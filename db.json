{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0},{"_id":"source/unrest/tabs.tag","path":"unrest/tabs.tag","modified":0},{"_id":"source/unrest/search.tag","path":"unrest/search.tag","modified":0},{"_id":"source/unrest/modal.tag","path":"unrest/modal.tag","modified":0},{"_id":"source/unrest/markdown.tag","path":"unrest/markdown.tag","modified":0},{"_id":"source/unrest/konsole.tag","path":"unrest/konsole.tag","modified":0},{"_id":"source/unrest/include.tag","path":"unrest/include.tag","modified":0},{"_id":"source/unrest/form.tag","path":"unrest/form.tag","modified":0},{"_id":"source/unrest/calendar.tag","path":"unrest/calendar.tag","modified":0},{"_id":"source/unrest/#tabs.tag#","path":"unrest/#tabs.tag#","modified":0}],"Cache":[{"_id":"themes/landscape/Gruntfile.js","shasum":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1453696099944},{"_id":"themes/landscape/LICENSE","shasum":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1453696099944},{"_id":"themes/landscape/README.md","shasum":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1453696099944},{"_id":"themes/landscape/_config.yml","shasum":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1453696099932},{"_id":"themes/landscape/languages/default.yml","shasum":"fd7397be7789b43c1c163ab4faf106318811c2a8","modified":1453696099932},{"_id":"themes/landscape/languages/zh-CN.yml","shasum":"751c74830d5609969f1fd6e7fa933ecd5756117a","modified":1453696099932},{"_id":"themes/landscape/languages/zh-TW.yml","shasum":"6141b4c7a094c74bd9df7c08908d92b561c1a0c0","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","shasum":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","shasum":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/archive.ejs","shasum":"30806481bc1233996e6f0c8ec59d23c3a55df034","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/article.ejs","shasum":"01201725258ad2aaee606cd4dfdebc21b646def1","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/footer.ejs","shasum":"4b19c1080c9e6c2acd922a88ed29d183a3b5bc09","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/head.ejs","shasum":"c02b8673ef726ca520e0d24361bedca846410295","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/header.ejs","shasum":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","shasum":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/post/category.ejs","shasum":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/post/date.ejs","shasum":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","shasum":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","shasum":"f26d30355ba9144c51e700e8edc6a4ab6144ff9a","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","shasum":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/post/title.ejs","shasum":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1453696099932},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","shasum":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1453696099932},{"_id":"themes/landscape/layout/_widget/archive.ejs","shasum":"71754895e33fd57a3d47c4e3bf52cb6aa25623f7","modified":1453696099932},{"_id":"themes/landscape/layout/_widget/category.ejs","shasum":"500217790ff080a6a20f96193a245a8c1e770e72","modified":1453696099932},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","shasum":"feba7c00fa59ba13bf870b358a499fde4473d335","modified":1453696099932},{"_id":"themes/landscape/layout/_widget/tag.ejs","shasum":"e9e367de7086b874e694389985236793f80251e0","modified":1453696099932},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","shasum":"34dc8cdd96cdb41dd11cb7513f13714373e5104a","modified":1453696099932},{"_id":"themes/landscape/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1453696099932},{"_id":"themes/landscape/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1453696099932},{"_id":"themes/landscape/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1453696099932},{"_id":"themes/landscape/layout/layout.ejs","shasum":"b83482b79e67416e3642b5e6b296c9941ea2d881","modified":1453696099932},{"_id":"themes/landscape/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1453696099932},{"_id":"themes/landscape/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1453696099932},{"_id":"themes/landscape/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1453696099932},{"_id":"themes/landscape/package.json","shasum":"85358dc34311c6662e841584e206a4679183943f","modified":1453696099944},{"_id":"themes/landscape/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1453696099932},{"_id":"themes/landscape/source/css/_extend.styl","shasum":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1453696099940},{"_id":"themes/landscape/source/css/_partial/archive.styl","shasum":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1453696099940},{"_id":"themes/landscape/source/css/_partial/article.styl","shasum":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1453696099940},{"_id":"themes/landscape/source/css/_partial/comment.styl","shasum":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1453696099940},{"_id":"themes/landscape/source/css/_partial/footer.styl","shasum":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1453696099940},{"_id":"themes/landscape/source/css/_partial/header.styl","shasum":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1453696099940},{"_id":"themes/landscape/source/css/_partial/highlight.styl","shasum":"82f5e9ed4c9e4f42c7f44b493cc897f8c3bf432d","modified":1453696099940},{"_id":"themes/landscape/source/css/_partial/highlight.styl~","shasum":"36eefe6332b86b66023a9884b754d305235846b4","modified":1453696099940},{"_id":"themes/landscape/source/css/_partial/mobile.styl","shasum":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1453696099940},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","shasum":"890349df5145abf46ce7712010c89237900b3713","modified":1453696099940},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","shasum":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1453696099940},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","shasum":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1453696099940},{"_id":"themes/landscape/source/css/_util/grid.styl","shasum":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1453696099940},{"_id":"themes/landscape/source/css/_util/mixin.styl","shasum":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1453696099940},{"_id":"themes/landscape/source/css/_variables.styl","shasum":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1453696099944},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1453696099944},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1453696099940},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1453696099940},{"_id":"themes/landscape/source/css/style.styl","shasum":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1453696099944},{"_id":"themes/landscape/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1453696099936},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1453696099936},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1453696099936},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1453696099936},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1453696099936},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1453696099936},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1453696099936},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1453696099936},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1453696099936},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1453696099936},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1453696099936},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1453696099936},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1453696099932},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1453696099936},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1453696099936},{"_id":"themes/landscape/source/js/script.js","shasum":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1453696099936},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1453696099944},{"_id":"source/_posts/2014/03/css-serpinski-triangle.md","shasum":"97c070fcef84039f6218b49f0e175c93cf1d90e1","modified":1453696099928},{"_id":"source/_posts/2014/03/css-serpinski-triangle.md~","shasum":"4ee551a8fbf52d760e3d8211938ea06dfaa782cc","modified":1453696099928},{"_id":"source/_posts/2016/01/Riot-Tabs.md","shasum":"754276744addd03875545a95207120e39344a221","modified":1453696099928},{"_id":"source/_posts/2016/01/Riot-Tabs.md~","shasum":"f2d2737fbede236d3217947c16444e8c29b5567b","modified":1453696099928},{"_id":"source/_posts/2016/01/scroll-header.md","shasum":"97b106538f1e737c37fe30a6f61a15c2553cc631","modified":1453696099928},{"_id":"source/_posts/2016/01/scroll-header.md~","shasum":"475a9beaa64c93bbc91c73660e3609acd3190d7f","modified":1453696099928},{"_id":"source/_posts/2016/01/what.md","shasum":"1d1f25baee3882a7a42d6e19ffffbda4c083db69","modified":1453696099928},{"_id":"source/_posts/_old/2014-03-12-css-serpinski-triangle.md","shasum":"4ee551a8fbf52d760e3d8211938ea06dfaa782cc","modified":1453696099928},{"_id":"source/_posts/_old/2014-04-12-pure-css-golden-spiral.md","shasum":"895e62b548b005590479ccfbda965a752c83ad01","modified":1453696099928},{"_id":"source/_posts/_old/2014-04-15-intro-to-programming.md","shasum":"7ed575d14a82c712810fe871c634ee6846a45969","modified":1453696099928},{"_id":"source/_posts/_old/2014-04-19-smcamerons-curly-vortex.md","shasum":"85a8818f24016b5559fe8825f7e965568dbaaae3","modified":1453696099928},{"_id":"source/_posts/_old/2014-04-29-intro-to-programming-day-2.md","shasum":"c66c56bc77fc3842a48866c1af13f01c399d569a","modified":1453696099928},{"_id":"source/_posts/_old/2014-05-07-intro-to-programming-day-3.md","shasum":"d76610aefc602c213c84dfca7d6bd147508e191b","modified":1453696099928},{"_id":"source/_posts/_old/2014-07-25-python-social-auth-tutorial.md","shasum":"432818e2d59709b26d83512821337288d470463a","modified":1453696099928},{"_id":"source/_posts/_old/2015-02-08-yapc-1-a-good-start.md","shasum":"190946571b11a63571c1eafb9546cb99597ffccb","modified":1453696099928},{"_id":"source/downloads/code/2016/01/scroll.css","shasum":"3a77cc506225ebd0b9b679a14b09da773956fbbc","modified":1453696099932},{"_id":"source/downloads/code/2016/01/scroll.js","shasum":"64b450c5b66d0bc8a4741613ea8195ee858e509e","modified":1453696099932},{"_id":"source/unrest/#tabs.tag#","shasum":"f511044da295f49e17734987ae2f0ce4b86846ab","modified":1453670465524},{"_id":"source/unrest/bower.json","shasum":"039a8dcb53d29f6e50e22e841c0ba0962e790b24","modified":1450321880976},{"_id":"source/unrest/bower_components/riot/bower.json","shasum":"625c246106a2e708ff080553c3abb700a1c21dcf","modified":1450213882000},{"_id":"source/unrest/bower_components/riot/riot+compiler.min.js","shasum":"7ee737c2e7cc9f1be294e4aa7519312eadbb934b","modified":1450213882000},{"_id":"source/unrest/bower_components/riot/riot.js","shasum":"5a32a915cb015ff658c7160410eda166dbc0ed27","modified":1450213882000},{"_id":"source/unrest/bower_components/riot/riot.min.js","shasum":"989a6c0ccf4b4159e0b30ac1f3c3bce2e6cf920f","modified":1450213882000},{"_id":"source/unrest/calendar.tag","shasum":"a0fe5a7add60ea66fa961cf615a3c8e252abc752","modified":1447018680432},{"_id":"source/unrest/calendar.tag~","shasum":"181359dea7fc71b02c80fd8f33f96c86a6d03d52","modified":1446431618043},{"_id":"source/unrest/demo.js","shasum":"d3747080c0d6b55c2e349cca863241b78eafabf3","modified":1453587346704},{"_id":"source/unrest/demo.js~","shasum":"d92abfd24fd3344f7de436259d345554eb574b7e","modified":1446564681304},{"_id":"source/unrest/form.tag","shasum":"b0fd6704ffaf78a2db581605ffc1d054dc964d8f","modified":1453587168036},{"_id":"source/unrest/http.min.js","shasum":"4a185e3f7482d99edabf3c6855c386b15708217b","modified":1446565618828},{"_id":"source/unrest/include.tag","shasum":"1768713f1d557058dd6feb95529bb222cf5d8972","modified":1452998437200},{"_id":"source/unrest/include.tag~","shasum":"ef89eea533e3391835f2ea305e943f505264f5c8","modified":1452998345536},{"_id":"source/unrest/index.html","shasum":"748cd3cbdb142b09afb20d27717a5f0c9ad059d7","modified":1453590368540},{"_id":"source/unrest/index.html~","shasum":"35211dc7e7dc267b813c74584ef6f7a8dae76ca5","modified":1446565236328},{"_id":"source/unrest/konsole.tag","shasum":"35fd5e577d41f2513307de387705e33d39d9a765","modified":1449809196128},{"_id":"source/unrest/konsole.tag~","shasum":"46f3d4b32e005d5c757a3fc3f29a59b3a753f57d","modified":1449808982452},{"_id":"source/unrest/markdown.tag","shasum":"9cbdc4845d4604c518eaa43d7b676e208c8fd2b4","modified":1453585156824},{"_id":"source/unrest/modal.tag","shasum":"39c59b259d62f1ce3001d1e344bc5b05a9a3dfb1","modified":1453587168036},{"_id":"source/unrest/search.tag","shasum":"3c1dcb1ddf657e34f86e91086f2e8855729516cf","modified":1450417909868},{"_id":"source/unrest/search.tag~","shasum":"570843d7c3ca4cf15ae910d3b062de823f25101f","modified":1450417861976},{"_id":"source/unrest/tabs.tag","shasum":"5ab3e1a3709007724e4ccfea292435918301e43a","modified":1453670428744},{"_id":"source/unrest/test.js","shasum":"3f9396e92bc73b683ed82b1cd1af7044d7c579b1","modified":1446013159683},{"_id":"source/unrest/unrest.js","shasum":"4580e63afcd99ed2b5e269d34177f0feaebd05e7","modified":1453587168036},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1453696099944},{"_id":"themes/landscape/source/css/images/banner.jpg","shasum":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1453696099940},{"_id":"source/unrest/bower_components/riot/riot+compiler.js","shasum":"39d6c16e50df9c467f18fb10c21f691de638e314","modified":1450213882000},{"_id":"source/unrest/moment.js","shasum":"65395e3e55adc5e2953e03c8378faa5cd0e324de","modified":1444275668000}],"Category":[],"Data":[],"Page":[{"_content":"var uR = (function() {\n  function serialize(form) {\n    var field, s = [];\n    if (typeof form != 'object' && form.nodeName != \"FORM\") { return }\n    var len = form.elements.length;\n    for (i=0; i<len; i++) {\n      field = form.elements[i];\n      if (!field.name || field.disabled || field.type == 'file' || field.type == 'reset' ||\n          field.type == 'submit' || field.type == 'button') { continue }\n      if (field.type == 'select-multiple') {\n        for (j=form.elements[i].options.length-1; j>=0; j--) {\n          if(field.options[j].selected)\n            s[s.length] = encodeURIComponent(field.name) + \"=\" + encodeURIComponent(field.options[j].value);\n        }\n      } else if ((field.type != 'checkbox' && field.type != 'radio') || field.checked) {\n        s[s.length] = encodeURIComponent(field.name) + \"=\" + encodeURIComponent(field.value);\n      }\n    }\n    return s.join('&').replace(/%20/g, '+');\n  }\n\n  cookie = {\n    set: function (name,value,days) {\n      var expires = \"\";\n      if (days) {\n        var date = new Date();\n        date.setTime(date.getTime()+(days*24*60*60*1000));\n        expires = \"; expires=\"+date.toGMTString();\n      }\n      document.cookie = name+\"=\"+value+expires+\"; path=/\";\n    },\n    get: function(name) {\n      var nameEQ = name + \"=\";\n      var ca = document.cookie.split(';');\n      for(var i=0;i < ca.length;i++) {\n        var c = ca[i];\n        while (c.charAt(0)==' ') c = c.substring(1,c.length);\n        if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);\n      }\n      return null;\n    },\n    delete: function (name) { createCookie(name,\"\",-1); }\n  }\n\n  function isEmpty(obj) {\n    for (key in obj) { return false; }\n    return true;\n  }\n\n  function ajax(opts) {\n    // create default options\n    var type = opts.type || \"GET\";\n    var data = opts.data;\n    var field = opts.target || opts.form;\n    var url = opts.url || opts.form.action;\n    var loading_attribute = opts.loading_attribute || \"\";\n    var success = opts.success || function(data,request) {};\n    var error = opts.error || function(data,request) {};\n    var that = opts.that;\n\n    // mark as loading\n    if (field) { field.setAttribute(\"data-loading\",loading_attribute); }\n\n    // create form_data from data or form\n    if (!data && opts.form) {\n      data = {};\n      var elements = opts.form.elements;\n      for (var i=0;i<elements.length;i++) {\n        data[elements[i].name] = elements[i].value;\n      }\n    }\n    // POST uses FormData, GET uses query string\n    var form_data = new FormData();\n    if (type==\"POST\") { for (var key in data) { form_data.append(key,data[key]); }; }\n    else {\n      url += \"?\"\n      for (key in data) { url += key + \"=\" + data[key] + \"&\" }\n    }\n\n    // create and send XHR\n    var request = new XMLHttpRequest();\n    request.open(type, url , true);\n\n    if (type == \"POST\") { request.setRequestHeader(\"X-CSRFToken\",cookie.get(\"csrftoken\")); }\n    request.onload = function(){\n      try { var data = JSON.parse(request.response); }\n      catch (e) {\n          var data = {};\n      }\n      if (field) { field.removeAttribute('data-loading'); }\n      var errors = data.errors || {};\n      if (isEmpty(errors) && request.status != 200) {\n        var e = opts.default_error || \"An unknown error has occurred\";\n        errors = { non_field_errors: e };\n      }\n      if (that) {\n        that.non_field_errors = [];\n        forEach(that.fields,function(field,i) {\n          if (errors[field.name]) { field.errors.push(errors[field.name]); }\n        });\n        if (errors.non_field_errors) { that.non_field_errors.push(errors.non_field_errors); }\n      }\n      var callback = (request.status == 200)?success:error;\n      callback(data,request);\n      if (that) { that.update(); }\n    };\n    request.send(form_data);\n  }\n\n  function debounce(func,wait,immediate) {\n    var timeout, wait = wait || 200;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) func.apply(context, args);\n      return true;\n    };\n  }\n\n  function dedribble(func, wait, end_bounce) {\n    var timeout, wait = wait || 200, end_bounce = end_bounce && true ;\n    var last = new Date();\n    return function() {\n      var context = this, args = arguments;\n      if (end_bounce) {\n        var later = function() {\n          timeout = null;\n          func.apply(context, args);\n        };\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n      }\n      if (new Date() - last > wait) { func.apply(context, args); last = new Date(); }\n    };\n  };\n\n  function forEach(array,func) {\n    for (var i=0;i<array.length;i++) { func(array[i],i,array); }\n  }\n  return {\n    serialize: serialize,\n    ajax: ajax,\n    debounce: debounce,\n    forEach: forEach,\n    dedribble: dedribble,\n    cookie: cookie\n  }\n})()\n  \n","source":"unrest/unrest.js","raw":"var uR = (function() {\n  function serialize(form) {\n    var field, s = [];\n    if (typeof form != 'object' && form.nodeName != \"FORM\") { return }\n    var len = form.elements.length;\n    for (i=0; i<len; i++) {\n      field = form.elements[i];\n      if (!field.name || field.disabled || field.type == 'file' || field.type == 'reset' ||\n          field.type == 'submit' || field.type == 'button') { continue }\n      if (field.type == 'select-multiple') {\n        for (j=form.elements[i].options.length-1; j>=0; j--) {\n          if(field.options[j].selected)\n            s[s.length] = encodeURIComponent(field.name) + \"=\" + encodeURIComponent(field.options[j].value);\n        }\n      } else if ((field.type != 'checkbox' && field.type != 'radio') || field.checked) {\n        s[s.length] = encodeURIComponent(field.name) + \"=\" + encodeURIComponent(field.value);\n      }\n    }\n    return s.join('&').replace(/%20/g, '+');\n  }\n\n  cookie = {\n    set: function (name,value,days) {\n      var expires = \"\";\n      if (days) {\n        var date = new Date();\n        date.setTime(date.getTime()+(days*24*60*60*1000));\n        expires = \"; expires=\"+date.toGMTString();\n      }\n      document.cookie = name+\"=\"+value+expires+\"; path=/\";\n    },\n    get: function(name) {\n      var nameEQ = name + \"=\";\n      var ca = document.cookie.split(';');\n      for(var i=0;i < ca.length;i++) {\n        var c = ca[i];\n        while (c.charAt(0)==' ') c = c.substring(1,c.length);\n        if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);\n      }\n      return null;\n    },\n    delete: function (name) { createCookie(name,\"\",-1); }\n  }\n\n  function isEmpty(obj) {\n    for (key in obj) { return false; }\n    return true;\n  }\n\n  function ajax(opts) {\n    // create default options\n    var type = opts.type || \"GET\";\n    var data = opts.data;\n    var field = opts.target || opts.form;\n    var url = opts.url || opts.form.action;\n    var loading_attribute = opts.loading_attribute || \"\";\n    var success = opts.success || function(data,request) {};\n    var error = opts.error || function(data,request) {};\n    var that = opts.that;\n\n    // mark as loading\n    if (field) { field.setAttribute(\"data-loading\",loading_attribute); }\n\n    // create form_data from data or form\n    if (!data && opts.form) {\n      data = {};\n      var elements = opts.form.elements;\n      for (var i=0;i<elements.length;i++) {\n        data[elements[i].name] = elements[i].value;\n      }\n    }\n    // POST uses FormData, GET uses query string\n    var form_data = new FormData();\n    if (type==\"POST\") { for (var key in data) { form_data.append(key,data[key]); }; }\n    else {\n      url += \"?\"\n      for (key in data) { url += key + \"=\" + data[key] + \"&\" }\n    }\n\n    // create and send XHR\n    var request = new XMLHttpRequest();\n    request.open(type, url , true);\n\n    if (type == \"POST\") { request.setRequestHeader(\"X-CSRFToken\",cookie.get(\"csrftoken\")); }\n    request.onload = function(){\n      try { var data = JSON.parse(request.response); }\n      catch (e) {\n          var data = {};\n      }\n      if (field) { field.removeAttribute('data-loading'); }\n      var errors = data.errors || {};\n      if (isEmpty(errors) && request.status != 200) {\n        var e = opts.default_error || \"An unknown error has occurred\";\n        errors = { non_field_errors: e };\n      }\n      if (that) {\n        that.non_field_errors = [];\n        forEach(that.fields,function(field,i) {\n          if (errors[field.name]) { field.errors.push(errors[field.name]); }\n        });\n        if (errors.non_field_errors) { that.non_field_errors.push(errors.non_field_errors); }\n      }\n      var callback = (request.status == 200)?success:error;\n      callback(data,request);\n      if (that) { that.update(); }\n    };\n    request.send(form_data);\n  }\n\n  function debounce(func,wait,immediate) {\n    var timeout, wait = wait || 200;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) func.apply(context, args);\n      return true;\n    };\n  }\n\n  function dedribble(func, wait, end_bounce) {\n    var timeout, wait = wait || 200, end_bounce = end_bounce && true ;\n    var last = new Date();\n    return function() {\n      var context = this, args = arguments;\n      if (end_bounce) {\n        var later = function() {\n          timeout = null;\n          func.apply(context, args);\n        };\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n      }\n      if (new Date() - last > wait) { func.apply(context, args); last = new Date(); }\n    };\n  };\n\n  function forEach(array,func) {\n    for (var i=0;i<array.length;i++) { func(array[i],i,array); }\n  }\n  return {\n    serialize: serialize,\n    ajax: ajax,\n    debounce: debounce,\n    forEach: forEach,\n    dedribble: dedribble,\n    cookie: cookie\n  }\n})()\n  \n","date":"2016-01-23T22:12:48.036Z","updated":"2016-01-23T22:12:48.036Z","path":"unrest/unrest.js","layout":"false","title":"","comments":1,"_id":"cijth4la300050nfwby22u19d"},{"_content":"console.log('what fun')\n","source":"unrest/test.js","raw":"console.log('what fun')\n","date":"2015-10-28T06:19:19.683Z","updated":"2015-10-28T06:19:19.683Z","path":"unrest/test.js","layout":"false","title":"","comments":1,"_id":"cijth4la500060nfwce7rm3si"},{"_content":"//! moment.js\n//! version : 2.10.6\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    global.moment = factory()\n}(this, function () { 'use strict';\n\n    var hookCallback;\n\n    function utils_hooks__hooks () {\n        return hookCallback.apply(null, arguments);\n    }\n\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback (callback) {\n        hookCallback = callback;\n    }\n\n    function isArray(input) {\n        return Object.prototype.toString.call(input) === '[object Array]';\n    }\n\n    function isDate(input) {\n        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n    }\n\n    function map(arr, fn) {\n        var res = [], i;\n        for (i = 0; i < arr.length; ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    function create_utc__createUTC (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty           : false,\n            unusedTokens    : [],\n            unusedInput     : [],\n            overflow        : -2,\n            charsLeftOver   : 0,\n            nullInput       : false,\n            invalidMonth    : null,\n            invalidFormat   : false,\n            userInvalidated : false,\n            iso             : false\n        };\n    }\n\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n\n    function valid__isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m);\n            m._isValid = !isNaN(m._d.getTime()) &&\n                flags.overflow < 0 &&\n                !flags.empty &&\n                !flags.invalidMonth &&\n                !flags.invalidWeekday &&\n                !flags.nullInput &&\n                !flags.invalidFormat &&\n                !flags.userInvalidated;\n\n            if (m._strict) {\n                m._isValid = m._isValid &&\n                    flags.charsLeftOver === 0 &&\n                    flags.unusedTokens.length === 0 &&\n                    flags.bigHour === undefined;\n            }\n        }\n        return m._isValid;\n    }\n\n    function valid__createInvalid (flags) {\n        var m = create_utc__createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        }\n        else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n\n        return m;\n    }\n\n    var momentProperties = utils_hooks__hooks.momentProperties = [];\n\n    function copyConfig(to, from) {\n        var i, prop, val;\n\n        if (typeof from._isAMomentObject !== 'undefined') {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (typeof from._i !== 'undefined') {\n            to._i = from._i;\n        }\n        if (typeof from._f !== 'undefined') {\n            to._f = from._f;\n        }\n        if (typeof from._l !== 'undefined') {\n            to._l = from._l;\n        }\n        if (typeof from._strict !== 'undefined') {\n            to._strict = from._strict;\n        }\n        if (typeof from._tzm !== 'undefined') {\n            to._tzm = from._tzm;\n        }\n        if (typeof from._isUTC !== 'undefined') {\n            to._isUTC = from._isUTC;\n        }\n        if (typeof from._offset !== 'undefined') {\n            to._offset = from._offset;\n        }\n        if (typeof from._pf !== 'undefined') {\n            to._pf = getParsingFlags(from);\n        }\n        if (typeof from._locale !== 'undefined') {\n            to._locale = from._locale;\n        }\n\n        if (momentProperties.length > 0) {\n            for (i in momentProperties) {\n                prop = momentProperties[i];\n                val = from[prop];\n                if (typeof val !== 'undefined') {\n                    to[prop] = val;\n                }\n            }\n        }\n\n        return to;\n    }\n\n    var updateInProgress = false;\n\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            utils_hooks__hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n\n    function isMoment (obj) {\n        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n    }\n\n    function absFloor (number) {\n        if (number < 0) {\n            return Math.ceil(number);\n        } else {\n            return Math.floor(number);\n        }\n    }\n\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n\n        return value;\n    }\n\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n            lengthDiff = Math.abs(array1.length - array2.length),\n            diffs = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if ((dontConvert && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n\n    function Locale() {\n    }\n\n    var locales = {};\n    var globalLocale;\n\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale, split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split('-') : null;\n            while (j > 0) {\n                locale = loadLocale(split.slice(0, j).join('-'));\n                if (locale) {\n                    return locale;\n                }\n                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                    //the next array item is better than a shallower substring of this one\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return null;\n    }\n\n    function loadLocale(name) {\n        var oldLocale = null;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (!locales[name] && typeof module !== 'undefined' &&\n                module && module.exports) {\n            try {\n                oldLocale = globalLocale._abbr;\n                require('./locale/' + name);\n                // because defineLocale currently also sets the global locale, we\n                // want to undo that for lazy loaded locales\n                locale_locales__getSetGlobalLocale(oldLocale);\n            } catch (e) { }\n        }\n        return locales[name];\n    }\n\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function locale_locales__getSetGlobalLocale (key, values) {\n        var data;\n        if (key) {\n            if (typeof values === 'undefined') {\n                data = locale_locales__getLocale(key);\n            }\n            else {\n                data = defineLocale(key, values);\n            }\n\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            }\n        }\n\n        return globalLocale._abbr;\n    }\n\n    function defineLocale (name, values) {\n        if (values !== null) {\n            values.abbr = name;\n            locales[name] = locales[name] || new Locale();\n            locales[name].set(values);\n\n            // backwards compat for now: also set the locale\n            locale_locales__getSetGlobalLocale(name);\n\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n\n    // returns locale data\n    function locale_locales__getLocale (key) {\n        var locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n\n        if (!key) {\n            return globalLocale;\n        }\n\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [key];\n        }\n\n        return chooseLocale(key);\n    }\n\n    var aliases = {};\n\n    function addUnitAlias (unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n    }\n\n    function normalizeUnits(units) {\n        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n\n        return normalizedInput;\n    }\n\n    function makeGetSet (unit, keepTime) {\n        return function (value) {\n            if (value != null) {\n                get_set__set(this, unit, value);\n                utils_hooks__hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get_set__get(this, unit);\n            }\n        };\n    }\n\n    function get_set__get (mom, unit) {\n        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();\n    }\n\n    function get_set__set (mom, unit, value) {\n        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n    }\n\n    // MOMENTS\n\n    function getSet (units, value) {\n        var unit;\n        if (typeof units === 'object') {\n            for (unit in units) {\n                this.set(unit, units[unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (typeof this[units] === 'function') {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = '' + Math.abs(number),\n            zerosToFill = targetLength - absNumber.length,\n            sign = number >= 0;\n        return (sign ? (forceSign ? '+' : '') : '-') +\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n    }\n\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\n    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\n    var formatFunctions = {};\n\n    var formatTokenFunctions = {};\n\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken (token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === 'string') {\n            func = function () {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function () {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function () {\n                return this.localeData().ordinal(func.apply(this, arguments), token);\n            };\n        }\n    }\n\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens), i, length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return function (mom) {\n            var output = '';\n            for (i = 0; i < length; i++) {\n                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];\n            }\n            return output;\n        };\n    }\n\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\n        return formatFunctions[format](m);\n    }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n\n        return format;\n    }\n\n    var match1         = /\\d/;            //       0 - 9\n    var match2         = /\\d\\d/;          //      00 - 99\n    var match3         = /\\d{3}/;         //     000 - 999\n    var match4         = /\\d{4}/;         //    0000 - 9999\n    var match6         = /[+-]?\\d{6}/;    // -999999 - 999999\n    var match1to2      = /\\d\\d?/;         //       0 - 99\n    var match1to3      = /\\d{1,3}/;       //       0 - 999\n    var match1to4      = /\\d{1,4}/;       //       0 - 9999\n    var match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\n    var matchUnsigned  = /\\d+/;           //       0 - inf\n    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\n    var matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\n\n    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\n    // any word (or two) characters or numbers including two/three word month in arabic.\n    var matchWord = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i;\n\n    var regexes = {};\n\n    function isFunction (sth) {\n        // https://github.com/moment/moment/issues/2325\n        return typeof sth === 'function' &&\n            Object.prototype.toString.call(sth) === '[object Function]';\n    }\n\n\n    function addRegexToken (token, regex, strictRegex) {\n        regexes[token] = isFunction(regex) ? regex : function (isStrict) {\n            return (isStrict && strictRegex) ? strictRegex : regex;\n        };\n    }\n\n    function getParseRegexForToken (token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n\n        return regexes[token](config._strict, config._locale);\n    }\n\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        }).replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    var tokens = {};\n\n    function addParseToken (token, callback) {\n        var i, func = callback;\n        if (typeof token === 'string') {\n            token = [token];\n        }\n        if (typeof callback === 'number') {\n            func = function (input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        for (i = 0; i < token.length; i++) {\n            tokens[token[i]] = func;\n        }\n    }\n\n    function addWeekParseToken (token, callback) {\n        addParseToken(token, function (input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n\n    var YEAR = 0;\n    var MONTH = 1;\n    var DATE = 2;\n    var HOUR = 3;\n    var MINUTE = 4;\n    var SECOND = 5;\n    var MILLISECOND = 6;\n\n    function daysInMonth(year, month) {\n        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();\n    }\n\n    // FORMATTING\n\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\n        return this.month() + 1;\n    });\n\n    addFormatToken('MMM', 0, 0, function (format) {\n        return this.localeData().monthsShort(this, format);\n    });\n\n    addFormatToken('MMMM', 0, 0, function (format) {\n        return this.localeData().months(this, format);\n    });\n\n    // ALIASES\n\n    addUnitAlias('month', 'M');\n\n    // PARSING\n\n    addRegexToken('M',    match1to2);\n    addRegexToken('MM',   match1to2, match2);\n    addRegexToken('MMM',  matchWord);\n    addRegexToken('MMMM', matchWord);\n\n    addParseToken(['M', 'MM'], function (input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n\n    // LOCALES\n\n    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\n    function localeMonths (m) {\n        return this._months[m.month()];\n    }\n\n    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\n    function localeMonthsShort (m) {\n        return this._monthsShort[m.month()];\n    }\n\n    function localeMonthsParse (monthName, format, strict) {\n        var i, mom, regex;\n\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = create_utc__createUTC([2000, i]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function setMonth (mom, value) {\n        var dayOfMonth;\n\n        // TODO: Move this out of here!\n        if (typeof value === 'string') {\n            value = mom.localeData().monthsParse(value);\n            // TODO: Another silent failure?\n            if (typeof value !== 'number') {\n                return mom;\n            }\n        }\n\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n        return mom;\n    }\n\n    function getSetMonth (value) {\n        if (value != null) {\n            setMonth(this, value);\n            utils_hooks__hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get_set__get(this, 'Month');\n        }\n    }\n\n    function getDaysInMonth () {\n        return daysInMonth(this.year(), this.month());\n    }\n\n    function checkOverflow (m) {\n        var overflow;\n        var a = m._a;\n\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow =\n                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n                -1;\n\n            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n            }\n\n            getParsingFlags(m).overflow = overflow;\n        }\n\n        return m;\n    }\n\n    function warn(msg) {\n        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n\n        return extend(function () {\n            if (firstTime) {\n                warn(msg + '\\n' + (new Error()).stack);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n    function deprecateSimple(name, msg) {\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    utils_hooks__hooks.suppressDeprecationWarnings = false;\n\n    var from_string__isoRegex = /^\\s*(?:[+-]\\d{6}|\\d{4})-(?:(\\d\\d-\\d\\d)|(W\\d\\d$)|(W\\d\\d-\\d)|(\\d\\d\\d))((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d+)?)?)?)?([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\n    var isoDates = [\n        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d{2}-\\d{2}/],\n        ['YYYY-MM-DD', /\\d{4}-\\d{2}-\\d{2}/],\n        ['GGGG-[W]WW-E', /\\d{4}-W\\d{2}-\\d/],\n        ['GGGG-[W]WW', /\\d{4}-W\\d{2}/],\n        ['YYYY-DDD', /\\d{4}-\\d{3}/]\n    ];\n\n    // iso time formats and regexes\n    var isoTimes = [\n        ['HH:mm:ss.SSSS', /(T| )\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n        ['HH:mm:ss', /(T| )\\d\\d:\\d\\d:\\d\\d/],\n        ['HH:mm', /(T| )\\d\\d:\\d\\d/],\n        ['HH', /(T| )\\d\\d/]\n    ];\n\n    var aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n    // date from iso format\n    function configFromISO(config) {\n        var i, l,\n            string = config._i,\n            match = from_string__isoRegex.exec(string);\n\n        if (match) {\n            getParsingFlags(config).iso = true;\n            for (i = 0, l = isoDates.length; i < l; i++) {\n                if (isoDates[i][1].exec(string)) {\n                    config._f = isoDates[i][0];\n                    break;\n                }\n            }\n            for (i = 0, l = isoTimes.length; i < l; i++) {\n                if (isoTimes[i][1].exec(string)) {\n                    // match[6] should be 'T' or space\n                    config._f += (match[6] || ' ') + isoTimes[i][0];\n                    break;\n                }\n            }\n            if (string.match(matchOffset)) {\n                config._f += 'Z';\n            }\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // date from iso format or fallback\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n            utils_hooks__hooks.createFromInputFallback(config);\n        }\n    }\n\n    utils_hooks__hooks.createFromInputFallback = deprecate(\n        'moment construction falls back to js Date. This is ' +\n        'discouraged and will be removed in upcoming major ' +\n        'release. Please refer to ' +\n        'https://github.com/moment/moment/issues/1407 for more info.',\n        function (config) {\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n    function createDate (y, m, d, h, M, s, ms) {\n        //can't just apply() to create a date:\n        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply\n        var date = new Date(y, m, d, h, M, s, ms);\n\n        //the date constructor doesn't accept years < 1970\n        if (y < 1970) {\n            date.setFullYear(y);\n        }\n        return date;\n    }\n\n    function createUTCDate (y) {\n        var date = new Date(Date.UTC.apply(null, arguments));\n        if (y < 1970) {\n            date.setUTCFullYear(y);\n        }\n        return date;\n    }\n\n    addFormatToken(0, ['YY', 2], 0, function () {\n        return this.year() % 100;\n    });\n\n    addFormatToken(0, ['YYYY',   4],       0, 'year');\n    addFormatToken(0, ['YYYYY',  5],       0, 'year');\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n    // ALIASES\n\n    addUnitAlias('year', 'y');\n\n    // PARSING\n\n    addRegexToken('Y',      matchSigned);\n    addRegexToken('YY',     match1to2, match2);\n    addRegexToken('YYYY',   match1to4, match4);\n    addRegexToken('YYYYY',  match1to6, match6);\n    addRegexToken('YYYYYY', match1to6, match6);\n\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n    addParseToken('YYYY', function (input, array) {\n        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken('YY', function (input, array) {\n        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);\n    });\n\n    // HELPERS\n\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    function isLeapYear(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n\n    // HOOKS\n\n    utils_hooks__hooks.parseTwoDigitYear = function (input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n    // MOMENTS\n\n    var getSetYear = makeGetSet('FullYear', false);\n\n    function getIsLeapYear () {\n        return isLeapYear(this.year());\n    }\n\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n    // ALIASES\n\n    addUnitAlias('week', 'w');\n    addUnitAlias('isoWeek', 'W');\n\n    // PARSING\n\n    addRegexToken('w',  match1to2);\n    addRegexToken('ww', match1to2, match2);\n    addRegexToken('W',  match1to2);\n    addRegexToken('WW', match1to2, match2);\n\n    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n        week[token.substr(0, 1)] = toInt(input);\n    });\n\n    // HELPERS\n\n    // firstDayOfWeek       0 = sun, 6 = sat\n    //                      the day of the week that starts the week\n    //                      (usually sunday or monday)\n    // firstDayOfWeekOfYear 0 = sun, 6 = sat\n    //                      the first week is the week that contains the first\n    //                      of this day of the week\n    //                      (eg. ISO weeks use thursday (4))\n    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {\n        var end = firstDayOfWeekOfYear - firstDayOfWeek,\n            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),\n            adjustedMoment;\n\n\n        if (daysToDayOfWeek > end) {\n            daysToDayOfWeek -= 7;\n        }\n\n        if (daysToDayOfWeek < end - 7) {\n            daysToDayOfWeek += 7;\n        }\n\n        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');\n        return {\n            week: Math.ceil(adjustedMoment.dayOfYear() / 7),\n            year: adjustedMoment.year()\n        };\n    }\n\n    // LOCALES\n\n    function localeWeek (mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n\n    var defaultLocaleWeek = {\n        dow : 0, // Sunday is the first day of the week.\n        doy : 6  // The week that contains Jan 1st is the first week of the year.\n    };\n\n    function localeFirstDayOfWeek () {\n        return this._week.dow;\n    }\n\n    function localeFirstDayOfYear () {\n        return this._week.doy;\n    }\n\n    // MOMENTS\n\n    function getSetWeek (input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    function getSetISOWeek (input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n    // ALIASES\n\n    addUnitAlias('dayOfYear', 'DDD');\n\n    // PARSING\n\n    addRegexToken('DDD',  match1to3);\n    addRegexToken('DDDD', match3);\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n\n    // HELPERS\n\n    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {\n        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;\n        if (d < firstDayOfWeek) {\n            d += 7;\n        }\n\n        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;\n\n        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;\n\n        return {\n            year: dayOfYear > 0 ? year : year - 1,\n            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear\n        };\n    }\n\n    // MOMENTS\n\n    function getSetDayOfYear (input) {\n        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function currentDateArray(config) {\n        var now = new Date();\n        if (config._useUTC) {\n            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];\n        }\n        return [now.getFullYear(), now.getMonth(), now.getDate()];\n    }\n\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray (config) {\n        var i, date, input = [], currentDate, yearToUse;\n\n        if (config._d) {\n            return;\n        }\n\n        currentDate = currentDateArray(config);\n\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n            if (config._dayOfYear > daysInYear(yearToUse)) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i] = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted, including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        // Check for 24:00:00.000\n        if (config._a[HOUR] === 24 &&\n                config._a[MINUTE] === 0 &&\n                config._a[SECOND] === 0 &&\n                config._a[MILLISECOND] === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n    }\n\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp;\n\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);\n            week = defaults(w.w, 1);\n\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < dow) {\n                    ++week;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from begining of week\n                weekday = w.e + dow;\n            } else {\n                // default to begining of week\n                weekday = dow;\n            }\n        }\n        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);\n\n        config._a[YEAR] = temp.year;\n        config._dayOfYear = temp.dayOfYear;\n    }\n\n    utils_hooks__hooks.ISO_8601 = function () {};\n\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === utils_hooks__hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n\n        config._a = [];\n        getParsingFlags(config).empty = true;\n\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = '' + config._i,\n            i, parsedInput, tokens, token, skipped,\n            stringLength = string.length,\n            totalParsedInputLength = 0;\n\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                }\n                else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            }\n            else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n\n        // clear _12h flag if hour is <= 12\n        if (getParsingFlags(config).bigHour === true &&\n                config._a[HOUR] <= 12 &&\n                config._a[HOUR] > 0) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n        configFromArray(config);\n        checkOverflow(config);\n    }\n\n\n    function meridiemFixWrap (locale, hour, meridiem) {\n        var isPm;\n\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n\n    function configFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n\n            scoreToBeat,\n            i,\n            currentScore;\n\n        if (config._f.length === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n        for (i = 0; i < config._f.length; i++) {\n            currentScore = 0;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n\n            if (!valid__isValid(tempConfig)) {\n                continue;\n            }\n\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n            getParsingFlags(tempConfig).score = currentScore;\n\n            if (scoreToBeat == null || currentScore < scoreToBeat) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n            }\n        }\n\n        extend(config, bestMoment || tempConfig);\n    }\n\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n\n        var i = normalizeObjectUnits(config._i);\n        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];\n\n        configFromArray(config);\n    }\n\n    function createFromConfig (config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n        return res;\n    }\n\n    function prepareConfig (config) {\n        var input = config._i,\n            format = config._f;\n\n        config._locale = config._locale || locale_locales__getLocale(config._l);\n\n        if (input === null || (format === undefined && input === '')) {\n            return valid__createInvalid({nullInput: true});\n        }\n\n        if (typeof input === 'string') {\n            config._i = input = config._locale.preparse(input);\n        }\n\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        } else if (isDate(input)) {\n            config._d = input;\n        } else {\n            configFromInput(config);\n        }\n\n        return config;\n    }\n\n    function configFromInput(config) {\n        var input = config._i;\n        if (input === undefined) {\n            config._d = new Date();\n        } else if (isDate(input)) {\n            config._d = new Date(+input);\n        } else if (typeof input === 'string') {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function (obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (typeof(input) === 'object') {\n            configFromObject(config);\n        } else if (typeof(input) === 'number') {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            utils_hooks__hooks.createFromInputFallback(config);\n        }\n    }\n\n    function createLocalOrUTC (input, format, locale, strict, isUTC) {\n        var c = {};\n\n        if (typeof(locale) === 'boolean') {\n            strict = locale;\n            locale = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n\n        return createFromConfig(c);\n    }\n\n    function local__createLocal (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n\n    var prototypeMin = deprecate(\n         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',\n         function () {\n             var other = local__createLocal.apply(null, arguments);\n             return other < this ? this : other;\n         }\n     );\n\n    var prototypeMax = deprecate(\n        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',\n        function () {\n            var other = local__createLocal.apply(null, arguments);\n            return other > this ? this : other;\n        }\n    );\n\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return local__createLocal();\n        }\n        res = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n\n    // TODO: Use [].sort instead?\n    function min () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isBefore', args);\n    }\n\n    function max () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n    }\n\n    function Duration (duration) {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter || 0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week || 0,\n            days = normalizedInput.day || 0,\n            hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds = normalizedInput.millisecond || 0;\n\n        // representation for dateAddRemove\n        this._milliseconds = +milliseconds +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 * 60\n            hours * 36e5; // 1000 * 60 * 60\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days +\n            weeks * 7;\n        // It is impossible translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months +\n            quarters * 3 +\n            years * 12;\n\n        this._data = {};\n\n        this._locale = locale_locales__getLocale();\n\n        this._bubble();\n    }\n\n    function isDuration (obj) {\n        return obj instanceof Duration;\n    }\n\n    function offset (token, separator) {\n        addFormatToken(token, 0, 0, function () {\n            var offset = this.utcOffset();\n            var sign = '+';\n            if (offset < 0) {\n                offset = -offset;\n                sign = '-';\n            }\n            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n        });\n    }\n\n    offset('Z', ':');\n    offset('ZZ', '');\n\n    // PARSING\n\n    addRegexToken('Z',  matchOffset);\n    addRegexToken('ZZ', matchOffset);\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(input);\n    });\n\n    // HELPERS\n\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n    function offsetFromString(string) {\n        var matches = ((string || '').match(matchOffset) || []);\n        var chunk   = matches[matches.length - 1] || [];\n        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n        var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return parts[0] === '+' ? minutes : -minutes;\n    }\n\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(+res._d + diff);\n            utils_hooks__hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return local__createLocal(input).local();\n        }\n    }\n\n    function getDateOffset (m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n    }\n\n    // HOOKS\n\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    utils_hooks__hooks.updateOffset = function () {};\n\n    // MOMENTS\n\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset (input, keepLocalTime) {\n        var offset = this._offset || 0,\n            localAdjust;\n        if (input != null) {\n            if (typeof input === 'string') {\n                input = offsetFromString(input);\n            }\n            if (Math.abs(input) < 16) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, 'm');\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    utils_hooks__hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n\n    function getSetZone (input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== 'string') {\n                input = -input;\n            }\n\n            this.utcOffset(input, keepLocalTime);\n\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n\n    function setOffsetToUTC (keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n\n    function setOffsetToLocal (keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), 'm');\n            }\n        }\n        return this;\n    }\n\n    function setOffsetToParsedOffset () {\n        if (this._tzm) {\n            this.utcOffset(this._tzm);\n        } else if (typeof this._i === 'string') {\n            this.utcOffset(offsetFromString(this._i));\n        }\n        return this;\n    }\n\n    function hasAlignedHourOffset (input) {\n        input = input ? local__createLocal(input).utcOffset() : 0;\n\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n\n    function isDaylightSavingTime () {\n        return (\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\n            this.utcOffset() > this.clone().month(5).utcOffset()\n        );\n    }\n\n    function isDaylightSavingTimeShifted () {\n        if (typeof this._isDSTShifted !== 'undefined') {\n            return this._isDSTShifted;\n        }\n\n        var c = {};\n\n        copyConfig(c, this);\n        c = prepareConfig(c);\n\n        if (c._a) {\n            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);\n            this._isDSTShifted = this.isValid() &&\n                compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n\n        return this._isDSTShifted;\n    }\n\n    function isLocal () {\n        return !this._isUTC;\n    }\n\n    function isUtcOffset () {\n        return this._isUTC;\n    }\n\n    function isUtc () {\n        return this._isUTC && this._offset === 0;\n    }\n\n    var aspNetRegex = /(\\-)?(?:(\\d*)\\.)?(\\d+)\\:(\\d+)(?:\\:(\\d+)\\.?(\\d{3})?)?/;\n\n    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;\n\n    function create__createDuration (input, key) {\n        var duration = input,\n            // matching against regexp is expensive, do it on demand\n            match = null,\n            sign,\n            ret,\n            diffRes;\n\n        if (isDuration(input)) {\n            duration = {\n                ms : input._milliseconds,\n                d  : input._days,\n                M  : input._months\n            };\n        } else if (typeof input === 'number') {\n            duration = {};\n            if (key) {\n                duration[key] = input;\n            } else {\n                duration.milliseconds = input;\n            }\n        } else if (!!(match = aspNetRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y  : 0,\n                d  : toInt(match[DATE])        * sign,\n                h  : toInt(match[HOUR])        * sign,\n                m  : toInt(match[MINUTE])      * sign,\n                s  : toInt(match[SECOND])      * sign,\n                ms : toInt(match[MILLISECOND]) * sign\n            };\n        } else if (!!(match = create__isoRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y : parseIso(match[2], sign),\n                M : parseIso(match[3], sign),\n                d : parseIso(match[4], sign),\n                h : parseIso(match[5], sign),\n                m : parseIso(match[6], sign),\n                s : parseIso(match[7], sign),\n                w : parseIso(match[8], sign)\n            };\n        } else if (duration == null) {// checks for null or undefined\n            duration = {};\n        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));\n\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale = input._locale;\n        }\n\n        return ret;\n    }\n\n    create__createDuration.fn = Duration.prototype;\n\n    function parseIso (inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',', '.'));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n\n    function positiveMomentsDifference(base, other) {\n        var res = {milliseconds: 0, months: 0};\n\n        res.months = other.month() - base.month() +\n            (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n        return res;\n    }\n\n    function momentsDifference(base, other) {\n        var res;\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return res;\n    }\n\n    function createAdder(direction, name) {\n        return function (val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');\n                tmp = val; val = period; period = tmp;\n            }\n\n            val = typeof val === 'string' ? +val : val;\n            dur = create__createDuration(val, period);\n            add_subtract__addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n\n    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds,\n            days = duration._days,\n            months = duration._months;\n        updateOffset = updateOffset == null ? true : updateOffset;\n\n        if (milliseconds) {\n            mom._d.setTime(+mom._d + milliseconds * isAdding);\n        }\n        if (days) {\n            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);\n        }\n        if (months) {\n            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);\n        }\n        if (updateOffset) {\n            utils_hooks__hooks.updateOffset(mom, days || months);\n        }\n    }\n\n    var add_subtract__add      = createAdder(1, 'add');\n    var add_subtract__subtract = createAdder(-1, 'subtract');\n\n    function moment_calendar__calendar (time, formats) {\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || local__createLocal(),\n            sod = cloneWithOffset(now, this).startOf('day'),\n            diff = this.diff(sod, 'days', true),\n            format = diff < -6 ? 'sameElse' :\n                diff < -1 ? 'lastWeek' :\n                diff < 0 ? 'lastDay' :\n                diff < 1 ? 'sameDay' :\n                diff < 2 ? 'nextDay' :\n                diff < 7 ? 'nextWeek' : 'sameElse';\n        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));\n    }\n\n    function clone () {\n        return new Moment(this);\n    }\n\n    function isAfter (input, units) {\n        var inputMs;\n        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');\n        if (units === 'millisecond') {\n            input = isMoment(input) ? input : local__createLocal(input);\n            return +this > +input;\n        } else {\n            inputMs = isMoment(input) ? +input : +local__createLocal(input);\n            return inputMs < +this.clone().startOf(units);\n        }\n    }\n\n    function isBefore (input, units) {\n        var inputMs;\n        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');\n        if (units === 'millisecond') {\n            input = isMoment(input) ? input : local__createLocal(input);\n            return +this < +input;\n        } else {\n            inputMs = isMoment(input) ? +input : +local__createLocal(input);\n            return +this.clone().endOf(units) < inputMs;\n        }\n    }\n\n    function isBetween (from, to, units) {\n        return this.isAfter(from, units) && this.isBefore(to, units);\n    }\n\n    function isSame (input, units) {\n        var inputMs;\n        units = normalizeUnits(units || 'millisecond');\n        if (units === 'millisecond') {\n            input = isMoment(input) ? input : local__createLocal(input);\n            return +this === +input;\n        } else {\n            inputMs = +local__createLocal(input);\n            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));\n        }\n    }\n\n    function diff (input, units, asFloat) {\n        var that = cloneWithOffset(input, this),\n            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,\n            delta, output;\n\n        units = normalizeUnits(units);\n\n        if (units === 'year' || units === 'month' || units === 'quarter') {\n            output = monthDiff(this, that);\n            if (units === 'quarter') {\n                output = output / 3;\n            } else if (units === 'year') {\n                output = output / 12;\n            }\n        } else {\n            delta = this - that;\n            output = units === 'second' ? delta / 1e3 : // 1000\n                units === 'minute' ? delta / 6e4 : // 1000 * 60\n                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60\n                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst\n                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst\n                delta;\n        }\n        return asFloat ? output : absFloor(output);\n    }\n\n    function monthDiff (a, b) {\n        // difference in months\n        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n            // b is in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\n            anchor2, adjust;\n\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n\n        return -(wholeMonthDiff + adjust);\n    }\n\n    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n\n    function toString () {\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n    }\n\n    function moment_format__toISOString () {\n        var m = this.clone().utc();\n        if (0 < m.year() && m.year() <= 9999) {\n            if ('function' === typeof Date.prototype.toISOString) {\n                // native implementation is ~50x faster, use it when we can\n                return this.toDate().toISOString();\n            } else {\n                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n            }\n        } else {\n            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n        }\n    }\n\n    function format (inputString) {\n        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);\n        return this.localeData().postformat(output);\n    }\n\n    function from (time, withoutSuffix) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n    }\n\n    function fromNow (withoutSuffix) {\n        return this.from(local__createLocal(), withoutSuffix);\n    }\n\n    function to (time, withoutSuffix) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n    }\n\n    function toNow (withoutSuffix) {\n        return this.to(local__createLocal(), withoutSuffix);\n    }\n\n    function locale (key) {\n        var newLocaleData;\n\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = locale_locales__getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n\n    var lang = deprecate(\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n        function (key) {\n            if (key === undefined) {\n                return this.localeData();\n            } else {\n                return this.locale(key);\n            }\n        }\n    );\n\n    function localeData () {\n        return this._locale;\n    }\n\n    function startOf (units) {\n        units = normalizeUnits(units);\n        // the following switch intentionally omits break keywords\n        // to utilize falling through the cases.\n        switch (units) {\n        case 'year':\n            this.month(0);\n            /* falls through */\n        case 'quarter':\n        case 'month':\n            this.date(1);\n            /* falls through */\n        case 'week':\n        case 'isoWeek':\n        case 'day':\n            this.hours(0);\n            /* falls through */\n        case 'hour':\n            this.minutes(0);\n            /* falls through */\n        case 'minute':\n            this.seconds(0);\n            /* falls through */\n        case 'second':\n            this.milliseconds(0);\n        }\n\n        // weeks are a special case\n        if (units === 'week') {\n            this.weekday(0);\n        }\n        if (units === 'isoWeek') {\n            this.isoWeekday(1);\n        }\n\n        // quarters are also special\n        if (units === 'quarter') {\n            this.month(Math.floor(this.month() / 3) * 3);\n        }\n\n        return this;\n    }\n\n    function endOf (units) {\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond') {\n            return this;\n        }\n        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n    }\n\n    function to_type__valueOf () {\n        return +this._d - ((this._offset || 0) * 60000);\n    }\n\n    function unix () {\n        return Math.floor(+this / 1000);\n    }\n\n    function toDate () {\n        return this._offset ? new Date(+this) : this._d;\n    }\n\n    function toArray () {\n        var m = this;\n        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n    }\n\n    function toObject () {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds()\n        };\n    }\n\n    function moment_valid__isValid () {\n        return valid__isValid(this);\n    }\n\n    function parsingFlags () {\n        return extend({}, getParsingFlags(this));\n    }\n\n    function invalidAt () {\n        return getParsingFlags(this).overflow;\n    }\n\n    addFormatToken(0, ['gg', 2], 0, function () {\n        return this.weekYear() % 100;\n    });\n\n    addFormatToken(0, ['GG', 2], 0, function () {\n        return this.isoWeekYear() % 100;\n    });\n\n    function addWeekYearFormatToken (token, getter) {\n        addFormatToken(0, [token, token.length], 0, getter);\n    }\n\n    addWeekYearFormatToken('gggg',     'weekYear');\n    addWeekYearFormatToken('ggggg',    'weekYear');\n    addWeekYearFormatToken('GGGG',  'isoWeekYear');\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n    // ALIASES\n\n    addUnitAlias('weekYear', 'gg');\n    addUnitAlias('isoWeekYear', 'GG');\n\n    // PARSING\n\n    addRegexToken('G',      matchSigned);\n    addRegexToken('g',      matchSigned);\n    addRegexToken('GG',     match1to2, match2);\n    addRegexToken('gg',     match1to2, match2);\n    addRegexToken('GGGG',   match1to4, match4);\n    addRegexToken('gggg',   match1to4, match4);\n    addRegexToken('GGGGG',  match1to6, match6);\n    addRegexToken('ggggg',  match1to6, match6);\n\n    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n        week[token.substr(0, 2)] = toInt(input);\n    });\n\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);\n    });\n\n    // HELPERS\n\n    function weeksInYear(year, dow, doy) {\n        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;\n    }\n\n    // MOMENTS\n\n    function getSetWeekYear (input) {\n        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;\n        return input == null ? year : this.add((input - year), 'y');\n    }\n\n    function getSetISOWeekYear (input) {\n        var year = weekOfYear(this, 1, 4).year;\n        return input == null ? year : this.add((input - year), 'y');\n    }\n\n    function getISOWeeksInYear () {\n        return weeksInYear(this.year(), 1, 4);\n    }\n\n    function getWeeksInYear () {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n\n    addFormatToken('Q', 0, 0, 'quarter');\n\n    // ALIASES\n\n    addUnitAlias('quarter', 'Q');\n\n    // PARSING\n\n    addRegexToken('Q', match1);\n    addParseToken('Q', function (input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n\n    // MOMENTS\n\n    function getSetQuarter (input) {\n        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n    }\n\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n    // ALIASES\n\n    addUnitAlias('date', 'D');\n\n    // PARSING\n\n    addRegexToken('D',  match1to2);\n    addRegexToken('DD', match1to2, match2);\n    addRegexToken('Do', function (isStrict, locale) {\n        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;\n    });\n\n    addParseToken(['D', 'DD'], DATE);\n    addParseToken('Do', function (input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0], 10);\n    });\n\n    // MOMENTS\n\n    var getSetDayOfMonth = makeGetSet('Date', true);\n\n    addFormatToken('d', 0, 'do', 'day');\n\n    addFormatToken('dd', 0, 0, function (format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n\n    addFormatToken('ddd', 0, 0, function (format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n\n    addFormatToken('dddd', 0, 0, function (format) {\n        return this.localeData().weekdays(this, format);\n    });\n\n    addFormatToken('e', 0, 0, 'weekday');\n    addFormatToken('E', 0, 0, 'isoWeekday');\n\n    // ALIASES\n\n    addUnitAlias('day', 'd');\n    addUnitAlias('weekday', 'e');\n    addUnitAlias('isoWeekday', 'E');\n\n    // PARSING\n\n    addRegexToken('d',    match1to2);\n    addRegexToken('e',    match1to2);\n    addRegexToken('E',    match1to2);\n    addRegexToken('dd',   matchWord);\n    addRegexToken('ddd',  matchWord);\n    addRegexToken('dddd', matchWord);\n\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {\n        var weekday = config._locale.weekdaysParse(input);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n        week[token] = toInt(input);\n    });\n\n    // HELPERS\n\n    function parseWeekday(input, locale) {\n        if (typeof input !== 'string') {\n            return input;\n        }\n\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n\n        input = locale.weekdaysParse(input);\n        if (typeof input === 'number') {\n            return input;\n        }\n\n        return null;\n    }\n\n    // LOCALES\n\n    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\n    function localeWeekdays (m) {\n        return this._weekdays[m.day()];\n    }\n\n    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\n    function localeWeekdaysShort (m) {\n        return this._weekdaysShort[m.day()];\n    }\n\n    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\n    function localeWeekdaysMin (m) {\n        return this._weekdaysMin[m.day()];\n    }\n\n    function localeWeekdaysParse (weekdayName) {\n        var i, mom, regex;\n\n        this._weekdaysParse = this._weekdaysParse || [];\n\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n            if (!this._weekdaysParse[i]) {\n                mom = local__createLocal([2000, 1]).day(i);\n                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function getSetDayOfWeek (input) {\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, 'd');\n        } else {\n            return day;\n        }\n    }\n\n    function getSetLocaleDayOfWeek (input) {\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, 'd');\n    }\n\n    function getSetISODayOfWeek (input) {\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);\n    }\n\n    addFormatToken('H', ['HH', 2], 0, 'hour');\n    addFormatToken('h', ['hh', 2], 0, function () {\n        return this.hours() % 12 || 12;\n    });\n\n    function meridiem (token, lowercase) {\n        addFormatToken(token, 0, 0, function () {\n            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n        });\n    }\n\n    meridiem('a', true);\n    meridiem('A', false);\n\n    // ALIASES\n\n    addUnitAlias('hour', 'h');\n\n    // PARSING\n\n    function matchMeridiem (isStrict, locale) {\n        return locale._meridiemParse;\n    }\n\n    addRegexToken('a',  matchMeridiem);\n    addRegexToken('A',  matchMeridiem);\n    addRegexToken('H',  match1to2);\n    addRegexToken('h',  match1to2);\n    addRegexToken('HH', match1to2, match2);\n    addRegexToken('hh', match1to2, match2);\n\n    addParseToken(['H', 'HH'], HOUR);\n    addParseToken(['a', 'A'], function (input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken(['h', 'hh'], function (input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n\n    // LOCALES\n\n    function localeIsPM (input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return ((input + '').toLowerCase().charAt(0) === 'p');\n    }\n\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\n    function localeMeridiem (hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? 'pm' : 'PM';\n        } else {\n            return isLower ? 'am' : 'AM';\n        }\n    }\n\n\n    // MOMENTS\n\n    // Setting the hour should keep the time, because the user explicitly\n    // specified which hour he wants. So trying to maintain the same hour (in\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\n    // this rule.\n    var getSetHour = makeGetSet('Hours', true);\n\n    addFormatToken('m', ['mm', 2], 0, 'minute');\n\n    // ALIASES\n\n    addUnitAlias('minute', 'm');\n\n    // PARSING\n\n    addRegexToken('m',  match1to2);\n    addRegexToken('mm', match1to2, match2);\n    addParseToken(['m', 'mm'], MINUTE);\n\n    // MOMENTS\n\n    var getSetMinute = makeGetSet('Minutes', false);\n\n    addFormatToken('s', ['ss', 2], 0, 'second');\n\n    // ALIASES\n\n    addUnitAlias('second', 's');\n\n    // PARSING\n\n    addRegexToken('s',  match1to2);\n    addRegexToken('ss', match1to2, match2);\n    addParseToken(['s', 'ss'], SECOND);\n\n    // MOMENTS\n\n    var getSetSecond = makeGetSet('Seconds', false);\n\n    addFormatToken('S', 0, 0, function () {\n        return ~~(this.millisecond() / 100);\n    });\n\n    addFormatToken(0, ['SS', 2], 0, function () {\n        return ~~(this.millisecond() / 10);\n    });\n\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n    addFormatToken(0, ['SSSS', 4], 0, function () {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n        return this.millisecond() * 1000000;\n    });\n\n\n    // ALIASES\n\n    addUnitAlias('millisecond', 'ms');\n\n    // PARSING\n\n    addRegexToken('S',    match1to3, match1);\n    addRegexToken('SS',   match1to3, match2);\n    addRegexToken('SSS',  match1to3, match3);\n\n    var token;\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n        addRegexToken(token, matchUnsigned);\n    }\n\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n    }\n\n    for (token = 'S'; token.length <= 9; token += 'S') {\n        addParseToken(token, parseMs);\n    }\n    // MOMENTS\n\n    var getSetMillisecond = makeGetSet('Milliseconds', false);\n\n    addFormatToken('z',  0, 0, 'zoneAbbr');\n    addFormatToken('zz', 0, 0, 'zoneName');\n\n    // MOMENTS\n\n    function getZoneAbbr () {\n        return this._isUTC ? 'UTC' : '';\n    }\n\n    function getZoneName () {\n        return this._isUTC ? 'Coordinated Universal Time' : '';\n    }\n\n    var momentPrototype__proto = Moment.prototype;\n\n    momentPrototype__proto.add          = add_subtract__add;\n    momentPrototype__proto.calendar     = moment_calendar__calendar;\n    momentPrototype__proto.clone        = clone;\n    momentPrototype__proto.diff         = diff;\n    momentPrototype__proto.endOf        = endOf;\n    momentPrototype__proto.format       = format;\n    momentPrototype__proto.from         = from;\n    momentPrototype__proto.fromNow      = fromNow;\n    momentPrototype__proto.to           = to;\n    momentPrototype__proto.toNow        = toNow;\n    momentPrototype__proto.get          = getSet;\n    momentPrototype__proto.invalidAt    = invalidAt;\n    momentPrototype__proto.isAfter      = isAfter;\n    momentPrototype__proto.isBefore     = isBefore;\n    momentPrototype__proto.isBetween    = isBetween;\n    momentPrototype__proto.isSame       = isSame;\n    momentPrototype__proto.isValid      = moment_valid__isValid;\n    momentPrototype__proto.lang         = lang;\n    momentPrototype__proto.locale       = locale;\n    momentPrototype__proto.localeData   = localeData;\n    momentPrototype__proto.max          = prototypeMax;\n    momentPrototype__proto.min          = prototypeMin;\n    momentPrototype__proto.parsingFlags = parsingFlags;\n    momentPrototype__proto.set          = getSet;\n    momentPrototype__proto.startOf      = startOf;\n    momentPrototype__proto.subtract     = add_subtract__subtract;\n    momentPrototype__proto.toArray      = toArray;\n    momentPrototype__proto.toObject     = toObject;\n    momentPrototype__proto.toDate       = toDate;\n    momentPrototype__proto.toISOString  = moment_format__toISOString;\n    momentPrototype__proto.toJSON       = moment_format__toISOString;\n    momentPrototype__proto.toString     = toString;\n    momentPrototype__proto.unix         = unix;\n    momentPrototype__proto.valueOf      = to_type__valueOf;\n\n    // Year\n    momentPrototype__proto.year       = getSetYear;\n    momentPrototype__proto.isLeapYear = getIsLeapYear;\n\n    // Week Year\n    momentPrototype__proto.weekYear    = getSetWeekYear;\n    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;\n\n    // Quarter\n    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;\n\n    // Month\n    momentPrototype__proto.month       = getSetMonth;\n    momentPrototype__proto.daysInMonth = getDaysInMonth;\n\n    // Week\n    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;\n    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;\n    momentPrototype__proto.weeksInYear    = getWeeksInYear;\n    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;\n\n    // Day\n    momentPrototype__proto.date       = getSetDayOfMonth;\n    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;\n    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;\n    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;\n    momentPrototype__proto.dayOfYear  = getSetDayOfYear;\n\n    // Hour\n    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;\n\n    // Minute\n    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;\n\n    // Second\n    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;\n\n    // Millisecond\n    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;\n\n    // Offset\n    momentPrototype__proto.utcOffset            = getSetOffset;\n    momentPrototype__proto.utc                  = setOffsetToUTC;\n    momentPrototype__proto.local                = setOffsetToLocal;\n    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;\n    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    momentPrototype__proto.isDST                = isDaylightSavingTime;\n    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;\n    momentPrototype__proto.isLocal              = isLocal;\n    momentPrototype__proto.isUtcOffset          = isUtcOffset;\n    momentPrototype__proto.isUtc                = isUtc;\n    momentPrototype__proto.isUTC                = isUtc;\n\n    // Timezone\n    momentPrototype__proto.zoneAbbr = getZoneAbbr;\n    momentPrototype__proto.zoneName = getZoneName;\n\n    // Deprecations\n    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);\n\n    var momentPrototype = momentPrototype__proto;\n\n    function moment__createUnix (input) {\n        return local__createLocal(input * 1000);\n    }\n\n    function moment__createInZone () {\n        return local__createLocal.apply(null, arguments).parseZone();\n    }\n\n    var defaultCalendar = {\n        sameDay : '[Today at] LT',\n        nextDay : '[Tomorrow at] LT',\n        nextWeek : 'dddd [at] LT',\n        lastDay : '[Yesterday at] LT',\n        lastWeek : '[Last] dddd [at] LT',\n        sameElse : 'L'\n    };\n\n    function locale_calendar__calendar (key, mom, now) {\n        var output = this._calendar[key];\n        return typeof output === 'function' ? output.call(mom, now) : output;\n    }\n\n    var defaultLongDateFormat = {\n        LTS  : 'h:mm:ss A',\n        LT   : 'h:mm A',\n        L    : 'MM/DD/YYYY',\n        LL   : 'MMMM D, YYYY',\n        LLL  : 'MMMM D, YYYY h:mm A',\n        LLLL : 'dddd, MMMM D, YYYY h:mm A'\n    };\n\n    function longDateFormat (key) {\n        var format = this._longDateFormat[key],\n            formatUpper = this._longDateFormat[key.toUpperCase()];\n\n        if (format || !formatUpper) {\n            return format;\n        }\n\n        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n            return val.slice(1);\n        });\n\n        return this._longDateFormat[key];\n    }\n\n    var defaultInvalidDate = 'Invalid date';\n\n    function invalidDate () {\n        return this._invalidDate;\n    }\n\n    var defaultOrdinal = '%d';\n    var defaultOrdinalParse = /\\d{1,2}/;\n\n    function ordinal (number) {\n        return this._ordinal.replace('%d', number);\n    }\n\n    function preParsePostFormat (string) {\n        return string;\n    }\n\n    var defaultRelativeTime = {\n        future : 'in %s',\n        past   : '%s ago',\n        s  : 'a few seconds',\n        m  : 'a minute',\n        mm : '%d minutes',\n        h  : 'an hour',\n        hh : '%d hours',\n        d  : 'a day',\n        dd : '%d days',\n        M  : 'a month',\n        MM : '%d months',\n        y  : 'a year',\n        yy : '%d years'\n    };\n\n    function relative__relativeTime (number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return (typeof output === 'function') ?\n            output(number, withoutSuffix, string, isFuture) :\n            output.replace(/%d/i, number);\n    }\n\n    function pastFuture (diff, output) {\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);\n    }\n\n    function locale_set__set (config) {\n        var prop, i;\n        for (i in config) {\n            prop = config[i];\n            if (typeof prop === 'function') {\n                this[i] = prop;\n            } else {\n                this['_' + i] = prop;\n            }\n        }\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _ordinalParseLenient.\n        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\\d{1,2}/).source);\n    }\n\n    var prototype__proto = Locale.prototype;\n\n    prototype__proto._calendar       = defaultCalendar;\n    prototype__proto.calendar        = locale_calendar__calendar;\n    prototype__proto._longDateFormat = defaultLongDateFormat;\n    prototype__proto.longDateFormat  = longDateFormat;\n    prototype__proto._invalidDate    = defaultInvalidDate;\n    prototype__proto.invalidDate     = invalidDate;\n    prototype__proto._ordinal        = defaultOrdinal;\n    prototype__proto.ordinal         = ordinal;\n    prototype__proto._ordinalParse   = defaultOrdinalParse;\n    prototype__proto.preparse        = preParsePostFormat;\n    prototype__proto.postformat      = preParsePostFormat;\n    prototype__proto._relativeTime   = defaultRelativeTime;\n    prototype__proto.relativeTime    = relative__relativeTime;\n    prototype__proto.pastFuture      = pastFuture;\n    prototype__proto.set             = locale_set__set;\n\n    // Month\n    prototype__proto.months       =        localeMonths;\n    prototype__proto._months      = defaultLocaleMonths;\n    prototype__proto.monthsShort  =        localeMonthsShort;\n    prototype__proto._monthsShort = defaultLocaleMonthsShort;\n    prototype__proto.monthsParse  =        localeMonthsParse;\n\n    // Week\n    prototype__proto.week = localeWeek;\n    prototype__proto._week = defaultLocaleWeek;\n    prototype__proto.firstDayOfYear = localeFirstDayOfYear;\n    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;\n\n    // Day of Week\n    prototype__proto.weekdays       =        localeWeekdays;\n    prototype__proto._weekdays      = defaultLocaleWeekdays;\n    prototype__proto.weekdaysMin    =        localeWeekdaysMin;\n    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;\n    prototype__proto.weekdaysShort  =        localeWeekdaysShort;\n    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;\n    prototype__proto.weekdaysParse  =        localeWeekdaysParse;\n\n    // Hours\n    prototype__proto.isPM = localeIsPM;\n    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;\n    prototype__proto.meridiem = localeMeridiem;\n\n    function lists__get (format, index, field, setter) {\n        var locale = locale_locales__getLocale();\n        var utc = create_utc__createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n\n    function list (format, index, field, count, setter) {\n        if (typeof format === 'number') {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n\n        if (index != null) {\n            return lists__get(format, index, field, setter);\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < count; i++) {\n            out[i] = lists__get(format, i, field, setter);\n        }\n        return out;\n    }\n\n    function lists__listMonths (format, index) {\n        return list(format, index, 'months', 12, 'month');\n    }\n\n    function lists__listMonthsShort (format, index) {\n        return list(format, index, 'monthsShort', 12, 'month');\n    }\n\n    function lists__listWeekdays (format, index) {\n        return list(format, index, 'weekdays', 7, 'day');\n    }\n\n    function lists__listWeekdaysShort (format, index) {\n        return list(format, index, 'weekdaysShort', 7, 'day');\n    }\n\n    function lists__listWeekdaysMin (format, index) {\n        return list(format, index, 'weekdaysMin', 7, 'day');\n    }\n\n    locale_locales__getSetGlobalLocale('en', {\n        ordinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (toInt(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        }\n    });\n\n    // Side effect imports\n    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);\n    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);\n\n    var mathAbs = Math.abs;\n\n    function duration_abs__abs () {\n        var data           = this._data;\n\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days         = mathAbs(this._days);\n        this._months       = mathAbs(this._months);\n\n        data.milliseconds  = mathAbs(data.milliseconds);\n        data.seconds       = mathAbs(data.seconds);\n        data.minutes       = mathAbs(data.minutes);\n        data.hours         = mathAbs(data.hours);\n        data.months        = mathAbs(data.months);\n        data.years         = mathAbs(data.years);\n\n        return this;\n    }\n\n    function duration_add_subtract__addSubtract (duration, input, value, direction) {\n        var other = create__createDuration(input, value);\n\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days         += direction * other._days;\n        duration._months       += direction * other._months;\n\n        return duration._bubble();\n    }\n\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function duration_add_subtract__add (input, value) {\n        return duration_add_subtract__addSubtract(this, input, value, 1);\n    }\n\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function duration_add_subtract__subtract (input, value) {\n        return duration_add_subtract__addSubtract(this, input, value, -1);\n    }\n\n    function absCeil (number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n\n    function bubble () {\n        var milliseconds = this._milliseconds;\n        var days         = this._days;\n        var months       = this._months;\n        var data         = this._data;\n        var seconds, minutes, hours, years, monthsFromDays;\n\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n                (milliseconds <= 0 && days <= 0 && months <= 0))) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n\n        seconds           = absFloor(milliseconds / 1000);\n        data.seconds      = seconds % 60;\n\n        minutes           = absFloor(seconds / 60);\n        data.minutes      = minutes % 60;\n\n        hours             = absFloor(minutes / 60);\n        data.hours        = hours % 24;\n\n        days += absFloor(hours / 24);\n\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        data.days   = days;\n        data.months = months;\n        data.years  = years;\n\n        return this;\n    }\n\n    function daysToMonths (days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return days * 4800 / 146097;\n    }\n\n    function monthsToDays (months) {\n        // the reverse of daysToMonths\n        return months * 146097 / 4800;\n    }\n\n    function as (units) {\n        var days;\n        var months;\n        var milliseconds = this._milliseconds;\n\n        units = normalizeUnits(units);\n\n        if (units === 'month' || units === 'year') {\n            days   = this._days   + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            return units === 'month' ? months : months / 12;\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch (units) {\n                case 'week'   : return days / 7     + milliseconds / 6048e5;\n                case 'day'    : return days         + milliseconds / 864e5;\n                case 'hour'   : return days * 24    + milliseconds / 36e5;\n                case 'minute' : return days * 1440  + milliseconds / 6e4;\n                case 'second' : return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n                default: throw new Error('Unknown unit ' + units);\n            }\n        }\n    }\n\n    // TODO: Use this.as('ms')?\n    function duration_as__valueOf () {\n        return (\n            this._milliseconds +\n            this._days * 864e5 +\n            (this._months % 12) * 2592e6 +\n            toInt(this._months / 12) * 31536e6\n        );\n    }\n\n    function makeAs (alias) {\n        return function () {\n            return this.as(alias);\n        };\n    }\n\n    var asMilliseconds = makeAs('ms');\n    var asSeconds      = makeAs('s');\n    var asMinutes      = makeAs('m');\n    var asHours        = makeAs('h');\n    var asDays         = makeAs('d');\n    var asWeeks        = makeAs('w');\n    var asMonths       = makeAs('M');\n    var asYears        = makeAs('y');\n\n    function duration_get__get (units) {\n        units = normalizeUnits(units);\n        return this[units + 's']();\n    }\n\n    function makeGetter(name) {\n        return function () {\n            return this._data[name];\n        };\n    }\n\n    var milliseconds = makeGetter('milliseconds');\n    var seconds      = makeGetter('seconds');\n    var minutes      = makeGetter('minutes');\n    var hours        = makeGetter('hours');\n    var days         = makeGetter('days');\n    var months       = makeGetter('months');\n    var years        = makeGetter('years');\n\n    function weeks () {\n        return absFloor(this.days() / 7);\n    }\n\n    var round = Math.round;\n    var thresholds = {\n        s: 45,  // seconds to minute\n        m: 45,  // minutes to hour\n        h: 22,  // hours to day\n        d: 26,  // days to month\n        M: 11   // months to year\n    };\n\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n\n    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {\n        var duration = create__createDuration(posNegDuration).abs();\n        var seconds  = round(duration.as('s'));\n        var minutes  = round(duration.as('m'));\n        var hours    = round(duration.as('h'));\n        var days     = round(duration.as('d'));\n        var months   = round(duration.as('M'));\n        var years    = round(duration.as('y'));\n\n        var a = seconds < thresholds.s && ['s', seconds]  ||\n                minutes === 1          && ['m']           ||\n                minutes < thresholds.m && ['mm', minutes] ||\n                hours   === 1          && ['h']           ||\n                hours   < thresholds.h && ['hh', hours]   ||\n                days    === 1          && ['d']           ||\n                days    < thresholds.d && ['dd', days]    ||\n                months  === 1          && ['M']           ||\n                months  < thresholds.M && ['MM', months]  ||\n                years   === 1          && ['y']           || ['yy', years];\n\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n\n    // This function allows you to set a threshold for relative time strings\n    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        return true;\n    }\n\n    function humanize (withSuffix) {\n        var locale = this.localeData();\n        var output = duration_humanize__relativeTime(this, !withSuffix, locale);\n\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n\n        return locale.postformat(output);\n    }\n\n    var iso_string__abs = Math.abs;\n\n    function iso_string__toISOString() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        var seconds = iso_string__abs(this._milliseconds) / 1000;\n        var days         = iso_string__abs(this._days);\n        var months       = iso_string__abs(this._months);\n        var minutes, hours, years;\n\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes           = absFloor(seconds / 60);\n        hours             = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n\n        // 12 months -> 1 year\n        years  = absFloor(months / 12);\n        months %= 12;\n\n\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        var Y = years;\n        var M = months;\n        var D = days;\n        var h = hours;\n        var m = minutes;\n        var s = seconds;\n        var total = this.asSeconds();\n\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return 'P0D';\n        }\n\n        return (total < 0 ? '-' : '') +\n            'P' +\n            (Y ? Y + 'Y' : '') +\n            (M ? M + 'M' : '') +\n            (D ? D + 'D' : '') +\n            ((h || m || s) ? 'T' : '') +\n            (h ? h + 'H' : '') +\n            (m ? m + 'M' : '') +\n            (s ? s + 'S' : '');\n    }\n\n    var duration_prototype__proto = Duration.prototype;\n\n    duration_prototype__proto.abs            = duration_abs__abs;\n    duration_prototype__proto.add            = duration_add_subtract__add;\n    duration_prototype__proto.subtract       = duration_add_subtract__subtract;\n    duration_prototype__proto.as             = as;\n    duration_prototype__proto.asMilliseconds = asMilliseconds;\n    duration_prototype__proto.asSeconds      = asSeconds;\n    duration_prototype__proto.asMinutes      = asMinutes;\n    duration_prototype__proto.asHours        = asHours;\n    duration_prototype__proto.asDays         = asDays;\n    duration_prototype__proto.asWeeks        = asWeeks;\n    duration_prototype__proto.asMonths       = asMonths;\n    duration_prototype__proto.asYears        = asYears;\n    duration_prototype__proto.valueOf        = duration_as__valueOf;\n    duration_prototype__proto._bubble        = bubble;\n    duration_prototype__proto.get            = duration_get__get;\n    duration_prototype__proto.milliseconds   = milliseconds;\n    duration_prototype__proto.seconds        = seconds;\n    duration_prototype__proto.minutes        = minutes;\n    duration_prototype__proto.hours          = hours;\n    duration_prototype__proto.days           = days;\n    duration_prototype__proto.weeks          = weeks;\n    duration_prototype__proto.months         = months;\n    duration_prototype__proto.years          = years;\n    duration_prototype__proto.humanize       = humanize;\n    duration_prototype__proto.toISOString    = iso_string__toISOString;\n    duration_prototype__proto.toString       = iso_string__toISOString;\n    duration_prototype__proto.toJSON         = iso_string__toISOString;\n    duration_prototype__proto.locale         = locale;\n    duration_prototype__proto.localeData     = localeData;\n\n    // Deprecations\n    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);\n    duration_prototype__proto.lang = lang;\n\n    // Side effect imports\n\n    addFormatToken('X', 0, 0, 'unix');\n    addFormatToken('x', 0, 0, 'valueOf');\n\n    // PARSING\n\n    addRegexToken('x', matchSigned);\n    addRegexToken('X', matchTimestamp);\n    addParseToken('X', function (input, array, config) {\n        config._d = new Date(parseFloat(input, 10) * 1000);\n    });\n    addParseToken('x', function (input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n\n    // Side effect imports\n\n\n    utils_hooks__hooks.version = '2.10.6';\n\n    setHookCallback(local__createLocal);\n\n    utils_hooks__hooks.fn                    = momentPrototype;\n    utils_hooks__hooks.min                   = min;\n    utils_hooks__hooks.max                   = max;\n    utils_hooks__hooks.utc                   = create_utc__createUTC;\n    utils_hooks__hooks.unix                  = moment__createUnix;\n    utils_hooks__hooks.months                = lists__listMonths;\n    utils_hooks__hooks.isDate                = isDate;\n    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;\n    utils_hooks__hooks.invalid               = valid__createInvalid;\n    utils_hooks__hooks.duration              = create__createDuration;\n    utils_hooks__hooks.isMoment              = isMoment;\n    utils_hooks__hooks.weekdays              = lists__listWeekdays;\n    utils_hooks__hooks.parseZone             = moment__createInZone;\n    utils_hooks__hooks.localeData            = locale_locales__getLocale;\n    utils_hooks__hooks.isDuration            = isDuration;\n    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;\n    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;\n    utils_hooks__hooks.defineLocale          = defineLocale;\n    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;\n    utils_hooks__hooks.normalizeUnits        = normalizeUnits;\n    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;\n\n    var _moment = utils_hooks__hooks;\n\n    return _moment;\n\n}));","source":"unrest/moment.js","raw":"//! moment.js\n//! version : 2.10.6\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    global.moment = factory()\n}(this, function () { 'use strict';\n\n    var hookCallback;\n\n    function utils_hooks__hooks () {\n        return hookCallback.apply(null, arguments);\n    }\n\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback (callback) {\n        hookCallback = callback;\n    }\n\n    function isArray(input) {\n        return Object.prototype.toString.call(input) === '[object Array]';\n    }\n\n    function isDate(input) {\n        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n    }\n\n    function map(arr, fn) {\n        var res = [], i;\n        for (i = 0; i < arr.length; ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    function create_utc__createUTC (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty           : false,\n            unusedTokens    : [],\n            unusedInput     : [],\n            overflow        : -2,\n            charsLeftOver   : 0,\n            nullInput       : false,\n            invalidMonth    : null,\n            invalidFormat   : false,\n            userInvalidated : false,\n            iso             : false\n        };\n    }\n\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n\n    function valid__isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m);\n            m._isValid = !isNaN(m._d.getTime()) &&\n                flags.overflow < 0 &&\n                !flags.empty &&\n                !flags.invalidMonth &&\n                !flags.invalidWeekday &&\n                !flags.nullInput &&\n                !flags.invalidFormat &&\n                !flags.userInvalidated;\n\n            if (m._strict) {\n                m._isValid = m._isValid &&\n                    flags.charsLeftOver === 0 &&\n                    flags.unusedTokens.length === 0 &&\n                    flags.bigHour === undefined;\n            }\n        }\n        return m._isValid;\n    }\n\n    function valid__createInvalid (flags) {\n        var m = create_utc__createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        }\n        else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n\n        return m;\n    }\n\n    var momentProperties = utils_hooks__hooks.momentProperties = [];\n\n    function copyConfig(to, from) {\n        var i, prop, val;\n\n        if (typeof from._isAMomentObject !== 'undefined') {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (typeof from._i !== 'undefined') {\n            to._i = from._i;\n        }\n        if (typeof from._f !== 'undefined') {\n            to._f = from._f;\n        }\n        if (typeof from._l !== 'undefined') {\n            to._l = from._l;\n        }\n        if (typeof from._strict !== 'undefined') {\n            to._strict = from._strict;\n        }\n        if (typeof from._tzm !== 'undefined') {\n            to._tzm = from._tzm;\n        }\n        if (typeof from._isUTC !== 'undefined') {\n            to._isUTC = from._isUTC;\n        }\n        if (typeof from._offset !== 'undefined') {\n            to._offset = from._offset;\n        }\n        if (typeof from._pf !== 'undefined') {\n            to._pf = getParsingFlags(from);\n        }\n        if (typeof from._locale !== 'undefined') {\n            to._locale = from._locale;\n        }\n\n        if (momentProperties.length > 0) {\n            for (i in momentProperties) {\n                prop = momentProperties[i];\n                val = from[prop];\n                if (typeof val !== 'undefined') {\n                    to[prop] = val;\n                }\n            }\n        }\n\n        return to;\n    }\n\n    var updateInProgress = false;\n\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            utils_hooks__hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n\n    function isMoment (obj) {\n        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n    }\n\n    function absFloor (number) {\n        if (number < 0) {\n            return Math.ceil(number);\n        } else {\n            return Math.floor(number);\n        }\n    }\n\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n\n        return value;\n    }\n\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n            lengthDiff = Math.abs(array1.length - array2.length),\n            diffs = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if ((dontConvert && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n\n    function Locale() {\n    }\n\n    var locales = {};\n    var globalLocale;\n\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale, split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split('-') : null;\n            while (j > 0) {\n                locale = loadLocale(split.slice(0, j).join('-'));\n                if (locale) {\n                    return locale;\n                }\n                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                    //the next array item is better than a shallower substring of this one\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return null;\n    }\n\n    function loadLocale(name) {\n        var oldLocale = null;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (!locales[name] && typeof module !== 'undefined' &&\n                module && module.exports) {\n            try {\n                oldLocale = globalLocale._abbr;\n                require('./locale/' + name);\n                // because defineLocale currently also sets the global locale, we\n                // want to undo that for lazy loaded locales\n                locale_locales__getSetGlobalLocale(oldLocale);\n            } catch (e) { }\n        }\n        return locales[name];\n    }\n\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function locale_locales__getSetGlobalLocale (key, values) {\n        var data;\n        if (key) {\n            if (typeof values === 'undefined') {\n                data = locale_locales__getLocale(key);\n            }\n            else {\n                data = defineLocale(key, values);\n            }\n\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            }\n        }\n\n        return globalLocale._abbr;\n    }\n\n    function defineLocale (name, values) {\n        if (values !== null) {\n            values.abbr = name;\n            locales[name] = locales[name] || new Locale();\n            locales[name].set(values);\n\n            // backwards compat for now: also set the locale\n            locale_locales__getSetGlobalLocale(name);\n\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n\n    // returns locale data\n    function locale_locales__getLocale (key) {\n        var locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n\n        if (!key) {\n            return globalLocale;\n        }\n\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [key];\n        }\n\n        return chooseLocale(key);\n    }\n\n    var aliases = {};\n\n    function addUnitAlias (unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n    }\n\n    function normalizeUnits(units) {\n        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n\n        return normalizedInput;\n    }\n\n    function makeGetSet (unit, keepTime) {\n        return function (value) {\n            if (value != null) {\n                get_set__set(this, unit, value);\n                utils_hooks__hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get_set__get(this, unit);\n            }\n        };\n    }\n\n    function get_set__get (mom, unit) {\n        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();\n    }\n\n    function get_set__set (mom, unit, value) {\n        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n    }\n\n    // MOMENTS\n\n    function getSet (units, value) {\n        var unit;\n        if (typeof units === 'object') {\n            for (unit in units) {\n                this.set(unit, units[unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (typeof this[units] === 'function') {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = '' + Math.abs(number),\n            zerosToFill = targetLength - absNumber.length,\n            sign = number >= 0;\n        return (sign ? (forceSign ? '+' : '') : '-') +\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n    }\n\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\n    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\n    var formatFunctions = {};\n\n    var formatTokenFunctions = {};\n\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken (token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === 'string') {\n            func = function () {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function () {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function () {\n                return this.localeData().ordinal(func.apply(this, arguments), token);\n            };\n        }\n    }\n\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens), i, length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return function (mom) {\n            var output = '';\n            for (i = 0; i < length; i++) {\n                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];\n            }\n            return output;\n        };\n    }\n\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\n        return formatFunctions[format](m);\n    }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n\n        return format;\n    }\n\n    var match1         = /\\d/;            //       0 - 9\n    var match2         = /\\d\\d/;          //      00 - 99\n    var match3         = /\\d{3}/;         //     000 - 999\n    var match4         = /\\d{4}/;         //    0000 - 9999\n    var match6         = /[+-]?\\d{6}/;    // -999999 - 999999\n    var match1to2      = /\\d\\d?/;         //       0 - 99\n    var match1to3      = /\\d{1,3}/;       //       0 - 999\n    var match1to4      = /\\d{1,4}/;       //       0 - 9999\n    var match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\n    var matchUnsigned  = /\\d+/;           //       0 - inf\n    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\n    var matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\n\n    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\n    // any word (or two) characters or numbers including two/three word month in arabic.\n    var matchWord = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i;\n\n    var regexes = {};\n\n    function isFunction (sth) {\n        // https://github.com/moment/moment/issues/2325\n        return typeof sth === 'function' &&\n            Object.prototype.toString.call(sth) === '[object Function]';\n    }\n\n\n    function addRegexToken (token, regex, strictRegex) {\n        regexes[token] = isFunction(regex) ? regex : function (isStrict) {\n            return (isStrict && strictRegex) ? strictRegex : regex;\n        };\n    }\n\n    function getParseRegexForToken (token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n\n        return regexes[token](config._strict, config._locale);\n    }\n\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        }).replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    var tokens = {};\n\n    function addParseToken (token, callback) {\n        var i, func = callback;\n        if (typeof token === 'string') {\n            token = [token];\n        }\n        if (typeof callback === 'number') {\n            func = function (input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        for (i = 0; i < token.length; i++) {\n            tokens[token[i]] = func;\n        }\n    }\n\n    function addWeekParseToken (token, callback) {\n        addParseToken(token, function (input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n\n    var YEAR = 0;\n    var MONTH = 1;\n    var DATE = 2;\n    var HOUR = 3;\n    var MINUTE = 4;\n    var SECOND = 5;\n    var MILLISECOND = 6;\n\n    function daysInMonth(year, month) {\n        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();\n    }\n\n    // FORMATTING\n\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\n        return this.month() + 1;\n    });\n\n    addFormatToken('MMM', 0, 0, function (format) {\n        return this.localeData().monthsShort(this, format);\n    });\n\n    addFormatToken('MMMM', 0, 0, function (format) {\n        return this.localeData().months(this, format);\n    });\n\n    // ALIASES\n\n    addUnitAlias('month', 'M');\n\n    // PARSING\n\n    addRegexToken('M',    match1to2);\n    addRegexToken('MM',   match1to2, match2);\n    addRegexToken('MMM',  matchWord);\n    addRegexToken('MMMM', matchWord);\n\n    addParseToken(['M', 'MM'], function (input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n\n    // LOCALES\n\n    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\n    function localeMonths (m) {\n        return this._months[m.month()];\n    }\n\n    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\n    function localeMonthsShort (m) {\n        return this._monthsShort[m.month()];\n    }\n\n    function localeMonthsParse (monthName, format, strict) {\n        var i, mom, regex;\n\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = create_utc__createUTC([2000, i]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function setMonth (mom, value) {\n        var dayOfMonth;\n\n        // TODO: Move this out of here!\n        if (typeof value === 'string') {\n            value = mom.localeData().monthsParse(value);\n            // TODO: Another silent failure?\n            if (typeof value !== 'number') {\n                return mom;\n            }\n        }\n\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n        return mom;\n    }\n\n    function getSetMonth (value) {\n        if (value != null) {\n            setMonth(this, value);\n            utils_hooks__hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get_set__get(this, 'Month');\n        }\n    }\n\n    function getDaysInMonth () {\n        return daysInMonth(this.year(), this.month());\n    }\n\n    function checkOverflow (m) {\n        var overflow;\n        var a = m._a;\n\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow =\n                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n                -1;\n\n            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n            }\n\n            getParsingFlags(m).overflow = overflow;\n        }\n\n        return m;\n    }\n\n    function warn(msg) {\n        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n\n        return extend(function () {\n            if (firstTime) {\n                warn(msg + '\\n' + (new Error()).stack);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n    function deprecateSimple(name, msg) {\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    utils_hooks__hooks.suppressDeprecationWarnings = false;\n\n    var from_string__isoRegex = /^\\s*(?:[+-]\\d{6}|\\d{4})-(?:(\\d\\d-\\d\\d)|(W\\d\\d$)|(W\\d\\d-\\d)|(\\d\\d\\d))((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d+)?)?)?)?([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\n    var isoDates = [\n        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d{2}-\\d{2}/],\n        ['YYYY-MM-DD', /\\d{4}-\\d{2}-\\d{2}/],\n        ['GGGG-[W]WW-E', /\\d{4}-W\\d{2}-\\d/],\n        ['GGGG-[W]WW', /\\d{4}-W\\d{2}/],\n        ['YYYY-DDD', /\\d{4}-\\d{3}/]\n    ];\n\n    // iso time formats and regexes\n    var isoTimes = [\n        ['HH:mm:ss.SSSS', /(T| )\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n        ['HH:mm:ss', /(T| )\\d\\d:\\d\\d:\\d\\d/],\n        ['HH:mm', /(T| )\\d\\d:\\d\\d/],\n        ['HH', /(T| )\\d\\d/]\n    ];\n\n    var aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n    // date from iso format\n    function configFromISO(config) {\n        var i, l,\n            string = config._i,\n            match = from_string__isoRegex.exec(string);\n\n        if (match) {\n            getParsingFlags(config).iso = true;\n            for (i = 0, l = isoDates.length; i < l; i++) {\n                if (isoDates[i][1].exec(string)) {\n                    config._f = isoDates[i][0];\n                    break;\n                }\n            }\n            for (i = 0, l = isoTimes.length; i < l; i++) {\n                if (isoTimes[i][1].exec(string)) {\n                    // match[6] should be 'T' or space\n                    config._f += (match[6] || ' ') + isoTimes[i][0];\n                    break;\n                }\n            }\n            if (string.match(matchOffset)) {\n                config._f += 'Z';\n            }\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // date from iso format or fallback\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n            utils_hooks__hooks.createFromInputFallback(config);\n        }\n    }\n\n    utils_hooks__hooks.createFromInputFallback = deprecate(\n        'moment construction falls back to js Date. This is ' +\n        'discouraged and will be removed in upcoming major ' +\n        'release. Please refer to ' +\n        'https://github.com/moment/moment/issues/1407 for more info.',\n        function (config) {\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n    function createDate (y, m, d, h, M, s, ms) {\n        //can't just apply() to create a date:\n        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply\n        var date = new Date(y, m, d, h, M, s, ms);\n\n        //the date constructor doesn't accept years < 1970\n        if (y < 1970) {\n            date.setFullYear(y);\n        }\n        return date;\n    }\n\n    function createUTCDate (y) {\n        var date = new Date(Date.UTC.apply(null, arguments));\n        if (y < 1970) {\n            date.setUTCFullYear(y);\n        }\n        return date;\n    }\n\n    addFormatToken(0, ['YY', 2], 0, function () {\n        return this.year() % 100;\n    });\n\n    addFormatToken(0, ['YYYY',   4],       0, 'year');\n    addFormatToken(0, ['YYYYY',  5],       0, 'year');\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n    // ALIASES\n\n    addUnitAlias('year', 'y');\n\n    // PARSING\n\n    addRegexToken('Y',      matchSigned);\n    addRegexToken('YY',     match1to2, match2);\n    addRegexToken('YYYY',   match1to4, match4);\n    addRegexToken('YYYYY',  match1to6, match6);\n    addRegexToken('YYYYYY', match1to6, match6);\n\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n    addParseToken('YYYY', function (input, array) {\n        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken('YY', function (input, array) {\n        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);\n    });\n\n    // HELPERS\n\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    function isLeapYear(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n\n    // HOOKS\n\n    utils_hooks__hooks.parseTwoDigitYear = function (input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n    // MOMENTS\n\n    var getSetYear = makeGetSet('FullYear', false);\n\n    function getIsLeapYear () {\n        return isLeapYear(this.year());\n    }\n\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n    // ALIASES\n\n    addUnitAlias('week', 'w');\n    addUnitAlias('isoWeek', 'W');\n\n    // PARSING\n\n    addRegexToken('w',  match1to2);\n    addRegexToken('ww', match1to2, match2);\n    addRegexToken('W',  match1to2);\n    addRegexToken('WW', match1to2, match2);\n\n    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n        week[token.substr(0, 1)] = toInt(input);\n    });\n\n    // HELPERS\n\n    // firstDayOfWeek       0 = sun, 6 = sat\n    //                      the day of the week that starts the week\n    //                      (usually sunday or monday)\n    // firstDayOfWeekOfYear 0 = sun, 6 = sat\n    //                      the first week is the week that contains the first\n    //                      of this day of the week\n    //                      (eg. ISO weeks use thursday (4))\n    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {\n        var end = firstDayOfWeekOfYear - firstDayOfWeek,\n            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),\n            adjustedMoment;\n\n\n        if (daysToDayOfWeek > end) {\n            daysToDayOfWeek -= 7;\n        }\n\n        if (daysToDayOfWeek < end - 7) {\n            daysToDayOfWeek += 7;\n        }\n\n        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');\n        return {\n            week: Math.ceil(adjustedMoment.dayOfYear() / 7),\n            year: adjustedMoment.year()\n        };\n    }\n\n    // LOCALES\n\n    function localeWeek (mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n\n    var defaultLocaleWeek = {\n        dow : 0, // Sunday is the first day of the week.\n        doy : 6  // The week that contains Jan 1st is the first week of the year.\n    };\n\n    function localeFirstDayOfWeek () {\n        return this._week.dow;\n    }\n\n    function localeFirstDayOfYear () {\n        return this._week.doy;\n    }\n\n    // MOMENTS\n\n    function getSetWeek (input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    function getSetISOWeek (input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n    // ALIASES\n\n    addUnitAlias('dayOfYear', 'DDD');\n\n    // PARSING\n\n    addRegexToken('DDD',  match1to3);\n    addRegexToken('DDDD', match3);\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n\n    // HELPERS\n\n    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {\n        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;\n        if (d < firstDayOfWeek) {\n            d += 7;\n        }\n\n        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;\n\n        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;\n\n        return {\n            year: dayOfYear > 0 ? year : year - 1,\n            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear\n        };\n    }\n\n    // MOMENTS\n\n    function getSetDayOfYear (input) {\n        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function currentDateArray(config) {\n        var now = new Date();\n        if (config._useUTC) {\n            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];\n        }\n        return [now.getFullYear(), now.getMonth(), now.getDate()];\n    }\n\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray (config) {\n        var i, date, input = [], currentDate, yearToUse;\n\n        if (config._d) {\n            return;\n        }\n\n        currentDate = currentDateArray(config);\n\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n            if (config._dayOfYear > daysInYear(yearToUse)) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i] = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted, including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        // Check for 24:00:00.000\n        if (config._a[HOUR] === 24 &&\n                config._a[MINUTE] === 0 &&\n                config._a[SECOND] === 0 &&\n                config._a[MILLISECOND] === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n    }\n\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp;\n\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);\n            week = defaults(w.w, 1);\n\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < dow) {\n                    ++week;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from begining of week\n                weekday = w.e + dow;\n            } else {\n                // default to begining of week\n                weekday = dow;\n            }\n        }\n        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);\n\n        config._a[YEAR] = temp.year;\n        config._dayOfYear = temp.dayOfYear;\n    }\n\n    utils_hooks__hooks.ISO_8601 = function () {};\n\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === utils_hooks__hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n\n        config._a = [];\n        getParsingFlags(config).empty = true;\n\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = '' + config._i,\n            i, parsedInput, tokens, token, skipped,\n            stringLength = string.length,\n            totalParsedInputLength = 0;\n\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                }\n                else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            }\n            else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n\n        // clear _12h flag if hour is <= 12\n        if (getParsingFlags(config).bigHour === true &&\n                config._a[HOUR] <= 12 &&\n                config._a[HOUR] > 0) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n        configFromArray(config);\n        checkOverflow(config);\n    }\n\n\n    function meridiemFixWrap (locale, hour, meridiem) {\n        var isPm;\n\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n\n    function configFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n\n            scoreToBeat,\n            i,\n            currentScore;\n\n        if (config._f.length === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n        for (i = 0; i < config._f.length; i++) {\n            currentScore = 0;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n\n            if (!valid__isValid(tempConfig)) {\n                continue;\n            }\n\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n            getParsingFlags(tempConfig).score = currentScore;\n\n            if (scoreToBeat == null || currentScore < scoreToBeat) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n            }\n        }\n\n        extend(config, bestMoment || tempConfig);\n    }\n\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n\n        var i = normalizeObjectUnits(config._i);\n        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];\n\n        configFromArray(config);\n    }\n\n    function createFromConfig (config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n        return res;\n    }\n\n    function prepareConfig (config) {\n        var input = config._i,\n            format = config._f;\n\n        config._locale = config._locale || locale_locales__getLocale(config._l);\n\n        if (input === null || (format === undefined && input === '')) {\n            return valid__createInvalid({nullInput: true});\n        }\n\n        if (typeof input === 'string') {\n            config._i = input = config._locale.preparse(input);\n        }\n\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        } else if (isDate(input)) {\n            config._d = input;\n        } else {\n            configFromInput(config);\n        }\n\n        return config;\n    }\n\n    function configFromInput(config) {\n        var input = config._i;\n        if (input === undefined) {\n            config._d = new Date();\n        } else if (isDate(input)) {\n            config._d = new Date(+input);\n        } else if (typeof input === 'string') {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function (obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (typeof(input) === 'object') {\n            configFromObject(config);\n        } else if (typeof(input) === 'number') {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            utils_hooks__hooks.createFromInputFallback(config);\n        }\n    }\n\n    function createLocalOrUTC (input, format, locale, strict, isUTC) {\n        var c = {};\n\n        if (typeof(locale) === 'boolean') {\n            strict = locale;\n            locale = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n\n        return createFromConfig(c);\n    }\n\n    function local__createLocal (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n\n    var prototypeMin = deprecate(\n         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',\n         function () {\n             var other = local__createLocal.apply(null, arguments);\n             return other < this ? this : other;\n         }\n     );\n\n    var prototypeMax = deprecate(\n        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',\n        function () {\n            var other = local__createLocal.apply(null, arguments);\n            return other > this ? this : other;\n        }\n    );\n\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return local__createLocal();\n        }\n        res = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n\n    // TODO: Use [].sort instead?\n    function min () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isBefore', args);\n    }\n\n    function max () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n    }\n\n    function Duration (duration) {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter || 0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week || 0,\n            days = normalizedInput.day || 0,\n            hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds = normalizedInput.millisecond || 0;\n\n        // representation for dateAddRemove\n        this._milliseconds = +milliseconds +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 * 60\n            hours * 36e5; // 1000 * 60 * 60\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days +\n            weeks * 7;\n        // It is impossible translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months +\n            quarters * 3 +\n            years * 12;\n\n        this._data = {};\n\n        this._locale = locale_locales__getLocale();\n\n        this._bubble();\n    }\n\n    function isDuration (obj) {\n        return obj instanceof Duration;\n    }\n\n    function offset (token, separator) {\n        addFormatToken(token, 0, 0, function () {\n            var offset = this.utcOffset();\n            var sign = '+';\n            if (offset < 0) {\n                offset = -offset;\n                sign = '-';\n            }\n            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n        });\n    }\n\n    offset('Z', ':');\n    offset('ZZ', '');\n\n    // PARSING\n\n    addRegexToken('Z',  matchOffset);\n    addRegexToken('ZZ', matchOffset);\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(input);\n    });\n\n    // HELPERS\n\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n    function offsetFromString(string) {\n        var matches = ((string || '').match(matchOffset) || []);\n        var chunk   = matches[matches.length - 1] || [];\n        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n        var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return parts[0] === '+' ? minutes : -minutes;\n    }\n\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(+res._d + diff);\n            utils_hooks__hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return local__createLocal(input).local();\n        }\n    }\n\n    function getDateOffset (m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n    }\n\n    // HOOKS\n\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    utils_hooks__hooks.updateOffset = function () {};\n\n    // MOMENTS\n\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset (input, keepLocalTime) {\n        var offset = this._offset || 0,\n            localAdjust;\n        if (input != null) {\n            if (typeof input === 'string') {\n                input = offsetFromString(input);\n            }\n            if (Math.abs(input) < 16) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, 'm');\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    utils_hooks__hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n\n    function getSetZone (input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== 'string') {\n                input = -input;\n            }\n\n            this.utcOffset(input, keepLocalTime);\n\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n\n    function setOffsetToUTC (keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n\n    function setOffsetToLocal (keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), 'm');\n            }\n        }\n        return this;\n    }\n\n    function setOffsetToParsedOffset () {\n        if (this._tzm) {\n            this.utcOffset(this._tzm);\n        } else if (typeof this._i === 'string') {\n            this.utcOffset(offsetFromString(this._i));\n        }\n        return this;\n    }\n\n    function hasAlignedHourOffset (input) {\n        input = input ? local__createLocal(input).utcOffset() : 0;\n\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n\n    function isDaylightSavingTime () {\n        return (\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\n            this.utcOffset() > this.clone().month(5).utcOffset()\n        );\n    }\n\n    function isDaylightSavingTimeShifted () {\n        if (typeof this._isDSTShifted !== 'undefined') {\n            return this._isDSTShifted;\n        }\n\n        var c = {};\n\n        copyConfig(c, this);\n        c = prepareConfig(c);\n\n        if (c._a) {\n            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);\n            this._isDSTShifted = this.isValid() &&\n                compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n\n        return this._isDSTShifted;\n    }\n\n    function isLocal () {\n        return !this._isUTC;\n    }\n\n    function isUtcOffset () {\n        return this._isUTC;\n    }\n\n    function isUtc () {\n        return this._isUTC && this._offset === 0;\n    }\n\n    var aspNetRegex = /(\\-)?(?:(\\d*)\\.)?(\\d+)\\:(\\d+)(?:\\:(\\d+)\\.?(\\d{3})?)?/;\n\n    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;\n\n    function create__createDuration (input, key) {\n        var duration = input,\n            // matching against regexp is expensive, do it on demand\n            match = null,\n            sign,\n            ret,\n            diffRes;\n\n        if (isDuration(input)) {\n            duration = {\n                ms : input._milliseconds,\n                d  : input._days,\n                M  : input._months\n            };\n        } else if (typeof input === 'number') {\n            duration = {};\n            if (key) {\n                duration[key] = input;\n            } else {\n                duration.milliseconds = input;\n            }\n        } else if (!!(match = aspNetRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y  : 0,\n                d  : toInt(match[DATE])        * sign,\n                h  : toInt(match[HOUR])        * sign,\n                m  : toInt(match[MINUTE])      * sign,\n                s  : toInt(match[SECOND])      * sign,\n                ms : toInt(match[MILLISECOND]) * sign\n            };\n        } else if (!!(match = create__isoRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y : parseIso(match[2], sign),\n                M : parseIso(match[3], sign),\n                d : parseIso(match[4], sign),\n                h : parseIso(match[5], sign),\n                m : parseIso(match[6], sign),\n                s : parseIso(match[7], sign),\n                w : parseIso(match[8], sign)\n            };\n        } else if (duration == null) {// checks for null or undefined\n            duration = {};\n        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));\n\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale = input._locale;\n        }\n\n        return ret;\n    }\n\n    create__createDuration.fn = Duration.prototype;\n\n    function parseIso (inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',', '.'));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n\n    function positiveMomentsDifference(base, other) {\n        var res = {milliseconds: 0, months: 0};\n\n        res.months = other.month() - base.month() +\n            (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n        return res;\n    }\n\n    function momentsDifference(base, other) {\n        var res;\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return res;\n    }\n\n    function createAdder(direction, name) {\n        return function (val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');\n                tmp = val; val = period; period = tmp;\n            }\n\n            val = typeof val === 'string' ? +val : val;\n            dur = create__createDuration(val, period);\n            add_subtract__addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n\n    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds,\n            days = duration._days,\n            months = duration._months;\n        updateOffset = updateOffset == null ? true : updateOffset;\n\n        if (milliseconds) {\n            mom._d.setTime(+mom._d + milliseconds * isAdding);\n        }\n        if (days) {\n            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);\n        }\n        if (months) {\n            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);\n        }\n        if (updateOffset) {\n            utils_hooks__hooks.updateOffset(mom, days || months);\n        }\n    }\n\n    var add_subtract__add      = createAdder(1, 'add');\n    var add_subtract__subtract = createAdder(-1, 'subtract');\n\n    function moment_calendar__calendar (time, formats) {\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || local__createLocal(),\n            sod = cloneWithOffset(now, this).startOf('day'),\n            diff = this.diff(sod, 'days', true),\n            format = diff < -6 ? 'sameElse' :\n                diff < -1 ? 'lastWeek' :\n                diff < 0 ? 'lastDay' :\n                diff < 1 ? 'sameDay' :\n                diff < 2 ? 'nextDay' :\n                diff < 7 ? 'nextWeek' : 'sameElse';\n        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));\n    }\n\n    function clone () {\n        return new Moment(this);\n    }\n\n    function isAfter (input, units) {\n        var inputMs;\n        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');\n        if (units === 'millisecond') {\n            input = isMoment(input) ? input : local__createLocal(input);\n            return +this > +input;\n        } else {\n            inputMs = isMoment(input) ? +input : +local__createLocal(input);\n            return inputMs < +this.clone().startOf(units);\n        }\n    }\n\n    function isBefore (input, units) {\n        var inputMs;\n        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');\n        if (units === 'millisecond') {\n            input = isMoment(input) ? input : local__createLocal(input);\n            return +this < +input;\n        } else {\n            inputMs = isMoment(input) ? +input : +local__createLocal(input);\n            return +this.clone().endOf(units) < inputMs;\n        }\n    }\n\n    function isBetween (from, to, units) {\n        return this.isAfter(from, units) && this.isBefore(to, units);\n    }\n\n    function isSame (input, units) {\n        var inputMs;\n        units = normalizeUnits(units || 'millisecond');\n        if (units === 'millisecond') {\n            input = isMoment(input) ? input : local__createLocal(input);\n            return +this === +input;\n        } else {\n            inputMs = +local__createLocal(input);\n            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));\n        }\n    }\n\n    function diff (input, units, asFloat) {\n        var that = cloneWithOffset(input, this),\n            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,\n            delta, output;\n\n        units = normalizeUnits(units);\n\n        if (units === 'year' || units === 'month' || units === 'quarter') {\n            output = monthDiff(this, that);\n            if (units === 'quarter') {\n                output = output / 3;\n            } else if (units === 'year') {\n                output = output / 12;\n            }\n        } else {\n            delta = this - that;\n            output = units === 'second' ? delta / 1e3 : // 1000\n                units === 'minute' ? delta / 6e4 : // 1000 * 60\n                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60\n                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst\n                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst\n                delta;\n        }\n        return asFloat ? output : absFloor(output);\n    }\n\n    function monthDiff (a, b) {\n        // difference in months\n        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n            // b is in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\n            anchor2, adjust;\n\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n\n        return -(wholeMonthDiff + adjust);\n    }\n\n    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n\n    function toString () {\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n    }\n\n    function moment_format__toISOString () {\n        var m = this.clone().utc();\n        if (0 < m.year() && m.year() <= 9999) {\n            if ('function' === typeof Date.prototype.toISOString) {\n                // native implementation is ~50x faster, use it when we can\n                return this.toDate().toISOString();\n            } else {\n                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n            }\n        } else {\n            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n        }\n    }\n\n    function format (inputString) {\n        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);\n        return this.localeData().postformat(output);\n    }\n\n    function from (time, withoutSuffix) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n    }\n\n    function fromNow (withoutSuffix) {\n        return this.from(local__createLocal(), withoutSuffix);\n    }\n\n    function to (time, withoutSuffix) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n    }\n\n    function toNow (withoutSuffix) {\n        return this.to(local__createLocal(), withoutSuffix);\n    }\n\n    function locale (key) {\n        var newLocaleData;\n\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = locale_locales__getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n\n    var lang = deprecate(\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n        function (key) {\n            if (key === undefined) {\n                return this.localeData();\n            } else {\n                return this.locale(key);\n            }\n        }\n    );\n\n    function localeData () {\n        return this._locale;\n    }\n\n    function startOf (units) {\n        units = normalizeUnits(units);\n        // the following switch intentionally omits break keywords\n        // to utilize falling through the cases.\n        switch (units) {\n        case 'year':\n            this.month(0);\n            /* falls through */\n        case 'quarter':\n        case 'month':\n            this.date(1);\n            /* falls through */\n        case 'week':\n        case 'isoWeek':\n        case 'day':\n            this.hours(0);\n            /* falls through */\n        case 'hour':\n            this.minutes(0);\n            /* falls through */\n        case 'minute':\n            this.seconds(0);\n            /* falls through */\n        case 'second':\n            this.milliseconds(0);\n        }\n\n        // weeks are a special case\n        if (units === 'week') {\n            this.weekday(0);\n        }\n        if (units === 'isoWeek') {\n            this.isoWeekday(1);\n        }\n\n        // quarters are also special\n        if (units === 'quarter') {\n            this.month(Math.floor(this.month() / 3) * 3);\n        }\n\n        return this;\n    }\n\n    function endOf (units) {\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond') {\n            return this;\n        }\n        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n    }\n\n    function to_type__valueOf () {\n        return +this._d - ((this._offset || 0) * 60000);\n    }\n\n    function unix () {\n        return Math.floor(+this / 1000);\n    }\n\n    function toDate () {\n        return this._offset ? new Date(+this) : this._d;\n    }\n\n    function toArray () {\n        var m = this;\n        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n    }\n\n    function toObject () {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds()\n        };\n    }\n\n    function moment_valid__isValid () {\n        return valid__isValid(this);\n    }\n\n    function parsingFlags () {\n        return extend({}, getParsingFlags(this));\n    }\n\n    function invalidAt () {\n        return getParsingFlags(this).overflow;\n    }\n\n    addFormatToken(0, ['gg', 2], 0, function () {\n        return this.weekYear() % 100;\n    });\n\n    addFormatToken(0, ['GG', 2], 0, function () {\n        return this.isoWeekYear() % 100;\n    });\n\n    function addWeekYearFormatToken (token, getter) {\n        addFormatToken(0, [token, token.length], 0, getter);\n    }\n\n    addWeekYearFormatToken('gggg',     'weekYear');\n    addWeekYearFormatToken('ggggg',    'weekYear');\n    addWeekYearFormatToken('GGGG',  'isoWeekYear');\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n    // ALIASES\n\n    addUnitAlias('weekYear', 'gg');\n    addUnitAlias('isoWeekYear', 'GG');\n\n    // PARSING\n\n    addRegexToken('G',      matchSigned);\n    addRegexToken('g',      matchSigned);\n    addRegexToken('GG',     match1to2, match2);\n    addRegexToken('gg',     match1to2, match2);\n    addRegexToken('GGGG',   match1to4, match4);\n    addRegexToken('gggg',   match1to4, match4);\n    addRegexToken('GGGGG',  match1to6, match6);\n    addRegexToken('ggggg',  match1to6, match6);\n\n    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n        week[token.substr(0, 2)] = toInt(input);\n    });\n\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);\n    });\n\n    // HELPERS\n\n    function weeksInYear(year, dow, doy) {\n        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;\n    }\n\n    // MOMENTS\n\n    function getSetWeekYear (input) {\n        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;\n        return input == null ? year : this.add((input - year), 'y');\n    }\n\n    function getSetISOWeekYear (input) {\n        var year = weekOfYear(this, 1, 4).year;\n        return input == null ? year : this.add((input - year), 'y');\n    }\n\n    function getISOWeeksInYear () {\n        return weeksInYear(this.year(), 1, 4);\n    }\n\n    function getWeeksInYear () {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n\n    addFormatToken('Q', 0, 0, 'quarter');\n\n    // ALIASES\n\n    addUnitAlias('quarter', 'Q');\n\n    // PARSING\n\n    addRegexToken('Q', match1);\n    addParseToken('Q', function (input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n\n    // MOMENTS\n\n    function getSetQuarter (input) {\n        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n    }\n\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n    // ALIASES\n\n    addUnitAlias('date', 'D');\n\n    // PARSING\n\n    addRegexToken('D',  match1to2);\n    addRegexToken('DD', match1to2, match2);\n    addRegexToken('Do', function (isStrict, locale) {\n        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;\n    });\n\n    addParseToken(['D', 'DD'], DATE);\n    addParseToken('Do', function (input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0], 10);\n    });\n\n    // MOMENTS\n\n    var getSetDayOfMonth = makeGetSet('Date', true);\n\n    addFormatToken('d', 0, 'do', 'day');\n\n    addFormatToken('dd', 0, 0, function (format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n\n    addFormatToken('ddd', 0, 0, function (format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n\n    addFormatToken('dddd', 0, 0, function (format) {\n        return this.localeData().weekdays(this, format);\n    });\n\n    addFormatToken('e', 0, 0, 'weekday');\n    addFormatToken('E', 0, 0, 'isoWeekday');\n\n    // ALIASES\n\n    addUnitAlias('day', 'd');\n    addUnitAlias('weekday', 'e');\n    addUnitAlias('isoWeekday', 'E');\n\n    // PARSING\n\n    addRegexToken('d',    match1to2);\n    addRegexToken('e',    match1to2);\n    addRegexToken('E',    match1to2);\n    addRegexToken('dd',   matchWord);\n    addRegexToken('ddd',  matchWord);\n    addRegexToken('dddd', matchWord);\n\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {\n        var weekday = config._locale.weekdaysParse(input);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n        week[token] = toInt(input);\n    });\n\n    // HELPERS\n\n    function parseWeekday(input, locale) {\n        if (typeof input !== 'string') {\n            return input;\n        }\n\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n\n        input = locale.weekdaysParse(input);\n        if (typeof input === 'number') {\n            return input;\n        }\n\n        return null;\n    }\n\n    // LOCALES\n\n    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\n    function localeWeekdays (m) {\n        return this._weekdays[m.day()];\n    }\n\n    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\n    function localeWeekdaysShort (m) {\n        return this._weekdaysShort[m.day()];\n    }\n\n    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\n    function localeWeekdaysMin (m) {\n        return this._weekdaysMin[m.day()];\n    }\n\n    function localeWeekdaysParse (weekdayName) {\n        var i, mom, regex;\n\n        this._weekdaysParse = this._weekdaysParse || [];\n\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n            if (!this._weekdaysParse[i]) {\n                mom = local__createLocal([2000, 1]).day(i);\n                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function getSetDayOfWeek (input) {\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, 'd');\n        } else {\n            return day;\n        }\n    }\n\n    function getSetLocaleDayOfWeek (input) {\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, 'd');\n    }\n\n    function getSetISODayOfWeek (input) {\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);\n    }\n\n    addFormatToken('H', ['HH', 2], 0, 'hour');\n    addFormatToken('h', ['hh', 2], 0, function () {\n        return this.hours() % 12 || 12;\n    });\n\n    function meridiem (token, lowercase) {\n        addFormatToken(token, 0, 0, function () {\n            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n        });\n    }\n\n    meridiem('a', true);\n    meridiem('A', false);\n\n    // ALIASES\n\n    addUnitAlias('hour', 'h');\n\n    // PARSING\n\n    function matchMeridiem (isStrict, locale) {\n        return locale._meridiemParse;\n    }\n\n    addRegexToken('a',  matchMeridiem);\n    addRegexToken('A',  matchMeridiem);\n    addRegexToken('H',  match1to2);\n    addRegexToken('h',  match1to2);\n    addRegexToken('HH', match1to2, match2);\n    addRegexToken('hh', match1to2, match2);\n\n    addParseToken(['H', 'HH'], HOUR);\n    addParseToken(['a', 'A'], function (input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken(['h', 'hh'], function (input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n\n    // LOCALES\n\n    function localeIsPM (input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return ((input + '').toLowerCase().charAt(0) === 'p');\n    }\n\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\n    function localeMeridiem (hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? 'pm' : 'PM';\n        } else {\n            return isLower ? 'am' : 'AM';\n        }\n    }\n\n\n    // MOMENTS\n\n    // Setting the hour should keep the time, because the user explicitly\n    // specified which hour he wants. So trying to maintain the same hour (in\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\n    // this rule.\n    var getSetHour = makeGetSet('Hours', true);\n\n    addFormatToken('m', ['mm', 2], 0, 'minute');\n\n    // ALIASES\n\n    addUnitAlias('minute', 'm');\n\n    // PARSING\n\n    addRegexToken('m',  match1to2);\n    addRegexToken('mm', match1to2, match2);\n    addParseToken(['m', 'mm'], MINUTE);\n\n    // MOMENTS\n\n    var getSetMinute = makeGetSet('Minutes', false);\n\n    addFormatToken('s', ['ss', 2], 0, 'second');\n\n    // ALIASES\n\n    addUnitAlias('second', 's');\n\n    // PARSING\n\n    addRegexToken('s',  match1to2);\n    addRegexToken('ss', match1to2, match2);\n    addParseToken(['s', 'ss'], SECOND);\n\n    // MOMENTS\n\n    var getSetSecond = makeGetSet('Seconds', false);\n\n    addFormatToken('S', 0, 0, function () {\n        return ~~(this.millisecond() / 100);\n    });\n\n    addFormatToken(0, ['SS', 2], 0, function () {\n        return ~~(this.millisecond() / 10);\n    });\n\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n    addFormatToken(0, ['SSSS', 4], 0, function () {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n        return this.millisecond() * 1000000;\n    });\n\n\n    // ALIASES\n\n    addUnitAlias('millisecond', 'ms');\n\n    // PARSING\n\n    addRegexToken('S',    match1to3, match1);\n    addRegexToken('SS',   match1to3, match2);\n    addRegexToken('SSS',  match1to3, match3);\n\n    var token;\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n        addRegexToken(token, matchUnsigned);\n    }\n\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n    }\n\n    for (token = 'S'; token.length <= 9; token += 'S') {\n        addParseToken(token, parseMs);\n    }\n    // MOMENTS\n\n    var getSetMillisecond = makeGetSet('Milliseconds', false);\n\n    addFormatToken('z',  0, 0, 'zoneAbbr');\n    addFormatToken('zz', 0, 0, 'zoneName');\n\n    // MOMENTS\n\n    function getZoneAbbr () {\n        return this._isUTC ? 'UTC' : '';\n    }\n\n    function getZoneName () {\n        return this._isUTC ? 'Coordinated Universal Time' : '';\n    }\n\n    var momentPrototype__proto = Moment.prototype;\n\n    momentPrototype__proto.add          = add_subtract__add;\n    momentPrototype__proto.calendar     = moment_calendar__calendar;\n    momentPrototype__proto.clone        = clone;\n    momentPrototype__proto.diff         = diff;\n    momentPrototype__proto.endOf        = endOf;\n    momentPrototype__proto.format       = format;\n    momentPrototype__proto.from         = from;\n    momentPrototype__proto.fromNow      = fromNow;\n    momentPrototype__proto.to           = to;\n    momentPrototype__proto.toNow        = toNow;\n    momentPrototype__proto.get          = getSet;\n    momentPrototype__proto.invalidAt    = invalidAt;\n    momentPrototype__proto.isAfter      = isAfter;\n    momentPrototype__proto.isBefore     = isBefore;\n    momentPrototype__proto.isBetween    = isBetween;\n    momentPrototype__proto.isSame       = isSame;\n    momentPrototype__proto.isValid      = moment_valid__isValid;\n    momentPrototype__proto.lang         = lang;\n    momentPrototype__proto.locale       = locale;\n    momentPrototype__proto.localeData   = localeData;\n    momentPrototype__proto.max          = prototypeMax;\n    momentPrototype__proto.min          = prototypeMin;\n    momentPrototype__proto.parsingFlags = parsingFlags;\n    momentPrototype__proto.set          = getSet;\n    momentPrototype__proto.startOf      = startOf;\n    momentPrototype__proto.subtract     = add_subtract__subtract;\n    momentPrototype__proto.toArray      = toArray;\n    momentPrototype__proto.toObject     = toObject;\n    momentPrototype__proto.toDate       = toDate;\n    momentPrototype__proto.toISOString  = moment_format__toISOString;\n    momentPrototype__proto.toJSON       = moment_format__toISOString;\n    momentPrototype__proto.toString     = toString;\n    momentPrototype__proto.unix         = unix;\n    momentPrototype__proto.valueOf      = to_type__valueOf;\n\n    // Year\n    momentPrototype__proto.year       = getSetYear;\n    momentPrototype__proto.isLeapYear = getIsLeapYear;\n\n    // Week Year\n    momentPrototype__proto.weekYear    = getSetWeekYear;\n    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;\n\n    // Quarter\n    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;\n\n    // Month\n    momentPrototype__proto.month       = getSetMonth;\n    momentPrototype__proto.daysInMonth = getDaysInMonth;\n\n    // Week\n    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;\n    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;\n    momentPrototype__proto.weeksInYear    = getWeeksInYear;\n    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;\n\n    // Day\n    momentPrototype__proto.date       = getSetDayOfMonth;\n    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;\n    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;\n    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;\n    momentPrototype__proto.dayOfYear  = getSetDayOfYear;\n\n    // Hour\n    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;\n\n    // Minute\n    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;\n\n    // Second\n    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;\n\n    // Millisecond\n    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;\n\n    // Offset\n    momentPrototype__proto.utcOffset            = getSetOffset;\n    momentPrototype__proto.utc                  = setOffsetToUTC;\n    momentPrototype__proto.local                = setOffsetToLocal;\n    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;\n    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    momentPrototype__proto.isDST                = isDaylightSavingTime;\n    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;\n    momentPrototype__proto.isLocal              = isLocal;\n    momentPrototype__proto.isUtcOffset          = isUtcOffset;\n    momentPrototype__proto.isUtc                = isUtc;\n    momentPrototype__proto.isUTC                = isUtc;\n\n    // Timezone\n    momentPrototype__proto.zoneAbbr = getZoneAbbr;\n    momentPrototype__proto.zoneName = getZoneName;\n\n    // Deprecations\n    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);\n\n    var momentPrototype = momentPrototype__proto;\n\n    function moment__createUnix (input) {\n        return local__createLocal(input * 1000);\n    }\n\n    function moment__createInZone () {\n        return local__createLocal.apply(null, arguments).parseZone();\n    }\n\n    var defaultCalendar = {\n        sameDay : '[Today at] LT',\n        nextDay : '[Tomorrow at] LT',\n        nextWeek : 'dddd [at] LT',\n        lastDay : '[Yesterday at] LT',\n        lastWeek : '[Last] dddd [at] LT',\n        sameElse : 'L'\n    };\n\n    function locale_calendar__calendar (key, mom, now) {\n        var output = this._calendar[key];\n        return typeof output === 'function' ? output.call(mom, now) : output;\n    }\n\n    var defaultLongDateFormat = {\n        LTS  : 'h:mm:ss A',\n        LT   : 'h:mm A',\n        L    : 'MM/DD/YYYY',\n        LL   : 'MMMM D, YYYY',\n        LLL  : 'MMMM D, YYYY h:mm A',\n        LLLL : 'dddd, MMMM D, YYYY h:mm A'\n    };\n\n    function longDateFormat (key) {\n        var format = this._longDateFormat[key],\n            formatUpper = this._longDateFormat[key.toUpperCase()];\n\n        if (format || !formatUpper) {\n            return format;\n        }\n\n        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n            return val.slice(1);\n        });\n\n        return this._longDateFormat[key];\n    }\n\n    var defaultInvalidDate = 'Invalid date';\n\n    function invalidDate () {\n        return this._invalidDate;\n    }\n\n    var defaultOrdinal = '%d';\n    var defaultOrdinalParse = /\\d{1,2}/;\n\n    function ordinal (number) {\n        return this._ordinal.replace('%d', number);\n    }\n\n    function preParsePostFormat (string) {\n        return string;\n    }\n\n    var defaultRelativeTime = {\n        future : 'in %s',\n        past   : '%s ago',\n        s  : 'a few seconds',\n        m  : 'a minute',\n        mm : '%d minutes',\n        h  : 'an hour',\n        hh : '%d hours',\n        d  : 'a day',\n        dd : '%d days',\n        M  : 'a month',\n        MM : '%d months',\n        y  : 'a year',\n        yy : '%d years'\n    };\n\n    function relative__relativeTime (number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return (typeof output === 'function') ?\n            output(number, withoutSuffix, string, isFuture) :\n            output.replace(/%d/i, number);\n    }\n\n    function pastFuture (diff, output) {\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);\n    }\n\n    function locale_set__set (config) {\n        var prop, i;\n        for (i in config) {\n            prop = config[i];\n            if (typeof prop === 'function') {\n                this[i] = prop;\n            } else {\n                this['_' + i] = prop;\n            }\n        }\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _ordinalParseLenient.\n        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\\d{1,2}/).source);\n    }\n\n    var prototype__proto = Locale.prototype;\n\n    prototype__proto._calendar       = defaultCalendar;\n    prototype__proto.calendar        = locale_calendar__calendar;\n    prototype__proto._longDateFormat = defaultLongDateFormat;\n    prototype__proto.longDateFormat  = longDateFormat;\n    prototype__proto._invalidDate    = defaultInvalidDate;\n    prototype__proto.invalidDate     = invalidDate;\n    prototype__proto._ordinal        = defaultOrdinal;\n    prototype__proto.ordinal         = ordinal;\n    prototype__proto._ordinalParse   = defaultOrdinalParse;\n    prototype__proto.preparse        = preParsePostFormat;\n    prototype__proto.postformat      = preParsePostFormat;\n    prototype__proto._relativeTime   = defaultRelativeTime;\n    prototype__proto.relativeTime    = relative__relativeTime;\n    prototype__proto.pastFuture      = pastFuture;\n    prototype__proto.set             = locale_set__set;\n\n    // Month\n    prototype__proto.months       =        localeMonths;\n    prototype__proto._months      = defaultLocaleMonths;\n    prototype__proto.monthsShort  =        localeMonthsShort;\n    prototype__proto._monthsShort = defaultLocaleMonthsShort;\n    prototype__proto.monthsParse  =        localeMonthsParse;\n\n    // Week\n    prototype__proto.week = localeWeek;\n    prototype__proto._week = defaultLocaleWeek;\n    prototype__proto.firstDayOfYear = localeFirstDayOfYear;\n    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;\n\n    // Day of Week\n    prototype__proto.weekdays       =        localeWeekdays;\n    prototype__proto._weekdays      = defaultLocaleWeekdays;\n    prototype__proto.weekdaysMin    =        localeWeekdaysMin;\n    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;\n    prototype__proto.weekdaysShort  =        localeWeekdaysShort;\n    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;\n    prototype__proto.weekdaysParse  =        localeWeekdaysParse;\n\n    // Hours\n    prototype__proto.isPM = localeIsPM;\n    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;\n    prototype__proto.meridiem = localeMeridiem;\n\n    function lists__get (format, index, field, setter) {\n        var locale = locale_locales__getLocale();\n        var utc = create_utc__createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n\n    function list (format, index, field, count, setter) {\n        if (typeof format === 'number') {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n\n        if (index != null) {\n            return lists__get(format, index, field, setter);\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < count; i++) {\n            out[i] = lists__get(format, i, field, setter);\n        }\n        return out;\n    }\n\n    function lists__listMonths (format, index) {\n        return list(format, index, 'months', 12, 'month');\n    }\n\n    function lists__listMonthsShort (format, index) {\n        return list(format, index, 'monthsShort', 12, 'month');\n    }\n\n    function lists__listWeekdays (format, index) {\n        return list(format, index, 'weekdays', 7, 'day');\n    }\n\n    function lists__listWeekdaysShort (format, index) {\n        return list(format, index, 'weekdaysShort', 7, 'day');\n    }\n\n    function lists__listWeekdaysMin (format, index) {\n        return list(format, index, 'weekdaysMin', 7, 'day');\n    }\n\n    locale_locales__getSetGlobalLocale('en', {\n        ordinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (toInt(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        }\n    });\n\n    // Side effect imports\n    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);\n    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);\n\n    var mathAbs = Math.abs;\n\n    function duration_abs__abs () {\n        var data           = this._data;\n\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days         = mathAbs(this._days);\n        this._months       = mathAbs(this._months);\n\n        data.milliseconds  = mathAbs(data.milliseconds);\n        data.seconds       = mathAbs(data.seconds);\n        data.minutes       = mathAbs(data.minutes);\n        data.hours         = mathAbs(data.hours);\n        data.months        = mathAbs(data.months);\n        data.years         = mathAbs(data.years);\n\n        return this;\n    }\n\n    function duration_add_subtract__addSubtract (duration, input, value, direction) {\n        var other = create__createDuration(input, value);\n\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days         += direction * other._days;\n        duration._months       += direction * other._months;\n\n        return duration._bubble();\n    }\n\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function duration_add_subtract__add (input, value) {\n        return duration_add_subtract__addSubtract(this, input, value, 1);\n    }\n\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function duration_add_subtract__subtract (input, value) {\n        return duration_add_subtract__addSubtract(this, input, value, -1);\n    }\n\n    function absCeil (number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n\n    function bubble () {\n        var milliseconds = this._milliseconds;\n        var days         = this._days;\n        var months       = this._months;\n        var data         = this._data;\n        var seconds, minutes, hours, years, monthsFromDays;\n\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n                (milliseconds <= 0 && days <= 0 && months <= 0))) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n\n        seconds           = absFloor(milliseconds / 1000);\n        data.seconds      = seconds % 60;\n\n        minutes           = absFloor(seconds / 60);\n        data.minutes      = minutes % 60;\n\n        hours             = absFloor(minutes / 60);\n        data.hours        = hours % 24;\n\n        days += absFloor(hours / 24);\n\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        data.days   = days;\n        data.months = months;\n        data.years  = years;\n\n        return this;\n    }\n\n    function daysToMonths (days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return days * 4800 / 146097;\n    }\n\n    function monthsToDays (months) {\n        // the reverse of daysToMonths\n        return months * 146097 / 4800;\n    }\n\n    function as (units) {\n        var days;\n        var months;\n        var milliseconds = this._milliseconds;\n\n        units = normalizeUnits(units);\n\n        if (units === 'month' || units === 'year') {\n            days   = this._days   + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            return units === 'month' ? months : months / 12;\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch (units) {\n                case 'week'   : return days / 7     + milliseconds / 6048e5;\n                case 'day'    : return days         + milliseconds / 864e5;\n                case 'hour'   : return days * 24    + milliseconds / 36e5;\n                case 'minute' : return days * 1440  + milliseconds / 6e4;\n                case 'second' : return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n                default: throw new Error('Unknown unit ' + units);\n            }\n        }\n    }\n\n    // TODO: Use this.as('ms')?\n    function duration_as__valueOf () {\n        return (\n            this._milliseconds +\n            this._days * 864e5 +\n            (this._months % 12) * 2592e6 +\n            toInt(this._months / 12) * 31536e6\n        );\n    }\n\n    function makeAs (alias) {\n        return function () {\n            return this.as(alias);\n        };\n    }\n\n    var asMilliseconds = makeAs('ms');\n    var asSeconds      = makeAs('s');\n    var asMinutes      = makeAs('m');\n    var asHours        = makeAs('h');\n    var asDays         = makeAs('d');\n    var asWeeks        = makeAs('w');\n    var asMonths       = makeAs('M');\n    var asYears        = makeAs('y');\n\n    function duration_get__get (units) {\n        units = normalizeUnits(units);\n        return this[units + 's']();\n    }\n\n    function makeGetter(name) {\n        return function () {\n            return this._data[name];\n        };\n    }\n\n    var milliseconds = makeGetter('milliseconds');\n    var seconds      = makeGetter('seconds');\n    var minutes      = makeGetter('minutes');\n    var hours        = makeGetter('hours');\n    var days         = makeGetter('days');\n    var months       = makeGetter('months');\n    var years        = makeGetter('years');\n\n    function weeks () {\n        return absFloor(this.days() / 7);\n    }\n\n    var round = Math.round;\n    var thresholds = {\n        s: 45,  // seconds to minute\n        m: 45,  // minutes to hour\n        h: 22,  // hours to day\n        d: 26,  // days to month\n        M: 11   // months to year\n    };\n\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n\n    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {\n        var duration = create__createDuration(posNegDuration).abs();\n        var seconds  = round(duration.as('s'));\n        var minutes  = round(duration.as('m'));\n        var hours    = round(duration.as('h'));\n        var days     = round(duration.as('d'));\n        var months   = round(duration.as('M'));\n        var years    = round(duration.as('y'));\n\n        var a = seconds < thresholds.s && ['s', seconds]  ||\n                minutes === 1          && ['m']           ||\n                minutes < thresholds.m && ['mm', minutes] ||\n                hours   === 1          && ['h']           ||\n                hours   < thresholds.h && ['hh', hours]   ||\n                days    === 1          && ['d']           ||\n                days    < thresholds.d && ['dd', days]    ||\n                months  === 1          && ['M']           ||\n                months  < thresholds.M && ['MM', months]  ||\n                years   === 1          && ['y']           || ['yy', years];\n\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n\n    // This function allows you to set a threshold for relative time strings\n    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        return true;\n    }\n\n    function humanize (withSuffix) {\n        var locale = this.localeData();\n        var output = duration_humanize__relativeTime(this, !withSuffix, locale);\n\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n\n        return locale.postformat(output);\n    }\n\n    var iso_string__abs = Math.abs;\n\n    function iso_string__toISOString() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        var seconds = iso_string__abs(this._milliseconds) / 1000;\n        var days         = iso_string__abs(this._days);\n        var months       = iso_string__abs(this._months);\n        var minutes, hours, years;\n\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes           = absFloor(seconds / 60);\n        hours             = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n\n        // 12 months -> 1 year\n        years  = absFloor(months / 12);\n        months %= 12;\n\n\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        var Y = years;\n        var M = months;\n        var D = days;\n        var h = hours;\n        var m = minutes;\n        var s = seconds;\n        var total = this.asSeconds();\n\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return 'P0D';\n        }\n\n        return (total < 0 ? '-' : '') +\n            'P' +\n            (Y ? Y + 'Y' : '') +\n            (M ? M + 'M' : '') +\n            (D ? D + 'D' : '') +\n            ((h || m || s) ? 'T' : '') +\n            (h ? h + 'H' : '') +\n            (m ? m + 'M' : '') +\n            (s ? s + 'S' : '');\n    }\n\n    var duration_prototype__proto = Duration.prototype;\n\n    duration_prototype__proto.abs            = duration_abs__abs;\n    duration_prototype__proto.add            = duration_add_subtract__add;\n    duration_prototype__proto.subtract       = duration_add_subtract__subtract;\n    duration_prototype__proto.as             = as;\n    duration_prototype__proto.asMilliseconds = asMilliseconds;\n    duration_prototype__proto.asSeconds      = asSeconds;\n    duration_prototype__proto.asMinutes      = asMinutes;\n    duration_prototype__proto.asHours        = asHours;\n    duration_prototype__proto.asDays         = asDays;\n    duration_prototype__proto.asWeeks        = asWeeks;\n    duration_prototype__proto.asMonths       = asMonths;\n    duration_prototype__proto.asYears        = asYears;\n    duration_prototype__proto.valueOf        = duration_as__valueOf;\n    duration_prototype__proto._bubble        = bubble;\n    duration_prototype__proto.get            = duration_get__get;\n    duration_prototype__proto.milliseconds   = milliseconds;\n    duration_prototype__proto.seconds        = seconds;\n    duration_prototype__proto.minutes        = minutes;\n    duration_prototype__proto.hours          = hours;\n    duration_prototype__proto.days           = days;\n    duration_prototype__proto.weeks          = weeks;\n    duration_prototype__proto.months         = months;\n    duration_prototype__proto.years          = years;\n    duration_prototype__proto.humanize       = humanize;\n    duration_prototype__proto.toISOString    = iso_string__toISOString;\n    duration_prototype__proto.toString       = iso_string__toISOString;\n    duration_prototype__proto.toJSON         = iso_string__toISOString;\n    duration_prototype__proto.locale         = locale;\n    duration_prototype__proto.localeData     = localeData;\n\n    // Deprecations\n    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);\n    duration_prototype__proto.lang = lang;\n\n    // Side effect imports\n\n    addFormatToken('X', 0, 0, 'unix');\n    addFormatToken('x', 0, 0, 'valueOf');\n\n    // PARSING\n\n    addRegexToken('x', matchSigned);\n    addRegexToken('X', matchTimestamp);\n    addParseToken('X', function (input, array, config) {\n        config._d = new Date(parseFloat(input, 10) * 1000);\n    });\n    addParseToken('x', function (input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n\n    // Side effect imports\n\n\n    utils_hooks__hooks.version = '2.10.6';\n\n    setHookCallback(local__createLocal);\n\n    utils_hooks__hooks.fn                    = momentPrototype;\n    utils_hooks__hooks.min                   = min;\n    utils_hooks__hooks.max                   = max;\n    utils_hooks__hooks.utc                   = create_utc__createUTC;\n    utils_hooks__hooks.unix                  = moment__createUnix;\n    utils_hooks__hooks.months                = lists__listMonths;\n    utils_hooks__hooks.isDate                = isDate;\n    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;\n    utils_hooks__hooks.invalid               = valid__createInvalid;\n    utils_hooks__hooks.duration              = create__createDuration;\n    utils_hooks__hooks.isMoment              = isMoment;\n    utils_hooks__hooks.weekdays              = lists__listWeekdays;\n    utils_hooks__hooks.parseZone             = moment__createInZone;\n    utils_hooks__hooks.localeData            = locale_locales__getLocale;\n    utils_hooks__hooks.isDuration            = isDuration;\n    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;\n    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;\n    utils_hooks__hooks.defineLocale          = defineLocale;\n    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;\n    utils_hooks__hooks.normalizeUnits        = normalizeUnits;\n    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;\n\n    var _moment = utils_hooks__hooks;\n\n    return _moment;\n\n}));","date":"2015-11-03T15:27:19.092Z","updated":"2015-10-08T03:41:08.000Z","path":"unrest/moment.js","layout":"false","title":"","comments":1,"_id":"cijth4la700070nfw8vnn2vn4"},{"_content":"<html>\n<head></head>\n<body>\n\n<h1>Markdown</h1>\n<markdown>\nheader\n=====\n\ntesting\n\nand more!\n\n<b>tag!</b>\n</markdown>\n<hr/>\n<h1>Tabs</h1>\n<ur-tabs>\n  <ur-tab id=\"Some Content\">\n    <p>\n      Sed fermentum lorem vitae leo sodales, ac placerat lacus ornare. Duis semper nulla vitae pharetra aliquam. Curabitur leo urna, euismod eget blandit eu, condimentum ut nisi. Sed ultricies mi nunc, in vulputate nibh eleifend et. Cras faucibus massa nec elementum varius. Quisque diam justo, blandit eget erat vel, suscipit lobortis nulla. Aenean non risus vel lorem scelerisque ultricies at ac orci. Pellentesque a lacinia libero. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n    </p>\n  </ur-tab>\n  <ur-tab id=\"More Content\">\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse cursus scelerisque iaculis. Duis erat sapien, auctor in auctor quis, dapibus non elit. Proin varius malesuada est in tincidunt. Aenean commodo quis eros placerat malesuada. Suspendisse potenti. Proin nunc nisl, porta nec velit in, feugiat maximus diam. Aliquam erat volutpat. Suspendisse arcu dolor, porta vel nisl quis, pellentesque tincidunt massa. Donec bibendum eleifend arcu, non elementum mauris ornare at. Quisque eget diam eu mauris consequat fringilla. Ut convallis mollis neque. Donec id tortor ac diam consectetur faucibus nec eget nunc.\n    </p>\n    <p>\n      Sed at luctus neque, at mollis nunc. Sed accumsan libero ac lorem pharetra elementum eget sed mi. In eu mi non mi laoreet sagittis. Aliquam venenatis consectetur lacus a maximus. Suspendisse sit amet quam non ipsum placerat mattis at et dui. Donec sit amet nunc sagittis, tincidunt sem id, tincidunt augue. Nulla in sollicitudin arcu, ut tristique est. Aliquam erat augue, placerat et vulputate congue, scelerisque quis urna. Suspendisse ante urna, commodo vel lorem eu, elementum imperdiet lorem. Proin fermentum dolor enim, quis porta massa egestas in. Aliquam interdum est nec elit aliquam gravida. Sed in libero et diam lacinia rutrum in sed lorem. Integer ut nisl ut purus iaculis aliquam.\n    </p>\n  </ur-tab>\n</ur-tabs>\n<hr/>\n<h1>Calendar</h1>\n<calendar date=\"2015-6-1\">\n  <div each=\"{ occurrences }\">\n    <div onclick=\"{ select }\">\n      { name }\n      <div if=\"{ end }\">{ moment.format(\"h:mm a\") } - { end_moment.format(\"h:mm a\") }</div>\n    </div>\n    <modal if=\"{ active }\" cancel=\"{ cancel }\" class=\"absolute\">\n      <h2>{ name }</h2>\n      { moment.format(\"dddd MMMM Do, YYYY\") }\n      <div>{ moment.format(\"h:mm a\") } - { end_moment.format(\"h:mm a\"); }</div>\n    </modal>\n  </div>\n</calendar>\n<hr/>\n</body>\n<script src=\"moment.js\"></script>\n<script src=\"calendar.tag\" type=\"riot/tag\"></script>\n<script src=\"modal.tag\" type=\"riot/tag\"></script>\n<script src=\"tabs.tag\" type=\"riot/tag\"></script>\n<script src=\"markdown.tag\" type=\"riot/tag\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/markdown.js/0.5.0/markdown.min.js\"></script>\n<script src=\"//cdn.jsdelivr.net/g/riot@2.2(riot.min.js+compiler.min.js)\"></script>\n<script src=\"http.min.js\"></script>\n<script src=\"unrest.js\"></script>\n<script src=\"demo.js\"></script>\n</html>\n","source":"unrest/index.html","raw":"<html>\n<head></head>\n<body>\n\n<h1>Markdown</h1>\n<markdown>\nheader\n=====\n\ntesting\n\nand more!\n\n<b>tag!</b>\n</markdown>\n<hr/>\n<h1>Tabs</h1>\n<ur-tabs>\n  <ur-tab id=\"Some Content\">\n    <p>\n      Sed fermentum lorem vitae leo sodales, ac placerat lacus ornare. Duis semper nulla vitae pharetra aliquam. Curabitur leo urna, euismod eget blandit eu, condimentum ut nisi. Sed ultricies mi nunc, in vulputate nibh eleifend et. Cras faucibus massa nec elementum varius. Quisque diam justo, blandit eget erat vel, suscipit lobortis nulla. Aenean non risus vel lorem scelerisque ultricies at ac orci. Pellentesque a lacinia libero. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n    </p>\n  </ur-tab>\n  <ur-tab id=\"More Content\">\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse cursus scelerisque iaculis. Duis erat sapien, auctor in auctor quis, dapibus non elit. Proin varius malesuada est in tincidunt. Aenean commodo quis eros placerat malesuada. Suspendisse potenti. Proin nunc nisl, porta nec velit in, feugiat maximus diam. Aliquam erat volutpat. Suspendisse arcu dolor, porta vel nisl quis, pellentesque tincidunt massa. Donec bibendum eleifend arcu, non elementum mauris ornare at. Quisque eget diam eu mauris consequat fringilla. Ut convallis mollis neque. Donec id tortor ac diam consectetur faucibus nec eget nunc.\n    </p>\n    <p>\n      Sed at luctus neque, at mollis nunc. Sed accumsan libero ac lorem pharetra elementum eget sed mi. In eu mi non mi laoreet sagittis. Aliquam venenatis consectetur lacus a maximus. Suspendisse sit amet quam non ipsum placerat mattis at et dui. Donec sit amet nunc sagittis, tincidunt sem id, tincidunt augue. Nulla in sollicitudin arcu, ut tristique est. Aliquam erat augue, placerat et vulputate congue, scelerisque quis urna. Suspendisse ante urna, commodo vel lorem eu, elementum imperdiet lorem. Proin fermentum dolor enim, quis porta massa egestas in. Aliquam interdum est nec elit aliquam gravida. Sed in libero et diam lacinia rutrum in sed lorem. Integer ut nisl ut purus iaculis aliquam.\n    </p>\n  </ur-tab>\n</ur-tabs>\n<hr/>\n<h1>Calendar</h1>\n<calendar date=\"2015-6-1\">\n  <div each=\"{ occurrences }\">\n    <div onclick=\"{ select }\">\n      { name }\n      <div if=\"{ end }\">{ moment.format(\"h:mm a\") } - { end_moment.format(\"h:mm a\") }</div>\n    </div>\n    <modal if=\"{ active }\" cancel=\"{ cancel }\" class=\"absolute\">\n      <h2>{ name }</h2>\n      { moment.format(\"dddd MMMM Do, YYYY\") }\n      <div>{ moment.format(\"h:mm a\") } - { end_moment.format(\"h:mm a\"); }</div>\n    </modal>\n  </div>\n</calendar>\n<hr/>\n</body>\n<script src=\"moment.js\"></script>\n<script src=\"calendar.tag\" type=\"riot/tag\"></script>\n<script src=\"modal.tag\" type=\"riot/tag\"></script>\n<script src=\"tabs.tag\" type=\"riot/tag\"></script>\n<script src=\"markdown.tag\" type=\"riot/tag\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/markdown.js/0.5.0/markdown.min.js\"></script>\n<script src=\"//cdn.jsdelivr.net/g/riot@2.2(riot.min.js+compiler.min.js)\"></script>\n<script src=\"http.min.js\"></script>\n<script src=\"unrest.js\"></script>\n<script src=\"demo.js\"></script>\n</html>\n","date":"2016-01-23T23:06:08.540Z","updated":"2016-01-23T23:06:08.540Z","path":"unrest/index.html","title":"","comments":1,"layout":"page","_id":"cijth4lae00080nfw3t2njtci"},{"_content":"!function(t,e){\"function\"==typeof define&&define.amd?define([],e):t.Http=e()}(this,function(){var t,e,n;return function(r){function o(t,e){return q.call(t,e)}function i(t,e){var n,r,o,i,s,u,p,c,f,a,l,h=e&&e.split(\"/\"),d=x.map,y=d&&d[\"*\"]||{};if(t&&\".\"===t.charAt(0))if(e){for(h=h.slice(0,h.length-1),t=t.split(\"/\"),s=t.length-1,x.nodeIdCompat&&j.test(t[s])&&(t[s]=t[s].replace(j,\"\")),t=h.concat(t),f=0;f<t.length;f+=1)if(l=t[f],\".\"===l)t.splice(f,1),f-=1;else if(\"..\"===l){if(1===f&&(\"..\"===t[2]||\"..\"===t[0]))break;f>0&&(t.splice(f-1,2),f-=2)}t=t.join(\"/\")}else 0===t.indexOf(\"./\")&&(t=t.substring(2));if((h||y)&&d){for(n=t.split(\"/\"),f=n.length;f>0;f-=1){if(r=n.slice(0,f).join(\"/\"),h)for(a=h.length;a>0;a-=1)if(o=d[h.slice(0,a).join(\"/\")],o&&(o=o[r])){i=o,u=f;break}if(i)break;!p&&y&&y[r]&&(p=y[r],c=f)}!i&&p&&(i=p,u=c),i&&(n.splice(0,u,i),t=n.join(\"/\"))}return t}function s(t,e){return function(){return h.apply(r,w.call(arguments,0).concat([t,e]))}}function u(t){return function(e){return i(e,t)}}function p(t){return function(e){m[t]=e}}function c(t){if(o(g,t)){var e=g[t];delete g[t],v[t]=!0,l.apply(r,e)}if(!o(m,t)&&!o(v,t))throw new Error(\"No \"+t);return m[t]}function f(t){var e,n=t?t.indexOf(\"!\"):-1;return n>-1&&(e=t.substring(0,n),t=t.substring(n+1,t.length)),[e,t]}function a(t){return function(){return x&&x.config&&x.config[t]||{}}}var l,h,d,y,m={},g={},x={},v={},q=Object.prototype.hasOwnProperty,w=[].slice,j=/\\.js$/;d=function(t,e){var n,r=f(t),o=r[0];return t=r[1],o&&(o=i(o,e),n=c(o)),o?t=n&&n.normalize?n.normalize(t,u(e)):i(t,e):(t=i(t,e),r=f(t),o=r[0],t=r[1],o&&(n=c(o))),{f:o?o+\"!\"+t:t,n:t,pr:o,p:n}},y={require:function(t){return s(t)},exports:function(t){var e=m[t];return\"undefined\"!=typeof e?e:m[t]={}},module:function(t){return{id:t,uri:\"\",exports:m[t],config:a(t)}}},l=function(t,e,n,i){var u,f,a,l,h,x,q=[],w=typeof n;if(i=i||t,\"undefined\"===w||\"function\"===w){for(e=!e.length&&n.length?[\"require\",\"exports\",\"module\"]:e,h=0;h<e.length;h+=1)if(l=d(e[h],i),f=l.f,\"require\"===f)q[h]=y.require(t);else if(\"exports\"===f)q[h]=y.exports(t),x=!0;else if(\"module\"===f)u=q[h]=y.module(t);else if(o(m,f)||o(g,f)||o(v,f))q[h]=c(f);else{if(!l.p)throw new Error(t+\" missing \"+f);l.p.load(l.n,s(i,!0),p(f),{}),q[h]=m[f]}a=n?n.apply(m[t],q):void 0,t&&(u&&u.exports!==r&&u.exports!==m[t]?m[t]=u.exports:a===r&&x||(m[t]=a))}else t&&(m[t]=n)},t=e=h=function(t,e,n,o,i){if(\"string\"==typeof t)return y[t]?y[t](e):c(d(t,e).f);if(!t.splice){if(x=t,x.deps&&h(x.deps,x.callback),!e)return;e.splice?(t=e,e=n,n=null):t=r}return e=e||function(){},\"function\"==typeof n&&(n=o,o=i),o?l(r,t,e,n):setTimeout(function(){l(r,t,e,n)},4),h},h.config=function(t){return h(t)},t._defined=m,n=function(t,e,n){e.splice||(n=e,e=[]),o(m,t)||o(g,t)||(g[t]=[t,e,n])},n.amd={jQuery:!0}}(),n(\"../vendor/almond\",function(){}),n(\"RequestManager\",[],function(){function t(){}return t.prototype.verifyStatus=function(t){return!(t.xhr.status<200||t.xhr.status>=300&&304!==t.xhr.status)},t.prototype.loaded=function(t){this.verifyStatus(t)?(t.response=this.parseData(t),t.completer.complete(t.response)):t.completer.completeError(t.xhr.statusText)},t.prototype.parseData=function(t){return\"application/json\"==t.xhr.getResponseHeader(\"content-type\")?JSON.parse(t.xhr.responseText):t.xhr.responseText},t.prototype.process=function(t){t.xhr.open(t.type,t.url,t.async),this.send(t)},t.prototype.send=function(t){this.prepareData(t);var e=this;t.async===!0?(t.xhr.onload=function(){e.loaded.call(e,t)},t.xhr.send(this.prepareData(t))):(t.xhr.send(this.prepareData(t)),this.loaded.call(this,t))},t.prototype.prepareData=function(t){return\"object\"==typeof t.data?(t.xhr.setRequestHeader(\"Content-Type\",\"application/json\"),JSON.stringify(t.data)):\"string\"==typeof t.data?t.data:null},t}),n(\"Request\",[\"./RequestManager\"],function(t){function e(){}function n(){this.promise=new e}function r(){this.xhr=new XMLHttpRequest,this.completer=new n,this.requestManager=new t}return e.prototype.then=function(t){this.resolve=t},e.prototype.fail=function(t){this.reject=t},n.prototype.complete=function(){void 0!==this.promise.resolve&&this.promise.resolve.apply(this,arguments)},n.prototype.completeError=function(t){void 0!==this.promise.reject&&this.promise.reject(t)},r.prototype.start=function(){return this.requestManager.process(this),this.completer.promise},r.prototype.restart=function(){return this.requestManager.process(),this.completer.promise},r}),function(t,e){\"function\"==typeof n&&n.amd?n(\"Get\",[\"./Request\"],e):t.Get=e(t.Request)}(this,function(t){function e(t,e){if(this.type=\"GET\",void 0===t)throw new Error(\"Parameters mismatched\");this.url=t,this.async=void 0===e?!0:e}return e.prototype=new t,e.prototype.constructor=e,e}),function(t,e){\"function\"==typeof n&&n.amd?n(\"Post\",[\"./Request\"],e):t.Post=e(t.Request)}(this,function(t){function e(t,e,n){if(this.type=\"POST\",void 0===t||void 0===e)throw new Error(\"Parameters mismatched\");return this.async=void 0===n?!0:!1,this.url=t,this.data=e,this}return e.prototype=new t,e.constructor=e,e}),n(\"main\",[\"./Get\",\"./Post\"],function(t,e){return{Get:t,Post:e}}),e(\"main\")});","source":"unrest/http.min.js","raw":"!function(t,e){\"function\"==typeof define&&define.amd?define([],e):t.Http=e()}(this,function(){var t,e,n;return function(r){function o(t,e){return q.call(t,e)}function i(t,e){var n,r,o,i,s,u,p,c,f,a,l,h=e&&e.split(\"/\"),d=x.map,y=d&&d[\"*\"]||{};if(t&&\".\"===t.charAt(0))if(e){for(h=h.slice(0,h.length-1),t=t.split(\"/\"),s=t.length-1,x.nodeIdCompat&&j.test(t[s])&&(t[s]=t[s].replace(j,\"\")),t=h.concat(t),f=0;f<t.length;f+=1)if(l=t[f],\".\"===l)t.splice(f,1),f-=1;else if(\"..\"===l){if(1===f&&(\"..\"===t[2]||\"..\"===t[0]))break;f>0&&(t.splice(f-1,2),f-=2)}t=t.join(\"/\")}else 0===t.indexOf(\"./\")&&(t=t.substring(2));if((h||y)&&d){for(n=t.split(\"/\"),f=n.length;f>0;f-=1){if(r=n.slice(0,f).join(\"/\"),h)for(a=h.length;a>0;a-=1)if(o=d[h.slice(0,a).join(\"/\")],o&&(o=o[r])){i=o,u=f;break}if(i)break;!p&&y&&y[r]&&(p=y[r],c=f)}!i&&p&&(i=p,u=c),i&&(n.splice(0,u,i),t=n.join(\"/\"))}return t}function s(t,e){return function(){return h.apply(r,w.call(arguments,0).concat([t,e]))}}function u(t){return function(e){return i(e,t)}}function p(t){return function(e){m[t]=e}}function c(t){if(o(g,t)){var e=g[t];delete g[t],v[t]=!0,l.apply(r,e)}if(!o(m,t)&&!o(v,t))throw new Error(\"No \"+t);return m[t]}function f(t){var e,n=t?t.indexOf(\"!\"):-1;return n>-1&&(e=t.substring(0,n),t=t.substring(n+1,t.length)),[e,t]}function a(t){return function(){return x&&x.config&&x.config[t]||{}}}var l,h,d,y,m={},g={},x={},v={},q=Object.prototype.hasOwnProperty,w=[].slice,j=/\\.js$/;d=function(t,e){var n,r=f(t),o=r[0];return t=r[1],o&&(o=i(o,e),n=c(o)),o?t=n&&n.normalize?n.normalize(t,u(e)):i(t,e):(t=i(t,e),r=f(t),o=r[0],t=r[1],o&&(n=c(o))),{f:o?o+\"!\"+t:t,n:t,pr:o,p:n}},y={require:function(t){return s(t)},exports:function(t){var e=m[t];return\"undefined\"!=typeof e?e:m[t]={}},module:function(t){return{id:t,uri:\"\",exports:m[t],config:a(t)}}},l=function(t,e,n,i){var u,f,a,l,h,x,q=[],w=typeof n;if(i=i||t,\"undefined\"===w||\"function\"===w){for(e=!e.length&&n.length?[\"require\",\"exports\",\"module\"]:e,h=0;h<e.length;h+=1)if(l=d(e[h],i),f=l.f,\"require\"===f)q[h]=y.require(t);else if(\"exports\"===f)q[h]=y.exports(t),x=!0;else if(\"module\"===f)u=q[h]=y.module(t);else if(o(m,f)||o(g,f)||o(v,f))q[h]=c(f);else{if(!l.p)throw new Error(t+\" missing \"+f);l.p.load(l.n,s(i,!0),p(f),{}),q[h]=m[f]}a=n?n.apply(m[t],q):void 0,t&&(u&&u.exports!==r&&u.exports!==m[t]?m[t]=u.exports:a===r&&x||(m[t]=a))}else t&&(m[t]=n)},t=e=h=function(t,e,n,o,i){if(\"string\"==typeof t)return y[t]?y[t](e):c(d(t,e).f);if(!t.splice){if(x=t,x.deps&&h(x.deps,x.callback),!e)return;e.splice?(t=e,e=n,n=null):t=r}return e=e||function(){},\"function\"==typeof n&&(n=o,o=i),o?l(r,t,e,n):setTimeout(function(){l(r,t,e,n)},4),h},h.config=function(t){return h(t)},t._defined=m,n=function(t,e,n){e.splice||(n=e,e=[]),o(m,t)||o(g,t)||(g[t]=[t,e,n])},n.amd={jQuery:!0}}(),n(\"../vendor/almond\",function(){}),n(\"RequestManager\",[],function(){function t(){}return t.prototype.verifyStatus=function(t){return!(t.xhr.status<200||t.xhr.status>=300&&304!==t.xhr.status)},t.prototype.loaded=function(t){this.verifyStatus(t)?(t.response=this.parseData(t),t.completer.complete(t.response)):t.completer.completeError(t.xhr.statusText)},t.prototype.parseData=function(t){return\"application/json\"==t.xhr.getResponseHeader(\"content-type\")?JSON.parse(t.xhr.responseText):t.xhr.responseText},t.prototype.process=function(t){t.xhr.open(t.type,t.url,t.async),this.send(t)},t.prototype.send=function(t){this.prepareData(t);var e=this;t.async===!0?(t.xhr.onload=function(){e.loaded.call(e,t)},t.xhr.send(this.prepareData(t))):(t.xhr.send(this.prepareData(t)),this.loaded.call(this,t))},t.prototype.prepareData=function(t){return\"object\"==typeof t.data?(t.xhr.setRequestHeader(\"Content-Type\",\"application/json\"),JSON.stringify(t.data)):\"string\"==typeof t.data?t.data:null},t}),n(\"Request\",[\"./RequestManager\"],function(t){function e(){}function n(){this.promise=new e}function r(){this.xhr=new XMLHttpRequest,this.completer=new n,this.requestManager=new t}return e.prototype.then=function(t){this.resolve=t},e.prototype.fail=function(t){this.reject=t},n.prototype.complete=function(){void 0!==this.promise.resolve&&this.promise.resolve.apply(this,arguments)},n.prototype.completeError=function(t){void 0!==this.promise.reject&&this.promise.reject(t)},r.prototype.start=function(){return this.requestManager.process(this),this.completer.promise},r.prototype.restart=function(){return this.requestManager.process(),this.completer.promise},r}),function(t,e){\"function\"==typeof n&&n.amd?n(\"Get\",[\"./Request\"],e):t.Get=e(t.Request)}(this,function(t){function e(t,e){if(this.type=\"GET\",void 0===t)throw new Error(\"Parameters mismatched\");this.url=t,this.async=void 0===e?!0:e}return e.prototype=new t,e.prototype.constructor=e,e}),function(t,e){\"function\"==typeof n&&n.amd?n(\"Post\",[\"./Request\"],e):t.Post=e(t.Request)}(this,function(t){function e(t,e,n){if(this.type=\"POST\",void 0===t||void 0===e)throw new Error(\"Parameters mismatched\");return this.async=void 0===n?!0:!1,this.url=t,this.data=e,this}return e.prototype=new t,e.constructor=e,e}),n(\"main\",[\"./Get\",\"./Post\"],function(t,e){return{Get:t,Post:e}}),e(\"main\")});","date":"2015-11-03T15:46:58.828Z","updated":"2015-11-03T15:46:58.828Z","path":"unrest/http.min.js","layout":"false","title":"","comments":1,"_id":"cijth4lag00090nfwrhi1dtcf"},{"_content":"var request = new Http.Get(\"http://holidayapi.com/v1/holidays?country=US&year=2015\",true);\nrequest.start().then( function(response) {\n  var holidays = JSON.parse(response).holidays;\n  var dates = []\n  for (var date in holidays) {\n    dates.push(date)\n  }\n  occurrences = [\n    { 'start': '2015-6-20 7:00 pm', 'name': 'My birthday party', 'end': '2015-6-20 9:00 pm' }\n  ];\n  for (var i=0;i<dates.length;i++) {\n    var d = dates[i];\n    for (var i2=0;i2<holidays[d].length;i2++) {\n      var o = holidays[d][i2];\n      o.start = o.date;\n      occurrences.push(o);\n    }\n  }\n  riot.mount(\"calendar\",{occurrences: occurrences});\n});\n\nfunction foo(e) {\n  alert(\"foo \"+e);\n}\n\nriot.mount(\"markdown,ur-tabs\");\n","source":"unrest/demo.js","raw":"var request = new Http.Get(\"http://holidayapi.com/v1/holidays?country=US&year=2015\",true);\nrequest.start().then( function(response) {\n  var holidays = JSON.parse(response).holidays;\n  var dates = []\n  for (var date in holidays) {\n    dates.push(date)\n  }\n  occurrences = [\n    { 'start': '2015-6-20 7:00 pm', 'name': 'My birthday party', 'end': '2015-6-20 9:00 pm' }\n  ];\n  for (var i=0;i<dates.length;i++) {\n    var d = dates[i];\n    for (var i2=0;i2<holidays[d].length;i2++) {\n      var o = holidays[d][i2];\n      o.start = o.date;\n      occurrences.push(o);\n    }\n  }\n  riot.mount(\"calendar\",{occurrences: occurrences});\n});\n\nfunction foo(e) {\n  alert(\"foo \"+e);\n}\n\nriot.mount(\"markdown,ur-tabs\");\n","date":"2016-01-23T22:15:46.704Z","updated":"2016-01-23T22:15:46.704Z","path":"unrest/demo.js","layout":"false","title":"","comments":1,"_id":"cijth4laj000a0nfwcqpnpdsk"},{"_content":"/* Riot v2.3.12, @license MIT, (c) 2015 Muut Inc. + contributors */\n(function(e,t){\"use strict\";var n={version:\"v2.3.12\",settings:{}},r=0,i=[],o={},f=\"riot-\",u=f+\"tag\",a=\"string\",s=\"object\",c=\"undefined\",l=\"function\",p=/^(?:opt(ion|group)|tbody|col|t[rhd])$/,d=[\"_item\",\"_id\",\"_parent\",\"update\",\"root\",\"mount\",\"unmount\",\"mixin\",\"isMounted\",\"isLoop\",\"tags\",\"parent\",\"opts\",\"trigger\",\"on\",\"off\",\"one\"],g=(e&&e.document||{}).documentMode|0;n.observable=function(e){e=e||{};var t={},n=function(e,t){e.replace(/\\S+/g,t)},r=function(t,n){Object.defineProperty(e,t,{value:n,enumerable:false,writable:false,configurable:false})};r(\"on\",function(r,i){if(typeof i!=\"function\")return e;n(r,function(e,n){(t[e]=t[e]||[]).push(i);i.typed=n>0});return e});r(\"off\",function(r,i){if(r==\"*\")t={};else{n(r,function(e){if(i){var n=t[e];for(var r=0,o;o=n&&n[r];++r){if(o==i)n.splice(r--,1)}}else delete t[e]})}return e});r(\"one\",function(t,n){function r(){e.off(t,r);n.apply(e,arguments)}return e.on(t,r)});r(\"trigger\",function(r){var i=arguments.length-1,o=new Array(i);for(var f=0;f<i;f++){o[f]=arguments[f+1]}n(r,function(n){var r=(t[n]||[]).slice(0);for(var i=0,f;f=r[i];++i){if(f.busy)return;f.busy=1;try{f.apply(e,f.typed?[n].concat(o):o)}catch(u){e.trigger(\"error\",u)}if(r[i]!==f){i--}f.busy=0}if(t.all&&n!=\"all\")e.trigger.apply(e,[\"all\",n].concat(o))});return e});return e};(function(t){if(!e)return;var n=/^.+?\\/+[^\\/]+/,r=\"EventListener\",i=\"remove\"+r,o=\"add\"+r,f=\"hasAttribute\",u=\"replace\",a=\"popstate\",s=\"hashchange\",c=\"trigger\",l=3,p=e,d=document,g=p.history.location||p.location,h=O.prototype,v=d&&d.ontouchstart?\"touchstart\":\"click\",m=false,y=t.observable(),b=false,w,x,_,N,L,T=[],C=0;function M(e){return e.split(/[\\/?#]/)}function E(e,t){var n=new RegExp(\"^\"+t[u](/\\*/g,\"([^/?#]+?)\")[u](/\\.\\./,\".*\")+\"$\"),r=e.match(n);if(r)return r.slice(1)}function S(e,t){var n;return function(){clearTimeout(n);n=setTimeout(e,t)}}function A(e){w=S(j,1);p[o](a,w);p[o](s,w);d[o](v,I);if(e)j(true)}function O(){this.$=[];t.observable(this);y.on(\"stop\",this.s.bind(this));y.on(\"emit\",this.e.bind(this))}function $(e){return e[u](/^\\/|\\/$/,\"\")}function H(e){return typeof e==\"string\"}function R(e){return(e||g.href)[u](n,\"\")}function k(e){return x[0]==\"#\"?(e||g.href).split(x)[1]||\"\":R(e)[u](x,\"\")}function j(e){var t=C==0;if(l<=C)return;C++;T.push(function(){var t=k();if(e||t!=_){y[c](\"emit\",t);_=t}});if(t){while(T.length){T[0]();T.shift()}C=0}}function I(e){if(e.which!=1||e.metaKey||e.ctrlKey||e.shiftKey||e.defaultPrevented)return;var t=e.target;while(t&&t.nodeName!=\"A\")t=t.parentNode;if(!t||t.nodeName!=\"A\"||t[f](\"download\")||!t[f](\"href\")||t.target&&t.target!=\"_self\"||t.href.indexOf(g.href.match(n)[0])==-1)return;if(t.href!=g.href){if(t.href.split(\"#\")[0]==g.href.split(\"#\")[0]||x!=\"#\"&&R(t.href).indexOf(x)!==0||!F(k(t.href),t.title||d.title))return}e.preventDefault()}function F(e,t){t=t||d.title;history.pushState(null,t,x+$(e));d.title=t;b=false;j();return b}h.m=function(e,t){if(H(e)&&(!t||H(t)))F(e,t);else if(t)this.r(e,t);else this.r(\"@\",e)};h.s=function(){this.off(\"*\");this.$=[]};h.e=function(e){this.$.concat(\"@\").some(function(t){var n=(t==\"@\"?N:L)($(e),$(t));if(typeof n!=\"undefined\"){this[c].apply(null,[t].concat(n));return b=true}},this)};h.r=function(e,t){if(e!=\"@\"){e=\"/\"+$(e);this.$.push(e)}this.on(e,t)};var B=new O;var K=B.m.bind(B);K.create=function(){var e=new O;e.m.stop=e.s.bind(e);return e.m.bind(e)};K.base=function(e){x=e||\"#\";_=k()};K.exec=function(){j(true)};K.parser=function(e,t){if(!e&&!t){N=M;L=E}if(e)N=e;if(t)L=t};K.query=function(){var e={};g.href[u](/[?&](.+?)=([^&]*)/g,function(t,n,r){e[n]=r});return e};K.stop=function(){if(m){p[i](a,w);p[i](s,w);d[i](v,I);y[c](\"stop\");m=false}};K.start=function(e){if(!m){if(document.readyState==\"complete\")A(e);else p[o](\"load\",function(){setTimeout(function(){A(e)},1)});m=true}};K.base();K.parser();t.route=K})(n);var h=function(e){var t=\"g\",r=/\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,i=/\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,o=i.source+\"|\"+/(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source+\"|\"+/\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,f=\"{ }\",u={\"(\":RegExp(\"([()])|\"+o,t),\"[\":RegExp(\"([[\\\\]])|\"+o,t),\"{\":RegExp(\"([{}])|\"+o,t)};var a=e,s,c=[];function l(e){return e}function p(e,n){if(!n)n=c;return new RegExp(e.source.replace(/{/g,n[2]).replace(/}/g,n[3]),e.global?t:\"\")}function d(e){var n,r=e.split(\" \");if(e===f){r[2]=r[0];r[3]=r[1];n=l}else{if(r.length!==2||/[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(e)){throw new Error('Unsupported brackets \"'+e+'\"')}r=r.concat(e.replace(/(?=[[\\]()*+?.^$|])/g,\"\\\\\").split(\" \"));n=p}r[4]=n(r[1].length>1?/{[\\S\\s]*?}/:/{[^}]*}/,r);r[5]=n(/\\\\({|})/g,r);r[6]=n(/(\\\\?)({)/g,r);r[7]=RegExp(\"(\\\\\\\\?)(?:([[({])|(\"+r[3]+\"))|\"+o,t);r[8]=e;return r}function g(e){if(!e)e=f;if(e!==c[8]){c=d(e);s=e===f?l:p;c[9]=s(/^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/);c[10]=s(/(^|[^\\\\]){=[\\S\\s]*?}/);h._rawOffset=c[0].length}a=e}function h(e){return e instanceof RegExp?s(e):c[e]}h.split=function y(e,t,n){if(!n)n=c;var r=[],i,o,f,a,s=n[6];o=f=s.lastIndex=0;while(i=s.exec(e)){a=i.index;if(o){if(i[2]){s.lastIndex=p(i[2],s.lastIndex);continue}if(!i[3])continue}if(!i[1]){l(e.slice(f,a));f=s.lastIndex;s=n[6+(o^=1)];s.lastIndex=f}}if(e&&f<e.length){l(e.slice(f))}return r;function l(e){if(t||o)r.push(e&&e.replace(n[5],\"$1\"));else r.push(e)}function p(t,n){var r,i=u[t],o=1;i.lastIndex=n;while(r=i.exec(e)){if(r[1]&&!(r[1]===t?++o:--o))break}return r?i.lastIndex:e.length}};h.hasExpr=function b(e){return h(4).test(e)};h.loopKeys=function w(e){var t=e.match(h(9));return t?{key:t[1],pos:t[2],val:c[0]+t[3].trim()+c[1]}:{val:e.trim()}};h.array=function x(e){return d(e||a)};var v;function m(e){var t;e=e||{};t=e.brackets;Object.defineProperty(e,\"brackets\",{set:g,get:function(){return a},enumerable:true});v=e;g(t)}Object.defineProperty(h,\"settings\",{set:m,get:function(){return v}});h.settings=typeof n!==\"undefined\"&&n.settings||{};h.set=g;h.R_STRINGS=i;h.R_MLCOMMS=r;h.S_QBLOCKS=o;return h}();var v=function(){var t={};function n(e,n){if(!e)return e;return(t[e]||(t[e]=i(e))).call(n,r)}n.isRaw=function(e){return e[h._rawOffset]===\"=\"};n.haveRaw=function(e){return h(10).test(e)};n.hasExpr=h.hasExpr;n.loopKeys=h.loopKeys;n.errorHandler=null;function r(e,t){if(n.errorHandler){e.riotData={tagName:t&&t.root&&t.root.tagName,_riot_id:t&&t._riot_id};n.errorHandler(e)}}function i(e){var t=u(e);if(t.slice(0,11)!==\"try{return \")t=\"return \"+t;return new Function(\"E\",t+\";\")}var o=RegExp(h.S_QBLOCKS,\"g\"),f=/\\x01(\\d+)~/g;function u(e){var t=[],n,r=h.split(e.replace(/\\u2057/g,'\"'),1);if(r.length>2||r[0]){var i,o,u=[];for(i=o=0;i<r.length;++i){n=r[i];if(n&&(n=i&1?c(n,1,t):'\"'+n.replace(/\\\\/g,\"\\\\\\\\\").replace(/\\r\\n?|\\n/g,\"\\\\n\").replace(/\"/g,'\\\\\"')+'\"'))u[o++]=n}n=o<2?u[0]:\"[\"+u.join(\",\")+'].join(\"\")'}else{n=c(r[1],0,t)}if(t[0])n=n.replace(f,function(e,n){return t[n].replace(/\\r/g,\"\\\\r\").replace(/\\n/g,\"\\\\n\")});return n}var a=/^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\x01(\\d+)~):/,s=/,|([[{(])|$/g;function c(e,t,n){if(e[0]===\"=\")e=e.slice(1);e=e.replace(o,function(e,t){return e.length>2&&!t?\"\u0001\"+(n.push(e)-1)+\"~\":e}).replace(/\\s+/g,\" \").trim().replace(/\\ ?([[\\({},?\\.:])\\ ?/g,\"$1\");if(e){var r=[],i=0,f;while(e&&(f=e.match(a))&&!f.index){var u,s,c=/,|([[{(])|$/g;e=RegExp.rightContext;u=f[2]?n[f[2]].slice(1,-1).trim().replace(/\\s+/g,\" \"):f[1];while(s=(f=c.exec(e))[1])l(s,c);s=e.slice(0,f.index);e=RegExp.rightContext;r[i++]=d(s,1,u)}e=!i?d(e,t):i>1?\"[\"+r.join(\",\")+'].join(\" \").trim()':r[0]}return e;function l(t,n){var r,i=1,o=t===\"(\"?/[()]/g:t===\"[\"?/[[\\]]/g:/[{}]/g;o.lastIndex=n.lastIndex;while(r=o.exec(e)){if(r[0]===t)++i;else if(!--i)break}n.lastIndex=i?e.length:o.lastIndex}}var l='\"in this?this:'+(typeof e!==\"object\"?\"global\":\"window\")+\").\";var p=/[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g;function d(e,t,n){var r;e=e.replace(p,function(e,t,n,i,o){if(n){i=r?0:i+e.length;if(n!==\"this\"&&n!==\"global\"&&n!==\"window\"){e=t+'(\"'+n+l+n;if(i)r=(o=o[i])===\".\"||o===\"(\"||o===\"[\"}else if(i)r=!/^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/.test(o.slice(i))}return e});if(r){e=\"try{return \"+e+\"}catch(e){E(e,this)}\"}if(n){e=(r?\"function(){\"+e+\"}.call(this)\":\"(\"+e+\")\")+'?\"'+n+'\":\"\"'}else if(t){e=\"function(v){\"+(r?e.replace(\"return \",\"v=\"):\"v=(\"+e+\")\")+';return v||v===0?v:\"\"}.call(this)'}return e}n.parse=function(e){return e};return n}();v.version=h.version=\"v2.3.19\";var m=function(e){var t={tr:\"tbody\",th:\"tr\",td:\"tr\",tbody:\"table\",col:\"colgroup\"},n=\"div\";e=e&&e<10;function r(r){var o=r&&r.match(/^\\s*<([-\\w]+)/),f=o&&o[1].toLowerCase(),u=t[f]||n,a=W(u);a.stub=true;if(e&&f&&(o=f.match(p)))i(a,r,f,!!o[1]);else a.innerHTML=r;return a}function i(e,t,r,i){var o=W(n),f=i?\"select>\":\"table>\",u;o.innerHTML=\"<\"+f+t+\"</\"+f;u=te(r,o);if(u)e.appendChild(u)}return r}(g);function y(e,t,n){var r={};r[e.key]=t;if(e.pos)r[e.pos]=n;return r}function b(e,t){var n=t.length,r=e.length;while(n>r){var i=t[--n];t.splice(n,1);i.unmount()}}function w(e,t){Object.keys(e.tags).forEach(function(n){var r=e.tags[n];if(U(r))A(r,function(e){F(e,n,t)});else F(r,n,t)})}function x(e,t,n){var r=e._root;e._virts=[];while(r){var i=r.nextSibling;if(n)t.insertBefore(r,n._root);else t.appendChild(r);e._virts.push(r);r=i}}function _(e,t,n,r){var i=e._root;for(var o=0;o<r;o++){var f=i.nextSibling;t.insertBefore(i,n._root);i=f}}function N(e,t,n){$(e,\"each\");var r=typeof R(e,\"no-reorder\")!==a||$(e,\"no-reorder\"),i=D(e),f=o[i]||{tmpl:e.outerHTML},u=p.test(i),s=e.parentNode,c=document.createTextNode(\"\"),l=j(e),d=/option/gi.test(i),g=[],h=[],m,N=e.tagName==\"VIRTUAL\";n=v.loopKeys(n);s.insertBefore(c,e);t.one(\"before-mount\",function(){e.parentNode.removeChild(e);if(s.stub)s=t.root}).on(\"update\",function(){var a=v(n.val,t),p=document.createDocumentFragment();if(!U(a)){m=a||false;a=m?Object.keys(a).map(function(e){return y(n,e,a[e])}):[]}a.forEach(function(a,c){var d=r&&a instanceof Object,v=h.indexOf(a),b=~v&&d?v:c,L=g[b];a=!m&&n.key?y(n,a,c):a;if(!d&&!L||d&&!~v||!L){L=new C(f,{parent:t,isLoop:true,hasImpl:!!o[i],root:u?s:e.cloneNode(),item:a},e.innerHTML);L.mount();if(N)L._root=L.root.firstChild;if(c==g.length){if(N)x(L,p);else p.appendChild(L.root)}else{if(N)x(L,s,g[c]);else s.insertBefore(L.root,g[c].root);h.splice(c,0,a)}g.splice(c,0,L);b=c}else L.update(a);if(b!==c&&d){if(N)_(L,s,g[c],e.childNodes.length);else s.insertBefore(L.root,g[c].root);if(n.pos)L[n.pos]=c;g.splice(c,0,g.splice(b,1)[0]);h.splice(c,0,h.splice(b,1)[0]);if(!l)w(L,c)}L._item=a;q(L,\"_parent\",t)},true);b(a,g);if(d)s.appendChild(p);else s.insertBefore(p,c);if(l)t.tags[i]=g;h=a.slice()})}function L(e,t,n,r){Q(e,function(e){if(e.nodeType==1){e.isLoop=e.isLoop||(e.parentNode&&e.parentNode.isLoop||R(e,\"each\"))?1:0;if(n){var i=j(e);if(i&&!e.isLoop)n.push(B(i,{root:e,parent:t},e.innerHTML,t))}if(!e.isLoop||r)ie(e,t,[])}})}function T(e,t,n){function r(e,t,r){if(v.hasExpr(t)){var i={dom:e,expr:t};n.push(P(i,r))}}Q(e,function(e){var n=e.nodeType;if(n==3&&e.parentNode.tagName!=\"STYLE\")r(e,e.nodeValue);if(n!=1)return;var i=R(e,\"each\");if(i){N(e,t,i);return false}A(e.attributes,function(t){var n=t.name,i=n.split(\"__\")[1];r(e,t.value,{attr:i||n,bool:i});if(i){$(e,n);return false}});if(j(e))return false})}function C(e,o,f){var u=n.observable(this),l=ne(o.opts)||{},p=m(e.tmpl),g=o.parent,h=o.isLoop,y=o.hasImpl,b=Z(o.item),w=[],x=[],_=o.root,N=e.fn,C=_.tagName.toLowerCase(),M={},E=[];if(N&&_._tag)_._tag.unmount(true);this.isMounted=false;_.isLoop=h;_._tag=this;q(this,\"_riot_id\",++r);P(this,{parent:g,root:_,opts:l,tags:{}},b);A(_.attributes,function(e){var t=e.value;if(v.hasExpr(t))M[e.name]=t});if(p.innerHTML&&!/^(select|optgroup|table|tbody|tr|col(?:group)?)$/.test(C))p.innerHTML=J(p.innerHTML,f);function R(){var e=y&&h?u:g||u;A(_.attributes,function(t){l[H(t.name)]=v(t.value,e)});A(Object.keys(M),function(t){l[H(t)]=v(M[t],e)})}function j(e){for(var t in b){if(typeof u[t]!==c&&V(u,t))u[t]=e[t]}}function I(){if(!u.parent||!h)return;A(Object.keys(u.parent),function(e){var t=!z(d,e)&&z(E,e);if(typeof u[e]===c||t){if(!t)E.push(e);u[e]=u.parent[e]}})}q(this,\"update\",function(e){e=Z(e);I();if(e&&typeof b===s){j(e);b=e}P(u,e);R();u.trigger(\"update\",e);S(w,u);ue(function(){u.trigger(\"updated\")});return this});q(this,\"mixin\",function(){A(arguments,function(e){var t;e=typeof e===a?n.mixin(e):e;if(O(e)){t=new e;e=e.prototype}else t=e;A(Object.getOwnPropertyNames(e),function(e){if(e!=\"init\")u[e]=O(t[e])?t[e].bind(u):t[e]});if(t.init)t.init.bind(u)()});return this});q(this,\"mount\",function(){R();if(N)N.call(u,l);T(p,u,w);F(true);if(e.attrs||y){Y(e.attrs,function(e,t){k(_,e,t)});T(u.root,u,w)}if(!u.parent||h)u.update(b);u.trigger(\"before-mount\");if(h&&!y){u.root=_=p.firstChild}else{while(p.firstChild)_.appendChild(p.firstChild);if(_.stub)u.root=_=g.root}if(h)L(u.root,u.parent,null,true);if(!u.parent||u.parent.isMounted){u.isMounted=true;u.trigger(\"mount\")}else u.parent.one(\"mount\",function(){if(!G(u.root)){u.parent.isMounted=u.isMounted=true;u.trigger(\"mount\")}})});q(this,\"unmount\",function(e){var n=_,r=n.parentNode,o;u.trigger(\"before-unmount\");i.splice(i.indexOf(u),1);if(this._virts){A(this._virts,function(e){e.parentNode.removeChild(e)})}if(r){if(g){o=K(g);if(U(o.tags[C]))A(o.tags[C],function(e,t){if(e._riot_id==u._riot_id)o.tags[C].splice(t,1)});else o.tags[C]=t}else while(n.firstChild)n.removeChild(n.firstChild);if(!e)r.removeChild(n);else $(r,\"riot-tag\")}u.trigger(\"unmount\");F();u.off(\"*\");u.isMounted=false;_._tag=null});function F(e){A(x,function(t){t[e?\"mount\":\"unmount\"]()});if(g){var t=e?\"on\":\"off\";if(h)g[t](\"unmount\",u.unmount);else g[t](\"update\",u.update)[t](\"unmount\",u.unmount)}}L(p,this,x)}function M(t,n,r,i){r[t]=function(t){var o=i._parent,f=i._item,u;if(!f)while(o&&!f){f=o._item;o=o._parent}t=t||e.event;if(V(t,\"currentTarget\"))t.currentTarget=r;if(V(t,\"target\"))t.target=t.srcElement;if(V(t,\"which\"))t.which=t.charCode||t.keyCode;t.item=f;if(n.call(i,t)!==true&&!/radio|check/.test(r.type)){if(t.preventDefault)t.preventDefault();t.returnValue=false}if(!t.preventUpdate){u=f?K(o):i;u.update()}}}function E(e,t,n){if(e){e.insertBefore(n,t);e.removeChild(t)}}function S(e,t){A(e,function(e,n){var r=e.dom,i=e.attr,o=v(e.expr,t),a=e.dom.parentNode;if(e.bool)o=o?i:false;else if(o==null)o=\"\";if(a&&a.tagName==\"TEXTAREA\"){o=(\"\"+o).replace(/riot-/g,\"\");a.value=o}if(e.value===o)return;e.value=o;if(!i){r.nodeValue=\"\"+o;return}$(r,i);if(O(o)){M(i,o,r,t)}else if(i==\"if\"){var c=e.stub,l=function(){E(c.parentNode,c,r)},p=function(){E(r.parentNode,r,c)};if(o){if(c){l();r.inStub=false;if(!G(r)){Q(r,function(e){if(e._tag&&!e._tag.isMounted)e._tag.isMounted=!!e._tag.trigger(\"mount\")})}}}else{c=e.stub=c||document.createTextNode(\"\");if(r.parentNode)p();else(t.parent||t).one(\"updated\",p);r.inStub=true}}else if(/^(show|hide)$/.test(i)){if(i==\"hide\")o=!o;r.style.display=o?\"\":\"none\"}else if(i==\"value\"){r.value=o}else if(oe(i,f)&&i!=u){if(o)k(r,i.slice(f.length),o)}else{if(e.bool){r[i]=o;if(!o)return}if(o&&o!=0&&typeof o!==s)k(r,i,o)}})}function A(e,t){for(var n=0,r=(e||[]).length,i;n<r;n++){i=e[n];if(i!=null&&t(i,n)===false)n--}return e}function O(e){return typeof e===l||false}function $(e,t){e.removeAttribute(t)}function H(e){return e.replace(/-(\\w)/g,function(e,t){return t.toUpperCase()})}function R(e,t){return e.getAttribute(t)}function k(e,t,n){e.setAttribute(t,n)}function j(e){return e.tagName&&o[R(e,u)||e.tagName.toLowerCase()]}function I(e,t,n){var r=n.tags[t];if(r){if(!U(r))if(r!==e)n.tags[t]=[r];if(!z(n.tags[t],e))n.tags[t].push(e)}else{n.tags[t]=e}}function F(e,t,n){var r=e.parent,i;if(!r)return;i=r.tags[t];if(U(i))i.splice(n,0,i.splice(i.indexOf(e),1)[0]);else I(e,t,r)}function B(e,t,n,r){var i=new C(e,t,n),o=D(t.root),f=K(r);i.parent=f;i._parent=r;I(i,o,f);if(f!==r)I(i,o,r);t.root.innerHTML=\"\";return i}function K(e){var t=e;while(!j(t.root)){if(!t.parent)break;t=t.parent}return t}function q(e,t,n,r){Object.defineProperty(e,t,P({value:n,enumerable:false,writable:false,configurable:false},r));return e}function D(e){var t=j(e),n=R(e,\"name\"),r=n&&!v.hasExpr(n)?n:t?t.name:e.tagName.toLowerCase();return r}function P(e){var t,n=arguments;for(var r=1;r<n.length;++r){if(t=n[r]){for(var i in t){if(V(e,i))e[i]=t[i]}}}return e}function z(e,t){return~e.indexOf(t)}function U(e){return Array.isArray(e)||e instanceof Array}function V(e,t){var n=Object.getOwnPropertyDescriptor(e,t);return typeof e[t]===c||n&&n.writable}function Z(e){if(!(e instanceof C)&&!(e&&typeof e.trigger==l))return e;var t={};for(var n in e){if(!z(d,n))t[n]=e[n]}return t}function Q(e,t){if(e){if(t(e)===false)return;else{e=e.firstChild;while(e){Q(e,t);e=e.nextSibling}}}}function Y(e,t){var n,r=/([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;while(n=r.exec(e)){t(n[1].toLowerCase(),n[2]||n[3]||n[4])}}function G(e){while(e){if(e.inStub)return true;e=e.parentNode}return false}function W(e){return document.createElement(e)}function X(e,t){var n=W(e);n.innerHTML=t||\"\";return n}function J(e,t){var n=X(\"div\",e);if(n.querySelector&&n.querySelector(\"yield[from]\")){A(X(\"div\",t).childNodes,function(e){if(e.nodeType==1&&e.tagName==\"YIELD\"&&e.getAttribute(\"to\")){A(ee('yield[from=\"'+e.getAttribute(\"to\")+'\"]',n),function(t){t.outerHTML=e.innerHTML})}});return n.innerHTML}else return e.replace(/<yield\\s*(?:\\/>|>\\s*<\\/yield\\s*>)/gi,t||\"\")}function ee(e,t){return(t||document).querySelectorAll(e)}function te(e,t){return(t||document).querySelector(e)}function ne(e){function t(){}t.prototype=e;return new t}function re(e){return R(e,\"id\")||R(e,\"name\")}function ie(e,t,n){var r=re(e),i=function(i){if(z(n,r))return;var o=U(i);if(!i)t[r]=e;else if(!o||o&&!z(i,e)){if(o)i.push(e);else t[r]=[i,e]}};if(!r)return;if(v.hasExpr(r))t.one(\"updated\",function(){r=re(e);i(t[r])});else i(t[r])}function oe(e,t){return e.slice(0,t.length)===t}var fe=function(){if(!e)return;var t=W(\"style\"),n=te(\"style[type=riot]\");k(t,\"type\",\"text/css\");if(n){n.parentNode.replaceChild(t,n);n=null}else document.getElementsByTagName(\"head\")[0].appendChild(t);return t.styleSheet?function(e){t.styleSheet.cssText+=e}:function(e){t.innerHTML+=e}}();var ue=function(e){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(e||{});function ae(e,t,n){var r=o[t],f=e._innerHTML=e._innerHTML||e.innerHTML;e.innerHTML=\"\";if(r&&e)r=new C(r,{root:e,opts:n},f);if(r&&r.mount){r.mount();if(!z(i,r))i.push(r)}return r}n.util={brackets:h,tmpl:v};n.mixin=function(){var e={};return function(t,n){if(!n)return e[t];e[t]=n}}();n.tag=function(e,t,n,r,i){if(O(r)){i=r;if(/^[\\w\\-]+\\s?=/.test(n)){r=n;n=\"\"}else r=\"\"}if(n){if(O(n))i=n;else if(fe)fe(n)}o[e]={name:e,tmpl:t,attrs:r,fn:i};return e};n.tag2=function(e,t,n,r,i,f){if(n&&fe)fe(n);o[e]={name:e,tmpl:t,attrs:r,fn:i};return e};n.mount=function(e,t,n){var r,i,f=[];function c(e){var t=\"\";A(e,function(e){t+=\", *[\"+u+'=\"'+e.trim()+'\"]'});return t}function l(){var e=Object.keys(o);return e+c(e)}function p(e){var r;if(e.tagName){if(t&&(!(r=R(e,u))||r!=t))k(e,u,t);var i=ae(e,t||e.getAttribute(u)||e.tagName.toLowerCase(),n);if(i)f.push(i)}else if(e.length)A(e,p)}if(typeof t===s){n=t;t=0}if(typeof e===a){if(e===\"*\")e=i=l();else e+=c(e.split(\",\"));r=e?ee(e):[]}else r=e;if(t===\"*\"){t=i||l();if(r.tagName)r=ee(t,r);else{var d=[];A(r,function(e){d.push(ee(t,e))});r=d}t=0}if(r.tagName)p(r);else A(r,p);return f};n.update=function(){return A(i,function(e){e.update()})};n.Tag=C;if(typeof exports===s)module.exports=n;else if(typeof define===l&&typeof define.amd!==c)define(function(){return e.riot=n});else e.riot=n})(typeof window!=\"undefined\"?window:void 0);\n","source":"unrest/bower_components/riot/riot.min.js","raw":"/* Riot v2.3.12, @license MIT, (c) 2015 Muut Inc. + contributors */\n(function(e,t){\"use strict\";var n={version:\"v2.3.12\",settings:{}},r=0,i=[],o={},f=\"riot-\",u=f+\"tag\",a=\"string\",s=\"object\",c=\"undefined\",l=\"function\",p=/^(?:opt(ion|group)|tbody|col|t[rhd])$/,d=[\"_item\",\"_id\",\"_parent\",\"update\",\"root\",\"mount\",\"unmount\",\"mixin\",\"isMounted\",\"isLoop\",\"tags\",\"parent\",\"opts\",\"trigger\",\"on\",\"off\",\"one\"],g=(e&&e.document||{}).documentMode|0;n.observable=function(e){e=e||{};var t={},n=function(e,t){e.replace(/\\S+/g,t)},r=function(t,n){Object.defineProperty(e,t,{value:n,enumerable:false,writable:false,configurable:false})};r(\"on\",function(r,i){if(typeof i!=\"function\")return e;n(r,function(e,n){(t[e]=t[e]||[]).push(i);i.typed=n>0});return e});r(\"off\",function(r,i){if(r==\"*\")t={};else{n(r,function(e){if(i){var n=t[e];for(var r=0,o;o=n&&n[r];++r){if(o==i)n.splice(r--,1)}}else delete t[e]})}return e});r(\"one\",function(t,n){function r(){e.off(t,r);n.apply(e,arguments)}return e.on(t,r)});r(\"trigger\",function(r){var i=arguments.length-1,o=new Array(i);for(var f=0;f<i;f++){o[f]=arguments[f+1]}n(r,function(n){var r=(t[n]||[]).slice(0);for(var i=0,f;f=r[i];++i){if(f.busy)return;f.busy=1;try{f.apply(e,f.typed?[n].concat(o):o)}catch(u){e.trigger(\"error\",u)}if(r[i]!==f){i--}f.busy=0}if(t.all&&n!=\"all\")e.trigger.apply(e,[\"all\",n].concat(o))});return e});return e};(function(t){if(!e)return;var n=/^.+?\\/+[^\\/]+/,r=\"EventListener\",i=\"remove\"+r,o=\"add\"+r,f=\"hasAttribute\",u=\"replace\",a=\"popstate\",s=\"hashchange\",c=\"trigger\",l=3,p=e,d=document,g=p.history.location||p.location,h=O.prototype,v=d&&d.ontouchstart?\"touchstart\":\"click\",m=false,y=t.observable(),b=false,w,x,_,N,L,T=[],C=0;function M(e){return e.split(/[\\/?#]/)}function E(e,t){var n=new RegExp(\"^\"+t[u](/\\*/g,\"([^/?#]+?)\")[u](/\\.\\./,\".*\")+\"$\"),r=e.match(n);if(r)return r.slice(1)}function S(e,t){var n;return function(){clearTimeout(n);n=setTimeout(e,t)}}function A(e){w=S(j,1);p[o](a,w);p[o](s,w);d[o](v,I);if(e)j(true)}function O(){this.$=[];t.observable(this);y.on(\"stop\",this.s.bind(this));y.on(\"emit\",this.e.bind(this))}function $(e){return e[u](/^\\/|\\/$/,\"\")}function H(e){return typeof e==\"string\"}function R(e){return(e||g.href)[u](n,\"\")}function k(e){return x[0]==\"#\"?(e||g.href).split(x)[1]||\"\":R(e)[u](x,\"\")}function j(e){var t=C==0;if(l<=C)return;C++;T.push(function(){var t=k();if(e||t!=_){y[c](\"emit\",t);_=t}});if(t){while(T.length){T[0]();T.shift()}C=0}}function I(e){if(e.which!=1||e.metaKey||e.ctrlKey||e.shiftKey||e.defaultPrevented)return;var t=e.target;while(t&&t.nodeName!=\"A\")t=t.parentNode;if(!t||t.nodeName!=\"A\"||t[f](\"download\")||!t[f](\"href\")||t.target&&t.target!=\"_self\"||t.href.indexOf(g.href.match(n)[0])==-1)return;if(t.href!=g.href){if(t.href.split(\"#\")[0]==g.href.split(\"#\")[0]||x!=\"#\"&&R(t.href).indexOf(x)!==0||!F(k(t.href),t.title||d.title))return}e.preventDefault()}function F(e,t){t=t||d.title;history.pushState(null,t,x+$(e));d.title=t;b=false;j();return b}h.m=function(e,t){if(H(e)&&(!t||H(t)))F(e,t);else if(t)this.r(e,t);else this.r(\"@\",e)};h.s=function(){this.off(\"*\");this.$=[]};h.e=function(e){this.$.concat(\"@\").some(function(t){var n=(t==\"@\"?N:L)($(e),$(t));if(typeof n!=\"undefined\"){this[c].apply(null,[t].concat(n));return b=true}},this)};h.r=function(e,t){if(e!=\"@\"){e=\"/\"+$(e);this.$.push(e)}this.on(e,t)};var B=new O;var K=B.m.bind(B);K.create=function(){var e=new O;e.m.stop=e.s.bind(e);return e.m.bind(e)};K.base=function(e){x=e||\"#\";_=k()};K.exec=function(){j(true)};K.parser=function(e,t){if(!e&&!t){N=M;L=E}if(e)N=e;if(t)L=t};K.query=function(){var e={};g.href[u](/[?&](.+?)=([^&]*)/g,function(t,n,r){e[n]=r});return e};K.stop=function(){if(m){p[i](a,w);p[i](s,w);d[i](v,I);y[c](\"stop\");m=false}};K.start=function(e){if(!m){if(document.readyState==\"complete\")A(e);else p[o](\"load\",function(){setTimeout(function(){A(e)},1)});m=true}};K.base();K.parser();t.route=K})(n);var h=function(e){var t=\"g\",r=/\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,i=/\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,o=i.source+\"|\"+/(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source+\"|\"+/\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,f=\"{ }\",u={\"(\":RegExp(\"([()])|\"+o,t),\"[\":RegExp(\"([[\\\\]])|\"+o,t),\"{\":RegExp(\"([{}])|\"+o,t)};var a=e,s,c=[];function l(e){return e}function p(e,n){if(!n)n=c;return new RegExp(e.source.replace(/{/g,n[2]).replace(/}/g,n[3]),e.global?t:\"\")}function d(e){var n,r=e.split(\" \");if(e===f){r[2]=r[0];r[3]=r[1];n=l}else{if(r.length!==2||/[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(e)){throw new Error('Unsupported brackets \"'+e+'\"')}r=r.concat(e.replace(/(?=[[\\]()*+?.^$|])/g,\"\\\\\").split(\" \"));n=p}r[4]=n(r[1].length>1?/{[\\S\\s]*?}/:/{[^}]*}/,r);r[5]=n(/\\\\({|})/g,r);r[6]=n(/(\\\\?)({)/g,r);r[7]=RegExp(\"(\\\\\\\\?)(?:([[({])|(\"+r[3]+\"))|\"+o,t);r[8]=e;return r}function g(e){if(!e)e=f;if(e!==c[8]){c=d(e);s=e===f?l:p;c[9]=s(/^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/);c[10]=s(/(^|[^\\\\]){=[\\S\\s]*?}/);h._rawOffset=c[0].length}a=e}function h(e){return e instanceof RegExp?s(e):c[e]}h.split=function y(e,t,n){if(!n)n=c;var r=[],i,o,f,a,s=n[6];o=f=s.lastIndex=0;while(i=s.exec(e)){a=i.index;if(o){if(i[2]){s.lastIndex=p(i[2],s.lastIndex);continue}if(!i[3])continue}if(!i[1]){l(e.slice(f,a));f=s.lastIndex;s=n[6+(o^=1)];s.lastIndex=f}}if(e&&f<e.length){l(e.slice(f))}return r;function l(e){if(t||o)r.push(e&&e.replace(n[5],\"$1\"));else r.push(e)}function p(t,n){var r,i=u[t],o=1;i.lastIndex=n;while(r=i.exec(e)){if(r[1]&&!(r[1]===t?++o:--o))break}return r?i.lastIndex:e.length}};h.hasExpr=function b(e){return h(4).test(e)};h.loopKeys=function w(e){var t=e.match(h(9));return t?{key:t[1],pos:t[2],val:c[0]+t[3].trim()+c[1]}:{val:e.trim()}};h.array=function x(e){return d(e||a)};var v;function m(e){var t;e=e||{};t=e.brackets;Object.defineProperty(e,\"brackets\",{set:g,get:function(){return a},enumerable:true});v=e;g(t)}Object.defineProperty(h,\"settings\",{set:m,get:function(){return v}});h.settings=typeof n!==\"undefined\"&&n.settings||{};h.set=g;h.R_STRINGS=i;h.R_MLCOMMS=r;h.S_QBLOCKS=o;return h}();var v=function(){var t={};function n(e,n){if(!e)return e;return(t[e]||(t[e]=i(e))).call(n,r)}n.isRaw=function(e){return e[h._rawOffset]===\"=\"};n.haveRaw=function(e){return h(10).test(e)};n.hasExpr=h.hasExpr;n.loopKeys=h.loopKeys;n.errorHandler=null;function r(e,t){if(n.errorHandler){e.riotData={tagName:t&&t.root&&t.root.tagName,_riot_id:t&&t._riot_id};n.errorHandler(e)}}function i(e){var t=u(e);if(t.slice(0,11)!==\"try{return \")t=\"return \"+t;return new Function(\"E\",t+\";\")}var o=RegExp(h.S_QBLOCKS,\"g\"),f=/\\x01(\\d+)~/g;function u(e){var t=[],n,r=h.split(e.replace(/\\u2057/g,'\"'),1);if(r.length>2||r[0]){var i,o,u=[];for(i=o=0;i<r.length;++i){n=r[i];if(n&&(n=i&1?c(n,1,t):'\"'+n.replace(/\\\\/g,\"\\\\\\\\\").replace(/\\r\\n?|\\n/g,\"\\\\n\").replace(/\"/g,'\\\\\"')+'\"'))u[o++]=n}n=o<2?u[0]:\"[\"+u.join(\",\")+'].join(\"\")'}else{n=c(r[1],0,t)}if(t[0])n=n.replace(f,function(e,n){return t[n].replace(/\\r/g,\"\\\\r\").replace(/\\n/g,\"\\\\n\")});return n}var a=/^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\x01(\\d+)~):/,s=/,|([[{(])|$/g;function c(e,t,n){if(e[0]===\"=\")e=e.slice(1);e=e.replace(o,function(e,t){return e.length>2&&!t?\"\u0001\"+(n.push(e)-1)+\"~\":e}).replace(/\\s+/g,\" \").trim().replace(/\\ ?([[\\({},?\\.:])\\ ?/g,\"$1\");if(e){var r=[],i=0,f;while(e&&(f=e.match(a))&&!f.index){var u,s,c=/,|([[{(])|$/g;e=RegExp.rightContext;u=f[2]?n[f[2]].slice(1,-1).trim().replace(/\\s+/g,\" \"):f[1];while(s=(f=c.exec(e))[1])l(s,c);s=e.slice(0,f.index);e=RegExp.rightContext;r[i++]=d(s,1,u)}e=!i?d(e,t):i>1?\"[\"+r.join(\",\")+'].join(\" \").trim()':r[0]}return e;function l(t,n){var r,i=1,o=t===\"(\"?/[()]/g:t===\"[\"?/[[\\]]/g:/[{}]/g;o.lastIndex=n.lastIndex;while(r=o.exec(e)){if(r[0]===t)++i;else if(!--i)break}n.lastIndex=i?e.length:o.lastIndex}}var l='\"in this?this:'+(typeof e!==\"object\"?\"global\":\"window\")+\").\";var p=/[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g;function d(e,t,n){var r;e=e.replace(p,function(e,t,n,i,o){if(n){i=r?0:i+e.length;if(n!==\"this\"&&n!==\"global\"&&n!==\"window\"){e=t+'(\"'+n+l+n;if(i)r=(o=o[i])===\".\"||o===\"(\"||o===\"[\"}else if(i)r=!/^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/.test(o.slice(i))}return e});if(r){e=\"try{return \"+e+\"}catch(e){E(e,this)}\"}if(n){e=(r?\"function(){\"+e+\"}.call(this)\":\"(\"+e+\")\")+'?\"'+n+'\":\"\"'}else if(t){e=\"function(v){\"+(r?e.replace(\"return \",\"v=\"):\"v=(\"+e+\")\")+';return v||v===0?v:\"\"}.call(this)'}return e}n.parse=function(e){return e};return n}();v.version=h.version=\"v2.3.19\";var m=function(e){var t={tr:\"tbody\",th:\"tr\",td:\"tr\",tbody:\"table\",col:\"colgroup\"},n=\"div\";e=e&&e<10;function r(r){var o=r&&r.match(/^\\s*<([-\\w]+)/),f=o&&o[1].toLowerCase(),u=t[f]||n,a=W(u);a.stub=true;if(e&&f&&(o=f.match(p)))i(a,r,f,!!o[1]);else a.innerHTML=r;return a}function i(e,t,r,i){var o=W(n),f=i?\"select>\":\"table>\",u;o.innerHTML=\"<\"+f+t+\"</\"+f;u=te(r,o);if(u)e.appendChild(u)}return r}(g);function y(e,t,n){var r={};r[e.key]=t;if(e.pos)r[e.pos]=n;return r}function b(e,t){var n=t.length,r=e.length;while(n>r){var i=t[--n];t.splice(n,1);i.unmount()}}function w(e,t){Object.keys(e.tags).forEach(function(n){var r=e.tags[n];if(U(r))A(r,function(e){F(e,n,t)});else F(r,n,t)})}function x(e,t,n){var r=e._root;e._virts=[];while(r){var i=r.nextSibling;if(n)t.insertBefore(r,n._root);else t.appendChild(r);e._virts.push(r);r=i}}function _(e,t,n,r){var i=e._root;for(var o=0;o<r;o++){var f=i.nextSibling;t.insertBefore(i,n._root);i=f}}function N(e,t,n){$(e,\"each\");var r=typeof R(e,\"no-reorder\")!==a||$(e,\"no-reorder\"),i=D(e),f=o[i]||{tmpl:e.outerHTML},u=p.test(i),s=e.parentNode,c=document.createTextNode(\"\"),l=j(e),d=/option/gi.test(i),g=[],h=[],m,N=e.tagName==\"VIRTUAL\";n=v.loopKeys(n);s.insertBefore(c,e);t.one(\"before-mount\",function(){e.parentNode.removeChild(e);if(s.stub)s=t.root}).on(\"update\",function(){var a=v(n.val,t),p=document.createDocumentFragment();if(!U(a)){m=a||false;a=m?Object.keys(a).map(function(e){return y(n,e,a[e])}):[]}a.forEach(function(a,c){var d=r&&a instanceof Object,v=h.indexOf(a),b=~v&&d?v:c,L=g[b];a=!m&&n.key?y(n,a,c):a;if(!d&&!L||d&&!~v||!L){L=new C(f,{parent:t,isLoop:true,hasImpl:!!o[i],root:u?s:e.cloneNode(),item:a},e.innerHTML);L.mount();if(N)L._root=L.root.firstChild;if(c==g.length){if(N)x(L,p);else p.appendChild(L.root)}else{if(N)x(L,s,g[c]);else s.insertBefore(L.root,g[c].root);h.splice(c,0,a)}g.splice(c,0,L);b=c}else L.update(a);if(b!==c&&d){if(N)_(L,s,g[c],e.childNodes.length);else s.insertBefore(L.root,g[c].root);if(n.pos)L[n.pos]=c;g.splice(c,0,g.splice(b,1)[0]);h.splice(c,0,h.splice(b,1)[0]);if(!l)w(L,c)}L._item=a;q(L,\"_parent\",t)},true);b(a,g);if(d)s.appendChild(p);else s.insertBefore(p,c);if(l)t.tags[i]=g;h=a.slice()})}function L(e,t,n,r){Q(e,function(e){if(e.nodeType==1){e.isLoop=e.isLoop||(e.parentNode&&e.parentNode.isLoop||R(e,\"each\"))?1:0;if(n){var i=j(e);if(i&&!e.isLoop)n.push(B(i,{root:e,parent:t},e.innerHTML,t))}if(!e.isLoop||r)ie(e,t,[])}})}function T(e,t,n){function r(e,t,r){if(v.hasExpr(t)){var i={dom:e,expr:t};n.push(P(i,r))}}Q(e,function(e){var n=e.nodeType;if(n==3&&e.parentNode.tagName!=\"STYLE\")r(e,e.nodeValue);if(n!=1)return;var i=R(e,\"each\");if(i){N(e,t,i);return false}A(e.attributes,function(t){var n=t.name,i=n.split(\"__\")[1];r(e,t.value,{attr:i||n,bool:i});if(i){$(e,n);return false}});if(j(e))return false})}function C(e,o,f){var u=n.observable(this),l=ne(o.opts)||{},p=m(e.tmpl),g=o.parent,h=o.isLoop,y=o.hasImpl,b=Z(o.item),w=[],x=[],_=o.root,N=e.fn,C=_.tagName.toLowerCase(),M={},E=[];if(N&&_._tag)_._tag.unmount(true);this.isMounted=false;_.isLoop=h;_._tag=this;q(this,\"_riot_id\",++r);P(this,{parent:g,root:_,opts:l,tags:{}},b);A(_.attributes,function(e){var t=e.value;if(v.hasExpr(t))M[e.name]=t});if(p.innerHTML&&!/^(select|optgroup|table|tbody|tr|col(?:group)?)$/.test(C))p.innerHTML=J(p.innerHTML,f);function R(){var e=y&&h?u:g||u;A(_.attributes,function(t){l[H(t.name)]=v(t.value,e)});A(Object.keys(M),function(t){l[H(t)]=v(M[t],e)})}function j(e){for(var t in b){if(typeof u[t]!==c&&V(u,t))u[t]=e[t]}}function I(){if(!u.parent||!h)return;A(Object.keys(u.parent),function(e){var t=!z(d,e)&&z(E,e);if(typeof u[e]===c||t){if(!t)E.push(e);u[e]=u.parent[e]}})}q(this,\"update\",function(e){e=Z(e);I();if(e&&typeof b===s){j(e);b=e}P(u,e);R();u.trigger(\"update\",e);S(w,u);ue(function(){u.trigger(\"updated\")});return this});q(this,\"mixin\",function(){A(arguments,function(e){var t;e=typeof e===a?n.mixin(e):e;if(O(e)){t=new e;e=e.prototype}else t=e;A(Object.getOwnPropertyNames(e),function(e){if(e!=\"init\")u[e]=O(t[e])?t[e].bind(u):t[e]});if(t.init)t.init.bind(u)()});return this});q(this,\"mount\",function(){R();if(N)N.call(u,l);T(p,u,w);F(true);if(e.attrs||y){Y(e.attrs,function(e,t){k(_,e,t)});T(u.root,u,w)}if(!u.parent||h)u.update(b);u.trigger(\"before-mount\");if(h&&!y){u.root=_=p.firstChild}else{while(p.firstChild)_.appendChild(p.firstChild);if(_.stub)u.root=_=g.root}if(h)L(u.root,u.parent,null,true);if(!u.parent||u.parent.isMounted){u.isMounted=true;u.trigger(\"mount\")}else u.parent.one(\"mount\",function(){if(!G(u.root)){u.parent.isMounted=u.isMounted=true;u.trigger(\"mount\")}})});q(this,\"unmount\",function(e){var n=_,r=n.parentNode,o;u.trigger(\"before-unmount\");i.splice(i.indexOf(u),1);if(this._virts){A(this._virts,function(e){e.parentNode.removeChild(e)})}if(r){if(g){o=K(g);if(U(o.tags[C]))A(o.tags[C],function(e,t){if(e._riot_id==u._riot_id)o.tags[C].splice(t,1)});else o.tags[C]=t}else while(n.firstChild)n.removeChild(n.firstChild);if(!e)r.removeChild(n);else $(r,\"riot-tag\")}u.trigger(\"unmount\");F();u.off(\"*\");u.isMounted=false;_._tag=null});function F(e){A(x,function(t){t[e?\"mount\":\"unmount\"]()});if(g){var t=e?\"on\":\"off\";if(h)g[t](\"unmount\",u.unmount);else g[t](\"update\",u.update)[t](\"unmount\",u.unmount)}}L(p,this,x)}function M(t,n,r,i){r[t]=function(t){var o=i._parent,f=i._item,u;if(!f)while(o&&!f){f=o._item;o=o._parent}t=t||e.event;if(V(t,\"currentTarget\"))t.currentTarget=r;if(V(t,\"target\"))t.target=t.srcElement;if(V(t,\"which\"))t.which=t.charCode||t.keyCode;t.item=f;if(n.call(i,t)!==true&&!/radio|check/.test(r.type)){if(t.preventDefault)t.preventDefault();t.returnValue=false}if(!t.preventUpdate){u=f?K(o):i;u.update()}}}function E(e,t,n){if(e){e.insertBefore(n,t);e.removeChild(t)}}function S(e,t){A(e,function(e,n){var r=e.dom,i=e.attr,o=v(e.expr,t),a=e.dom.parentNode;if(e.bool)o=o?i:false;else if(o==null)o=\"\";if(a&&a.tagName==\"TEXTAREA\"){o=(\"\"+o).replace(/riot-/g,\"\");a.value=o}if(e.value===o)return;e.value=o;if(!i){r.nodeValue=\"\"+o;return}$(r,i);if(O(o)){M(i,o,r,t)}else if(i==\"if\"){var c=e.stub,l=function(){E(c.parentNode,c,r)},p=function(){E(r.parentNode,r,c)};if(o){if(c){l();r.inStub=false;if(!G(r)){Q(r,function(e){if(e._tag&&!e._tag.isMounted)e._tag.isMounted=!!e._tag.trigger(\"mount\")})}}}else{c=e.stub=c||document.createTextNode(\"\");if(r.parentNode)p();else(t.parent||t).one(\"updated\",p);r.inStub=true}}else if(/^(show|hide)$/.test(i)){if(i==\"hide\")o=!o;r.style.display=o?\"\":\"none\"}else if(i==\"value\"){r.value=o}else if(oe(i,f)&&i!=u){if(o)k(r,i.slice(f.length),o)}else{if(e.bool){r[i]=o;if(!o)return}if(o&&o!=0&&typeof o!==s)k(r,i,o)}})}function A(e,t){for(var n=0,r=(e||[]).length,i;n<r;n++){i=e[n];if(i!=null&&t(i,n)===false)n--}return e}function O(e){return typeof e===l||false}function $(e,t){e.removeAttribute(t)}function H(e){return e.replace(/-(\\w)/g,function(e,t){return t.toUpperCase()})}function R(e,t){return e.getAttribute(t)}function k(e,t,n){e.setAttribute(t,n)}function j(e){return e.tagName&&o[R(e,u)||e.tagName.toLowerCase()]}function I(e,t,n){var r=n.tags[t];if(r){if(!U(r))if(r!==e)n.tags[t]=[r];if(!z(n.tags[t],e))n.tags[t].push(e)}else{n.tags[t]=e}}function F(e,t,n){var r=e.parent,i;if(!r)return;i=r.tags[t];if(U(i))i.splice(n,0,i.splice(i.indexOf(e),1)[0]);else I(e,t,r)}function B(e,t,n,r){var i=new C(e,t,n),o=D(t.root),f=K(r);i.parent=f;i._parent=r;I(i,o,f);if(f!==r)I(i,o,r);t.root.innerHTML=\"\";return i}function K(e){var t=e;while(!j(t.root)){if(!t.parent)break;t=t.parent}return t}function q(e,t,n,r){Object.defineProperty(e,t,P({value:n,enumerable:false,writable:false,configurable:false},r));return e}function D(e){var t=j(e),n=R(e,\"name\"),r=n&&!v.hasExpr(n)?n:t?t.name:e.tagName.toLowerCase();return r}function P(e){var t,n=arguments;for(var r=1;r<n.length;++r){if(t=n[r]){for(var i in t){if(V(e,i))e[i]=t[i]}}}return e}function z(e,t){return~e.indexOf(t)}function U(e){return Array.isArray(e)||e instanceof Array}function V(e,t){var n=Object.getOwnPropertyDescriptor(e,t);return typeof e[t]===c||n&&n.writable}function Z(e){if(!(e instanceof C)&&!(e&&typeof e.trigger==l))return e;var t={};for(var n in e){if(!z(d,n))t[n]=e[n]}return t}function Q(e,t){if(e){if(t(e)===false)return;else{e=e.firstChild;while(e){Q(e,t);e=e.nextSibling}}}}function Y(e,t){var n,r=/([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;while(n=r.exec(e)){t(n[1].toLowerCase(),n[2]||n[3]||n[4])}}function G(e){while(e){if(e.inStub)return true;e=e.parentNode}return false}function W(e){return document.createElement(e)}function X(e,t){var n=W(e);n.innerHTML=t||\"\";return n}function J(e,t){var n=X(\"div\",e);if(n.querySelector&&n.querySelector(\"yield[from]\")){A(X(\"div\",t).childNodes,function(e){if(e.nodeType==1&&e.tagName==\"YIELD\"&&e.getAttribute(\"to\")){A(ee('yield[from=\"'+e.getAttribute(\"to\")+'\"]',n),function(t){t.outerHTML=e.innerHTML})}});return n.innerHTML}else return e.replace(/<yield\\s*(?:\\/>|>\\s*<\\/yield\\s*>)/gi,t||\"\")}function ee(e,t){return(t||document).querySelectorAll(e)}function te(e,t){return(t||document).querySelector(e)}function ne(e){function t(){}t.prototype=e;return new t}function re(e){return R(e,\"id\")||R(e,\"name\")}function ie(e,t,n){var r=re(e),i=function(i){if(z(n,r))return;var o=U(i);if(!i)t[r]=e;else if(!o||o&&!z(i,e)){if(o)i.push(e);else t[r]=[i,e]}};if(!r)return;if(v.hasExpr(r))t.one(\"updated\",function(){r=re(e);i(t[r])});else i(t[r])}function oe(e,t){return e.slice(0,t.length)===t}var fe=function(){if(!e)return;var t=W(\"style\"),n=te(\"style[type=riot]\");k(t,\"type\",\"text/css\");if(n){n.parentNode.replaceChild(t,n);n=null}else document.getElementsByTagName(\"head\")[0].appendChild(t);return t.styleSheet?function(e){t.styleSheet.cssText+=e}:function(e){t.innerHTML+=e}}();var ue=function(e){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(e||{});function ae(e,t,n){var r=o[t],f=e._innerHTML=e._innerHTML||e.innerHTML;e.innerHTML=\"\";if(r&&e)r=new C(r,{root:e,opts:n},f);if(r&&r.mount){r.mount();if(!z(i,r))i.push(r)}return r}n.util={brackets:h,tmpl:v};n.mixin=function(){var e={};return function(t,n){if(!n)return e[t];e[t]=n}}();n.tag=function(e,t,n,r,i){if(O(r)){i=r;if(/^[\\w\\-]+\\s?=/.test(n)){r=n;n=\"\"}else r=\"\"}if(n){if(O(n))i=n;else if(fe)fe(n)}o[e]={name:e,tmpl:t,attrs:r,fn:i};return e};n.tag2=function(e,t,n,r,i,f){if(n&&fe)fe(n);o[e]={name:e,tmpl:t,attrs:r,fn:i};return e};n.mount=function(e,t,n){var r,i,f=[];function c(e){var t=\"\";A(e,function(e){t+=\", *[\"+u+'=\"'+e.trim()+'\"]'});return t}function l(){var e=Object.keys(o);return e+c(e)}function p(e){var r;if(e.tagName){if(t&&(!(r=R(e,u))||r!=t))k(e,u,t);var i=ae(e,t||e.getAttribute(u)||e.tagName.toLowerCase(),n);if(i)f.push(i)}else if(e.length)A(e,p)}if(typeof t===s){n=t;t=0}if(typeof e===a){if(e===\"*\")e=i=l();else e+=c(e.split(\",\"));r=e?ee(e):[]}else r=e;if(t===\"*\"){t=i||l();if(r.tagName)r=ee(t,r);else{var d=[];A(r,function(e){d.push(ee(t,e))});r=d}t=0}if(r.tagName)p(r);else A(r,p);return f};n.update=function(){return A(i,function(e){e.update()})};n.Tag=C;if(typeof exports===s)module.exports=n;else if(typeof define===l&&typeof define.amd!==c)define(function(){return e.riot=n});else e.riot=n})(typeof window!=\"undefined\"?window:void 0);\n","date":"2015-12-17T03:11:20.964Z","updated":"2015-12-15T21:11:22.000Z","path":"unrest/bower_components/riot/riot.min.js","layout":"false","title":"","comments":1,"_id":"cijth4lal000b0nfwzoobfhye"},{"_content":"/* Riot v2.3.12, @license MIT, (c) 2015 Muut Inc. + contributors */\n\n;(function(window, undefined) {\n  'use strict';\nvar riot = { version: 'v2.3.12', settings: {} },\n  // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n\n  // counter to give a unique id to all the Tag instances\n  __uid = 0,\n  // tags instances cache\n  __virtualDom = [],\n  // tags implementation cache\n  __tagImpl = {},\n\n  /**\n   * Const\n   */\n  // riot specific prefixes\n  RIOT_PREFIX = 'riot-',\n  RIOT_TAG = RIOT_PREFIX + 'tag',\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n  T_OBJECT = 'object',\n  T_UNDEF  = 'undefined',\n  T_FUNCTION = 'function',\n  // special native tags that cannot be treated like the others\n  SPECIAL_TAGS_REGEX = /^(?:opt(ion|group)|tbody|col|t[rhd])$/,\n  RESERVED_WORDS_BLACKLIST = ['_item', '_id', '_parent', 'update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isLoop', 'tags', 'parent', 'opts', 'trigger', 'on', 'off', 'one'],\n\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (window && window.document || {}).documentMode | 0\n/* istanbul ignore next */\nriot.observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {}\n\n  /**\n   * Private variables and methods\n   */\n\n  var callbacks = {},\n    onEachEvent = function(e, fn) { e.replace(/\\S+/g, fn) },\n    defineProperty = function (key, value) {\n      Object.defineProperty(el, key, {\n        value: value,\n        enumerable: false,\n        writable: false,\n        configurable: false\n      })\n    }\n\n  /**\n   * Listen to the given space separated list of `events` and execute the `callback` each time an event is triggered.\n   * @param  { String } events - events ids\n   * @param  { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('on', function(events, fn) {\n    if (typeof fn != 'function')  return el\n\n    onEachEvent(events, function(name, pos) {\n      (callbacks[name] = callbacks[name] || []).push(fn)\n      fn.typed = pos > 0\n    })\n\n    return el\n  })\n\n  /**\n   * Removes the given space separated list of `events` listeners\n   * @param   { String } events - events ids\n   * @param   { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('off', function(events, fn) {\n    if (events == '*') callbacks = {}\n    else {\n      onEachEvent(events, function(name) {\n        if (fn) {\n          var arr = callbacks[name]\n          for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n            if (cb == fn) arr.splice(i--, 1)\n          }\n        } else delete callbacks[name]\n      })\n    }\n    return el\n  })\n\n  /**\n   * Listen to the given space separated list of `events` and execute the `callback` at most once\n   * @param   { String } events - events ids\n   * @param   { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('one', function(events, fn) {\n    function on() {\n      el.off(events, on)\n      fn.apply(el, arguments)\n    }\n    return el.on(events, on)\n  })\n\n  /**\n   * Execute all callback functions that listen to the given space separated list of `events`\n   * @param   { String } events - events ids\n   * @returns { Object } el\n   */\n\n  defineProperty('trigger', function(events) {\n\n    // getting the arguments\n    // skipping the first one\n    var arglen = arguments.length - 1,\n      args = new Array(arglen)\n    for (var i = 0; i < arglen; i++) {\n      args[i] = arguments[i + 1]\n    }\n\n    onEachEvent(events, function(name) {\n\n      var fns = (callbacks[name] || []).slice(0)\n\n      for (var i = 0, fn; fn = fns[i]; ++i) {\n        if (fn.busy) return\n        fn.busy = 1\n\n        try {\n          fn.apply(el, fn.typed ? [name].concat(args) : args)\n        } catch (e) { el.trigger('error', e) }\n        if (fns[i] !== fn) { i-- }\n        fn.busy = 0\n      }\n\n      if (callbacks.all && name != 'all')\n        el.trigger.apply(el, ['all', name].concat(args))\n\n    })\n\n    return el\n  })\n\n  return el\n\n}\n/* istanbul ignore next */\n;(function(riot) { if (!window) return;\n\n/**\n * Simple client-side router\n * @module riot-route\n */\n\n\nvar RE_ORIGIN = /^.+?\\/+[^\\/]+/,\n  EVENT_LISTENER = 'EventListener',\n  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n  HAS_ATTRIBUTE = 'hasAttribute',\n  REPLACE = 'replace',\n  POPSTATE = 'popstate',\n  HASHCHANGE = 'hashchange',\n  TRIGGER = 'trigger',\n  MAX_EMIT_STACK_LEVEL = 3,\n  win = window,\n  doc = document,\n  loc = win.history.location || win.location, // see html5-history-api\n  prot = Router.prototype, // to minify more\n  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n  started = false,\n  central = riot.observable(),\n  routeFound = false,\n  debouncedEmit,\n  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/)\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var re = new RegExp('^' + filter[REPLACE](/\\*/g, '([^/?#]+?)')[REPLACE](/\\.\\./, '.*') + '$'),\n    args = path.match(re)\n\n  if (args) return args.slice(1)\n}\n\n/**\n * Simple/cheap debounce implementation\n * @param   {function} fn - callback\n * @param   {number} delay - delay in seconds\n * @returns {function} debounced function\n */\nfunction debounce(fn, delay) {\n  var t\n  return function () {\n    clearTimeout(t)\n    t = setTimeout(fn, delay)\n  }\n}\n\n/**\n * Set the window listeners to trigger the routes\n * @param {boolean} autoExec - see route.start\n */\nfunction start(autoExec) {\n  debouncedEmit = debounce(emit, 1)\n  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit)\n  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n  doc[ADD_EVENT_LISTENER](clickEvent, click)\n  if (autoExec) emit(true)\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = []\n  riot.observable(this) // make it observable\n  central.on('stop', this.s.bind(this))\n  central.on('emit', this.e.bind(this))\n}\n\nfunction normalize(path) {\n  return path[REPLACE](/^\\/|\\/$/, '')\n}\n\nfunction isString(str) {\n  return typeof str == 'string'\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href)[REPLACE](RE_ORIGIN, '')\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  return base[0] == '#'\n    ? (href || loc.href).split(base)[1] || ''\n    : getPathFromRoot(href)[REPLACE](base, '')\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel == 0\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return\n\n  emitStackLevel++\n  emitStack.push(function() {\n    var path = getPathFromBase()\n    if (force || path != current) {\n      central[TRIGGER]('emit', path)\n      current = path\n    }\n  })\n  if (isRoot) {\n    while (emitStack.length) {\n      emitStack[0]()\n      emitStack.shift()\n    }\n    emitStackLevel = 0\n  }\n}\n\nfunction click(e) {\n  if (\n    e.which != 1 // not left click\n    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n    || e.defaultPrevented // or default prevented\n  ) return\n\n  var el = e.target\n  while (el && el.nodeName != 'A') el = el.parentNode\n  if (\n    !el || el.nodeName != 'A' // not A tag\n    || el[HAS_ATTRIBUTE]('download') // has download attr\n    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n    || el.target && el.target != '_self' // another window or frame\n    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin\n  ) return\n\n  if (el.href != loc.href) {\n    if (\n      el.href.split('#')[0] == loc.href.split('#')[0] // internal jump\n      || base != '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n    ) return\n  }\n\n  e.preventDefault()\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n * @returns {boolean} - route not found flag\n */\nfunction go(path, title) {\n  title = title || doc.title\n  // browsers ignores the second parameter `title`\n  history.pushState(null, title, base + normalize(path))\n  // so we need to set it manually\n  doc.title = title\n  routeFound = false\n  emit()\n  return routeFound\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n */\nprot.m = function(first, second) {\n  if (isString(first) && (!second || isString(second))) go(first, second)\n  else if (second) this.r(first, second)\n  else this.r('@', first)\n}\n\n/**\n * Stop routing\n */\nprot.s = function() {\n  this.off('*')\n  this.$ = []\n}\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function(path) {\n  this.$.concat('@').some(function(filter) {\n    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))\n    if (typeof args != 'undefined') {\n      this[TRIGGER].apply(null, [filter].concat(args))\n      return routeFound = true // exit from loop\n    }\n  }, this)\n}\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function(filter, action) {\n  if (filter != '@') {\n    filter = '/' + normalize(filter)\n    this.$.push(filter)\n  }\n  this.on(filter, action)\n}\n\nvar mainRouter = new Router()\nvar route = mainRouter.m.bind(mainRouter)\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function() {\n  var newSubRouter = new Router()\n  // stop only this sub-router\n  newSubRouter.m.stop = newSubRouter.s.bind(newSubRouter)\n  // return sub-router's main method\n  return newSubRouter.m.bind(newSubRouter)\n}\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function(arg) {\n  base = arg || '#'\n  current = getPathFromBase() // recalculate current path\n}\n\n/** Exec routing right now **/\nroute.exec = function() {\n  emit(true)\n}\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function(fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER\n    secondParser = DEFAULT_SECOND_PARSER\n  }\n  if (fn) parser = fn\n  if (fn2) secondParser = fn2\n}\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function() {\n  var q = {}\n  loc.href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })\n  return q\n}\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit)\n    win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n    doc[REMOVE_EVENT_LISTENER](clickEvent, click)\n    central[TRIGGER]('stop')\n    started = false\n  }\n}\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    if (document.readyState == 'complete') start(autoExec)\n    // the timeout is needed to solve\n    // a weird safari bug https://github.com/riot/route/issues/33\n    else win[ADD_EVENT_LISTENER]('load', function() {\n      setTimeout(function() { start(autoExec) }, 1)\n    })\n    started = true\n  }\n}\n\n/** Prepare the router **/\nroute.base()\nroute.parser()\n\nriot.route = route\n})(riot)\n/* istanbul ignore next */\n\n/**\n * The riot template engine\n * @version v2.3.19\n */\n\n/**\n * @module brackets\n *\n * `brackets         ` Returns a string or regex based on its parameter\n * `brackets.settings` Mirrors the `riot.settings` object (use brackets.set in new code)\n * `brackets.set     ` Change the current riot brackets\n */\n\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB  = 'g',\n\n    MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n    STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\n    S_QBSRC = STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    DEFAULT = '{ }',\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBSRC, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBSRC, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBSRC, REGLOB)\n    }\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _pairs = []\n\n  function _loopback(re) { return re }\n\n  function _rewrite(re, bp) {\n    if (!bp) bp = _pairs\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create(pair) {\n    var\n      cvt,\n      arr = pair.split(' ')\n\n    if (pair === DEFAULT) {\n      arr[2] = arr[0]\n      arr[3] = arr[1]\n      cvt = _loopback\n    }\n    else {\n      if (arr.length !== 2 || /[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(pair)) {\n        throw new Error('Unsupported brackets \"' + pair + '\"')\n      }\n      arr = arr.concat(pair.replace(/(?=[[\\]()*+?.^$|])/g, '\\\\').split(' '))\n      cvt = _rewrite\n    }\n    arr[4] = cvt(arr[1].length > 1 ? /{[\\S\\s]*?}/ : /{[^}]*}/, arr)\n    arr[5] = cvt(/\\\\({|})/g, arr)\n    arr[6] = cvt(/(\\\\?)({)/g, arr)\n    arr[7] = RegExp('(\\\\\\\\?)(?:([[({])|(' + arr[3] + '))|' + S_QBSRC, REGLOB)\n    arr[8] = pair\n    return arr\n  }\n\n  function _reset(pair) {\n    if (!pair) pair = DEFAULT\n\n    if (pair !== _pairs[8]) {\n      _pairs = _create(pair)\n      _regex = pair === DEFAULT ? _loopback : _rewrite\n      _pairs[9] = _regex(/^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/)\n      _pairs[10] = _regex(/(^|[^\\\\]){=[\\S\\s]*?}/)\n      _brackets._rawOffset = _pairs[0].length\n    }\n    cachedBrackets = pair\n  }\n\n  function _brackets(reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _pairs[reOrIdx]\n  }\n\n  _brackets.split = function split(str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) _bp = _pairs\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6]\n\n    isexpr = start = re.lastIndex = 0\n\n    while (match = re.exec(str)) {\n\n      pos = match.index\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(match[2], re.lastIndex)\n          continue\n        }\n\n        if (!match[3])\n          continue\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos))\n        start = re.lastIndex\n        re = _bp[6 + (isexpr ^= 1)]\n        re.lastIndex = start\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start))\n    }\n\n    return parts\n\n    function unescapeStr(str) {\n      if (tmpl || isexpr)\n        parts.push(str && str.replace(_bp[5], '$1'))\n      else\n        parts.push(str)\n    }\n\n    function skipBraces(ch, pos) {\n      var\n        match,\n        recch = FINDBRACES[ch],\n        level = 1\n      recch.lastIndex = pos\n\n      while (match = recch.exec(str)) {\n        if (match[1] &&\n          !(match[1] === ch ? ++level : --level)) break\n      }\n      return match ? recch.lastIndex : str.length\n    }\n  }\n\n  _brackets.hasExpr = function hasExpr(str) {\n    return _brackets(4).test(str)\n  }\n\n  _brackets.loopKeys = function loopKeys(expr) {\n    var m = expr.match(_brackets(9))\n    return m ?\n      { key: m[1], pos: m[2], val: _pairs[0] + m[3].trim() + _pairs[1] } : { val: expr.trim() }\n  }\n\n  _brackets.array = function array(pair) {\n    return _create(pair || cachedBrackets)\n  }\n\n  var _settings\n  function _setSettings(o) {\n    var b\n    o = o || {}\n    b = o.brackets\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    })\n    _settings = o\n    _reset(b)\n  }\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  })\n\n  /* istanbul ignore next: in the node version riot is not in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}\n  _brackets.set = _reset\n\n  _brackets.R_STRINGS = STRINGS\n  _brackets.R_MLCOMMS = MLCOMMS\n  _brackets.S_QBLOCKS = S_QBSRC\n\n  return _brackets\n\n})()\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\nvar tmpl = (function () {\n\n  var _cache = {}\n\n  function _tmpl(str, data) {\n    if (!str) return str\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.isRaw = function (expr) {\n    return expr[brackets._rawOffset] === \"=\"\n  }\n\n  _tmpl.haveRaw = function (src) {\n    return brackets(10).test(src)\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr\n\n  _tmpl.loopKeys = brackets.loopKeys\n\n  _tmpl.errorHandler = null\n\n  function _logErr(err, ctx) {\n\n    if (_tmpl.errorHandler) {\n\n      err.riotData = {\n        tagName: ctx && ctx.root && ctx.root.tagName,\n        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n      }\n      _tmpl.errorHandler(err)\n    }\n  }\n\n  function _create(str) {\n\n    var expr = _getTmpl(str)\n    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr\n\n    return new Function('E', expr + ';')\n  }\n\n  var\n    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_QBMARK = /\\x01(\\d+)~/g\n\n  function _getTmpl(str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str.replace(/\\u2057/g, '\"'), 1)\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = []\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i]\n\n        if (expr && (expr = i & 1 ?\n\n              _parseExpr(expr, 1, qstr) :\n\n              '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) list[j++] = expr\n\n      }\n\n      expr = j < 2 ? list[0] :\n             '[' + list.join(',') + '].join(\"\")'\n    }\n    else {\n\n      expr = _parseExpr(parts[1], 0, qstr)\n    }\n\n    if (qstr[0])\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      })\n\n    return expr\n  }\n\n  var\n    CS_IDENT = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\x01(\\d+)~):/,\n    RE_BRACE = /,|([[{(])|$/g\n\n  function _parseExpr(expr, asText, qstr) {\n\n    if (expr[0] === \"=\") expr = expr.slice(1)\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? '\\x01' + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1')\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match\n\n      while (expr &&\n            (match = expr.match(CS_IDENT)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g\n\n        expr = RegExp.rightContext\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1]\n\n        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)\n\n        jsb  = expr.slice(0, match.index)\n        expr = RegExp.rightContext\n\n        list[cnt++] = _wrapExpr(jsb, 1, key)\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText) :\n          cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0]\n    }\n    return expr\n\n    function skipBraces(jsb, re) {\n      var\n        match,\n        lv = 1,\n        ir = jsb === '(' ? /[()]/g : jsb === '[' ? /[[\\]]/g : /[{}]/g\n\n      ir.lastIndex = re.lastIndex\n      while (match = ir.exec(expr)) {\n        if (match[0] === jsb) ++lv\n        else if (!--lv) break\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex\n    }\n  }\n\n  // istanbul ignore next: not both\n  var JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').'\n  var JS_VARNAME = /[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g\n\n  function _wrapExpr(expr, asText, key) {\n    var tb\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar\n          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['\n        }\n        else if (pos)\n          tb = !/^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/.test(s.slice(pos))\n      }\n      return match\n    })\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}'\n    }\n\n    if (key) {\n\n      expr = (tb ?\n          'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"'\n    }\n    else if (asText) {\n\n      expr = 'function(v){' + (tb ?\n          expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)'\n    }\n\n    return expr\n  }\n\n  // istanbul ignore next: compatibility fix for beta versions\n  _tmpl.parse = function (s) { return s }\n\n  return _tmpl\n\n})()\n\n  tmpl.version = brackets.version = 'v2.3.19'\n\n\n/*\n  lib/browser/tag/mkdom.js\n\n  Includes hacks needed for the Internet Explorer version 9 and bellow\n\n*/\n// http://kangax.github.io/compat-table/es5/#ie8\n// http://codeplanet.io/dropping-ie8/\n\nvar mkdom = (function (checkIE) {\n\n  var rootEls = {\n      'tr': 'tbody',\n      'th': 'tr',\n      'td': 'tr',\n      'tbody': 'table',\n      'col': 'colgroup'\n    },\n    GENERIC = 'div'\n\n  checkIE = checkIE && checkIE < 10\n\n  // creates any dom element in a div, table, or colgroup container\n  function _mkdom(html) {\n\n    var match = html && html.match(/^\\s*<([-\\w]+)/),\n      tagName = match && match[1].toLowerCase(),\n      rootTag = rootEls[tagName] || GENERIC,\n      el = mkEl(rootTag)\n\n    el.stub = true\n\n    /* istanbul ignore next */\n    if (checkIE && tagName && (match = tagName.match(SPECIAL_TAGS_REGEX)))\n      ie9elem(el, html, tagName, !!match[1])\n    else\n      el.innerHTML = html\n\n    return el\n  }\n\n  // creates tr, th, td, option, optgroup element for IE8-9\n  /* istanbul ignore next */\n  function ie9elem(el, html, tagName, select) {\n\n    var div = mkEl(GENERIC),\n      tag = select ? 'select>' : 'table>',\n      child\n\n    div.innerHTML = '<' + tag + html + '</' + tag\n\n    child = $(tagName, div)\n    if (child)\n      el.appendChild(child)\n\n  }\n  // end ie9elem()\n\n  return _mkdom\n\n})(IE_VERSION)\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n\n  var i = tags.length,\n    j = items.length\n\n  while (i > j) {\n    var t = tags[--i]\n    tags.splice(i, 1)\n    t.unmount()\n  }\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @param   { Object } child - non custom loop tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(child, i) {\n  Object.keys(child.tags).forEach(function(tagName) {\n    var tag = child.tags[tagName]\n    if (isArray(tag))\n      each(tag, function (t) {\n        moveChildTag(t, tagName, i)\n      })\n    else\n      moveChildTag(tag, tagName, i)\n  })\n}\n\n/**\n * Adds the elements for a virtual tag\n * @param { Tag } tag - the tag whose root's children will be inserted or appended\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction addVirtual(tag, src, target) {\n  var el = tag._root\n  tag._virts = []\n  while (el) {\n    var sib = el.nextSibling\n    if (target)\n      src.insertBefore(el, target._root)\n    else\n      src.appendChild(el)\n\n    tag._virts.push(el) // hold for unmounting\n    el = sib\n  }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @param { Tag } tag - first child reference used to start move\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n * @param { Number } len - how many child nodes to move\n */\nfunction moveVirtual(tag, src, target, len) {\n  var el = tag._root\n  for (var i = 0; i < len; i++) {\n    var sib = el.nextSibling\n    src.insertBefore(el, target._root)\n    el = sib\n  }\n}\n\n\n/**\n * Manage tags having the 'each'\n * @param   { Object } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, 'each')\n\n  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n    tagName = getTagName(dom),\n    impl = __tagImpl[tagName] || { tmpl: dom.outerHTML },\n    useRoot = SPECIAL_TAGS_REGEX.test(tagName),\n    root = dom.parentNode,\n    ref = document.createTextNode(''),\n    child = getTag(dom),\n    isOption = /option/gi.test(tagName), // the option tags must be treated differently\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isVirtual = dom.tagName == 'VIRTUAL'\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr)\n\n  // insert a marked where the loop tags will be injected\n  root.insertBefore(ref, dom)\n\n  // clean template code\n  parent.one('before-mount', function () {\n\n    // remove the original DOM node\n    dom.parentNode.removeChild(dom)\n    if (root.stub) root = parent.root\n\n  }).on('update', function () {\n    // get the new items collection\n    var items = tmpl(expr.val, parent),\n      // create a fragment to hold the new DOM nodes to inject in the parent tag\n      frag = document.createDocumentFragment()\n\n\n\n    // object loop. any changes cause full redraw\n    if (!isArray(items)) {\n      hasKeys = items || false\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, key, items[key])\n        }) : []\n    }\n\n    // loop all the new items\n    items.forEach(function(item, i) {\n      // reorder only if the items are objects\n      var _mustReorder = mustReorder && item instanceof Object,\n        oldPos = oldItems.indexOf(item),\n        pos = ~oldPos && _mustReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos]\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item\n\n      // new tag\n      if (\n        !_mustReorder && !tag // with no-reorder we just update the old tags\n        ||\n        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements\n      ) {\n\n        tag = new Tag(impl, {\n          parent: parent,\n          isLoop: true,\n          hasImpl: !!__tagImpl[tagName],\n          root: useRoot ? root : dom.cloneNode(),\n          item: item\n        }, dom.innerHTML)\n\n        tag.mount()\n        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts\n        // this tag must be appended\n        if (i == tags.length) {\n          if (isVirtual)\n            addVirtual(tag, frag)\n          else frag.appendChild(tag.root)\n        }\n        // this tag must be insert\n        else {\n          if (isVirtual)\n            addVirtual(tag, root, tags[i])\n          else root.insertBefore(tag.root, tags[i].root)\n          oldItems.splice(i, 0, item)\n        }\n\n        tags.splice(i, 0, tag)\n        pos = i // handled here so no move\n      } else tag.update(item)\n\n      // reorder the tag if it's not located in its previous position\n      if (pos !== i && _mustReorder) {\n        // update the DOM\n        if (isVirtual)\n          moveVirtual(tag, root, tags[i], dom.childNodes.length)\n        else root.insertBefore(tag.root, tags[i].root)\n        // update the position attribute if it exists\n        if (expr.pos)\n          tag[expr.pos] = i\n        // move the old tag instance\n        tags.splice(i, 0, tags.splice(pos, 1)[0])\n        // move the old item\n        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child) moveNestedTags(tag, i)\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag._item = item\n      // cache the real parent tag internally\n      defineProperty(tag, '_parent', parent)\n\n    }, true) // allow null values\n\n    // remove the redundant tags\n    unmountRedundant(items, tags)\n\n    // insert the new nodes\n    if (isOption) root.appendChild(frag)\n    else root.insertBefore(frag, ref)\n\n    // set the 'tags' property of the parent tag\n    // if child is 'undefined' it means that we don't need to set this property\n    // for example:\n    // we don't need store the `myTag.tags['div']` property if we are looping a div tag\n    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`\n    if (child) parent.tags[tagName] = tags\n\n    // clone the items array\n    oldItems = items.slice()\n\n  })\n\n}\n\n\nfunction parseNamedElements(root, tag, childTags, forceParsingNamed) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = dom.isLoop || (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each')) ? 1 : 0\n\n      // custom child tag\n      if (childTags) {\n        var child = getTag(dom)\n\n        if (child && !dom.isLoop)\n          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))\n      }\n\n      if (!dom.isLoop || forceParsingNamed)\n        setNamed(dom, tag, [])\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (tmpl.hasExpr(val)) {\n      var expr = { dom: dom, expr: val }\n      expressions.push(extend(expr, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    var attr = getAttr(dom, 'each')\n\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n    opts = inherit(conf.opts) || {},\n    dom = mkdom(impl.tmpl),\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    hasImpl = conf.hasImpl,\n    item = cleanUpData(conf.item),\n    expressions = [],\n    childTags = [],\n    root = conf.root,\n    fn = impl.fn,\n    tagName = root.tagName.toLowerCase(),\n    attr = {},\n    propsInSyncWithParent = []\n\n  if (fn && root._tag) root._tag.unmount(true)\n\n  // not yet mounted\n  this.isMounted = false\n  root.isLoop = isLoop\n\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id\n\n  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    var val = el.value\n    // remember attributes with expressions only\n    if (tmpl.hasExpr(val)) attr[el.name] = val\n  })\n\n  if (dom.innerHTML && !/^(select|optgroup|table|tbody|tr|col(?:group)?)$/.test(tagName))\n    // replace all the yield tags with the tag inner html\n    dom.innerHTML = replaceYield(dom.innerHTML, innerHTML)\n\n  // options\n  function updateOpts() {\n    var ctx = hasImpl && isLoop ? self : parent || self\n\n    // update opts from current DOM attributes\n    each(root.attributes, function(el) {\n      opts[toCamel(el.name)] = tmpl(el.value, ctx)\n    })\n    // recover those with expressions\n    each(Object.keys(attr), function(name) {\n      opts[toCamel(name)] = tmpl(attr[name], ctx)\n    })\n  }\n\n  function normalizeData(data) {\n    for (var key in item) {\n      if (typeof self[key] !== T_UNDEF && isWritable(self, key))\n        self[key] = data[key]\n    }\n  }\n\n  function inheritFromParent () {\n    if (!self.parent || !isLoop) return\n    each(Object.keys(self.parent), function(k) {\n      // some properties must be always in sync with the parent tag\n      var mustSync = !contains(RESERVED_WORDS_BLACKLIST, k) && contains(propsInSyncWithParent, k)\n      if (typeof self[k] === T_UNDEF || mustSync) {\n        // track the property to keep in sync\n        // so we can keep it updated\n        if (!mustSync) propsInSyncWithParent.push(k)\n        self[k] = self.parent[k]\n      }\n    })\n  }\n\n  defineProperty(this, 'update', function(data) {\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data)\n    // inherit properties from the parent\n    inheritFromParent()\n    // normalize the tag properties in case an item object was initially passed\n    if (data && typeof item === T_OBJECT) {\n      normalizeData(data)\n      item = data\n    }\n    extend(self, data)\n    updateOpts()\n    self.trigger('update', data)\n    update(expressions, self)\n    // the updated event will be triggered\n    // once the DOM will be ready and all the reflow are completed\n    // this is useful if you want to get the \"real\" root properties\n    // 4 ex: root.offsetWidth ...\n    rAF(function() { self.trigger('updated') })\n    return this\n  })\n\n  defineProperty(this, 'mixin', function() {\n    each(arguments, function(mix) {\n      var instance\n\n      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix()\n        // save the prototype to loop it afterwards\n        mix = mix.prototype\n      } else instance = mix\n\n      // loop the keys in the function prototype or the all object keys\n      each(Object.getOwnPropertyNames(mix), function(key) {\n        // bind methods to self\n        if (key != 'init')\n          self[key] = isFunction(instance[key]) ?\n                        instance[key].bind(self) :\n                        instance[key]\n      })\n\n      // init method will be called automatically\n      if (instance.init) instance.init.bind(self)()\n    })\n    return this\n  })\n\n  defineProperty(this, 'mount', function() {\n\n    updateOpts()\n\n    // initialiation\n    if (fn) fn.call(self, opts)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    // mount the child tags\n    toggle(true)\n\n    // update the root adding custom attributes coming from the compiler\n    // it fixes also #1087\n    if (impl.attrs || hasImpl) {\n      walkAttributes(impl.attrs, function (k, v) { setAttr(root, k, v) })\n      parseExpressions(self.root, self, expressions)\n    }\n\n    if (!self.parent || isLoop) self.update(item)\n\n    // internal use only, fixes #403\n    self.trigger('before-mount')\n\n    if (isLoop && !hasImpl) {\n      // update the root attribute for the looped elements\n      self.root = root = dom.firstChild\n\n    } else {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n      if (root.stub) self.root = root = parent.root\n    }\n\n    // parse the named dom nodes in the looped child\n    // adding them to the parent as well\n    if (isLoop)\n      parseNamedElements(self.root, self.parent, null, true)\n\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent || self.parent.isMounted) {\n      self.isMounted = true\n      self.trigger('mount')\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() {\n      // avoid to trigger the `mount` event for the tags\n      // not visible included in an if statement\n      if (!isInStub(self.root)) {\n        self.parent.isMounted = self.isMounted = true\n        self.trigger('mount')\n      }\n    })\n  })\n\n\n  defineProperty(this, 'unmount', function(keepRootTag) {\n    var el = root,\n      p = el.parentNode,\n      ptag\n\n    self.trigger('before-unmount')\n\n    // remove this tag instance from the global virtualDom variable\n    __virtualDom.splice(__virtualDom.indexOf(self), 1)\n\n    if (this._virts) {\n      each(this._virts, function(v) {\n        v.parentNode.removeChild(v)\n      })\n    }\n\n    if (p) {\n\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent)\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (isArray(ptag.tags[tagName]))\n          each(ptag.tags[tagName], function(tag, i) {\n            if (tag._riot_id == self._riot_id)\n              ptag.tags[tagName].splice(i, 1)\n          })\n        else\n          // otherwise just delete the tag instance\n          ptag.tags[tagName] = undefined\n      }\n\n      else\n        while (el.firstChild) el.removeChild(el.firstChild)\n\n      if (!keepRootTag)\n        p.removeChild(el)\n      else\n        // the riot-tag attribute isn't needed anymore, remove it\n        remAttr(p, 'riot-tag')\n    }\n\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    self.isMounted = false\n    // somehow ie8 does not like `delete root._tag`\n    root._tag = null\n\n  })\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (parent) {\n      var evt = isMount ? 'on' : 'off'\n\n      // the loop tags will be always in sync with the parent automatically\n      if (isLoop)\n        parent[evt]('unmount', self.unmount)\n      else\n        parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n    }\n  }\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n}\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n\n  dom[name] = function(e) {\n\n    var ptag = tag._parent,\n      item = tag._item,\n      el\n\n    if (!item)\n      while (ptag && !item) {\n        item = ptag._item\n        ptag = ptag._parent\n      }\n\n    // cross browser event fix\n    e = e || window.event\n\n    // override the event properties\n    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n    if (isWritable(e, 'target')) e.target = e.srcElement\n    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      if (e.preventDefault) e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      el = item ? getImmediateCustomParentTag(ptag) : tag\n      el.update()\n    }\n\n  }\n\n}\n\n\n/**\n * Insert a DOM node replacing another one (used by if- attribute)\n * @param   { Object } root - parent node\n * @param   { Object } node - node replaced\n * @param   { Object } before - node added\n */\nfunction insertTo(root, node, before) {\n  if (root) {\n    root.insertBefore(before, node)\n    root.removeChild(node)\n  }\n}\n\n/**\n * Update the expressions in a Tag instance\n * @param   { Array } expressions - expression that must be re evaluated\n * @param   { Tag } tag - tag instance\n */\nfunction update(expressions, tag) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n      attrName = expr.attr,\n      value = tmpl(expr.expr, tag),\n      parent = expr.dom.parentNode\n\n    if (expr.bool)\n      value = value ? attrName : false\n    else if (value == null)\n      value = ''\n\n    // leave out riot- prefixes from strings inside textarea\n    // fix #815: any value -> string\n    if (parent && parent.tagName == 'TEXTAREA') {\n      value = ('' + value).replace(/riot-/g, '')\n      // change textarea's value\n      parent.value = value\n    }\n\n    // no change\n    if (expr.value === value) return\n    expr.value = value\n\n    // text node\n    if (!attrName) {\n      dom.nodeValue = '' + value    // #815 related\n      return\n    }\n\n    // remove original attribute\n    remAttr(dom, attrName)\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, tag)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub,\n        add = function() { insertTo(stub.parentNode, stub, dom) },\n        remove = function() { insertTo(dom.parentNode, dom, stub) }\n\n      // add to DOM\n      if (value) {\n        if (stub) {\n          add()\n          dom.inStub = false\n          // avoid to trigger the mount event if the tags is not visible yet\n          // maybe we can optimize this avoiding to mount the tag at all\n          if (!isInStub(dom)) {\n            walk(dom, function(el) {\n              if (el._tag && !el._tag.isMounted) el._tag.isMounted = !!el._tag.trigger('mount')\n            })\n          }\n        }\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        // if the parentNode is defined we can easily replace the tag\n        if (dom.parentNode)\n          remove()\n        // otherwise we need to wait the updated event\n        else (tag.parent || tag).one('updated', remove)\n\n        dom.inStub = true\n      }\n    // show / hide\n    } else if (/^(show|hide)$/.test(attrName)) {\n      if (attrName == 'hide') value = !value\n      dom.style.display = value ? '' : 'none'\n\n    // field value\n    } else if (attrName == 'value') {\n      dom.value = value\n\n    // <img src=\"{ expr }\">\n    } else if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n      if (value)\n        setAttr(dom, attrName.slice(RIOT_PREFIX.length), value)\n\n    } else {\n      if (expr.bool) {\n        dom[attrName] = value\n        if (!value) return\n      }\n\n      if (value && value != 0 && typeof value !== T_OBJECT)\n        setAttr(dom, attrName, value)\n\n    }\n\n  })\n\n}\n/**\n * Loops an array\n * @param   { Array } els - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(els, fn) {\n  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n    el = els[i]\n    // return false -> remove current item during loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\n/**\n * Detect if the argument passed is a function\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isFunction(v) {\n  return typeof v === T_FUNCTION || false   // avoid IE problems\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } string - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(string) {\n  return string.replace(/-(\\w)/g, function(_, c) {\n    return c.toUpperCase()\n  })\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  dom.setAttribute(name, val)\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]\n}\n/**\n * Add a child tag to its parent into the `tags` object\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the new tag will be stored\n * @param   { Object } parent - tag instance where the new child tag will be included\n */\nfunction addChildTag(tag, tagName, parent) {\n  var cachedTag = parent.tags[tagName]\n\n  // if there are multiple children tags having the same name\n  if (cachedTag) {\n    // if the parent tags property is not yet an array\n    // create it adding the first cached tag\n    if (!isArray(cachedTag))\n      // don't add the same tag twice\n      if (cachedTag !== tag)\n        parent.tags[tagName] = [cachedTag]\n    // add the new nested tag to the array\n    if (!contains(parent.tags[tagName], tag))\n      parent.tags[tagName].push(tag)\n  } else {\n    parent.tags[tagName] = tag\n  }\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tag, tagName, newPos) {\n  var parent = tag.parent,\n    tags\n  // no parent no move\n  if (!parent) return\n\n  tags = parent.tags[tagName]\n\n  if (isArray(tags))\n    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])\n  else addChildTag(tag, tagName, parent)\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag(child, opts, innerHTML),\n    tagName = getTagName(opts.root),\n    ptag = getImmediateCustomParentTag(parent)\n  // fix for the parent attribute in the looped elements\n  tag.parent = ptag\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag._parent = parent\n\n  // add this tag to the custom parent tag\n  addChildTag(tag, tagName, ptag)\n  // and also to the real parent tag\n  if (ptag !== parent)\n    addChildTag(tag, tagName, parent)\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = ''\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag\n  while (!getTag(ptag.root)) {\n    if (!ptag.parent) break\n    ptag = ptag.parent\n  }\n  return ptag\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n* @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: false\n  }, options))\n  return el\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom) {\n  var child = getTag(dom),\n    namedTag = getAttr(dom, 'name'),\n    tagName = namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n\n  return tagName\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          src[key] = obj[key]\n      }\n    }\n  }\n  return src\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } arr - target array\n * @param   { * } item - item to test\n * @returns { Boolean } Does 'arr' contain 'item'?\n */\nfunction contains(arr, item) {\n  return ~arr.indexOf(item)\n}\n\n/**\n * Check whether an object is a kind of array\n * @param   { * } a - anything\n * @returns {Boolean} is 'a' an array?\n */\nfunction isArray(a) { return Array.isArray(a) || a instanceof Array }\n\n/**\n * Detect whether a property of an object could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } is this property writable?\n */\nfunction isWritable(obj, key) {\n  var props = Object.getOwnPropertyDescriptor(obj, key)\n  return typeof obj[key] === T_UNDEF || props && props.writable\n}\n\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION)) return data\n\n  var o = {}\n  for (var key in data) {\n    if (!contains(RESERVED_WORDS_BLACKLIST, key))\n      o[key] = data[key]\n  }\n  return o\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n */\nfunction walk(dom, fn) {\n  if (dom) {\n    // stop the recursion\n    if (fn(dom) === false) return\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttributes(html, fn) {\n  var m,\n    re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\n  while (m = re.exec(html)) {\n    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n  }\n}\n\n/**\n * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n * @param   { Object }  dom - DOM node we want to parse\n * @returns { Boolean } -\n */\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub) return true\n    dom = dom.parentNode\n  }\n  return false\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name) {\n  return document.createElement(name)\n}\n\n/**\n * Create a generic DOM node, and fill it with innerHTML\n * @param   { String } name - name of the DOM node we want to create\n * @param   { String } innerHTML - innerHTML of the new DOM\n * @returns { Object } DOM node just created\n */\nfunction mkElWithInnerHTML(name, innerHTML) {\n  var el = mkEl(name)\n  el.innerHTML = innerHTML || ''\n  return el\n}\n\n/**\n * Replace the yield tag from any tag template with the innerHTML of the\n * original tag in the page\n * @param   { String } tmpl - tag implementation template\n * @param   { String } innerHTML - original content of the tag in the DOM\n * @returns { String } tag template updated without the yield tag\n */\nfunction replaceYield(tmpl, innerHTML) {\n  var tmplElement = mkElWithInnerHTML('div', tmpl)\n  // if ($('yield[from]'.tmplElement)) { // this issues test errors\n  if (tmplElement.querySelector && tmplElement.querySelector('yield[from]')) { // code coverage path not taken (?)\n    // yield to(s) must be direct children from innerHTML(root), all other tags are ignored\n    each(mkElWithInnerHTML('div', innerHTML).childNodes, function(toYield) {\n      if (toYield.nodeType == 1 && toYield.tagName == 'YIELD' && toYield.getAttribute('to')) {\n        // replace all yield[from]\n        each($$('yield[from=\"'+toYield.getAttribute('to')+'\"]', tmplElement), function(fromYield) {\n          fromYield.outerHTML = toYield.innerHTML\n        })\n      }\n    })\n    return tmplElement.innerHTML\n  } else\n    // just replace yield in tmpl with the innerHTML\n    return tmpl.replace(/<yield\\s*(?:\\/>|>\\s*<\\/yield\\s*>)/gi, innerHTML || '')\n}\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Simple object prototypal inheritance\n * @param   { Object } parent - parent object\n * @returns { Object } child instance\n */\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n\n/**\n * Get the name property needed to identify a DOM node in riot\n * @param   { Object } dom - DOM node we need to parse\n * @returns { String | undefined } give us back a string to identify this dom node\n */\nfunction getNamedKey(dom) {\n  return getAttr(dom, 'id') || getAttr(dom, 'name')\n}\n\n/**\n * Set the named properties of a tag element\n * @param { Object } dom - DOM node we need to parse\n * @param { Object } parent - tag instance where the named dom element will be eventually added\n * @param { Array } keys - list of all the tag instance properties\n */\nfunction setNamed(dom, parent, keys) {\n  // get the key value we want to add to the tag instance\n  var key = getNamedKey(dom),\n    // add the node detected to a tag instance using the named property\n    add = function(value) {\n      // avoid to override the tag properties already set\n      if (contains(keys, key)) return\n      // check whether this value is an array\n      var isArr = isArray(value)\n      // if the key was never set\n      if (!value)\n        // set it once on the tag instance\n        parent[key] = dom\n      // if it was an array and not yet set\n      else if (!isArr || isArr && !contains(value, dom)) {\n        // add the dom node into the array\n        if (isArr)\n          value.push(dom)\n        else\n          parent[key] = [value, dom]\n      }\n    }\n\n  // skip the elements with no named properties\n  if (!key) return\n\n  // check whether this key has been already evaluated\n  if (tmpl.hasExpr(key))\n    // wait the first updated event only once\n    parent.one('updated', function() {\n      key = getNamedKey(dom)\n      add(parent[key])\n    })\n  else\n    add(parent[key])\n\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } src - source string\n * @param   { String } str - test string\n * @returns { Boolean } -\n */\nfunction startsWith(src, str) {\n  return src.slice(0, str.length) === str\n}\n\n/**\n * Function needed to inject in runtime the custom tags css\n */\nvar injectStyle = (function() {\n\n  if (!window) return // skip injection on the server\n\n  // create the style node\n  var styleNode = mkEl('style'),\n    placeholder = $('style[type=riot]')\n\n  setAttr(styleNode, 'type', 'text/css')\n\n  // inject the new node into the DOM -- in head\n  if (placeholder) {\n    placeholder.parentNode.replaceChild(styleNode, placeholder)\n    placeholder = null\n  }\n  else document.getElementsByTagName('head')[0].appendChild(styleNode)\n\n  /**\n   * This is the function exported that will be used to update the style tag just created\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @param   { String } css [description]\n   */\n  return styleNode.styleSheet ?\n    function (css) { styleNode.styleSheet.cssText += css } :\n    function (css) { styleNode.innerHTML += css }\n\n})()\n\n/**\n * requestAnimationFrame polyfill\n */\nvar rAF = (function(w) {\n  return  w.requestAnimationFrame       ||\n          w.webkitRequestAnimationFrame ||\n          w.mozRequestAnimationFrame    ||\n          function(cb) { setTimeout(cb, 1000 / 60) }\n})(window || {})\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts) {\n  var tag = __tagImpl[tagName],\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    // add this tag to the virtualDom variable\n    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)\n  }\n\n  return tag\n}\n/**\n * Riot public api\n */\n\n// share methods for other riot parts, e.g. compiler\nriot.util = { brackets: brackets, tmpl: tmpl }\n\n/**\n * Create a mixin that could be globally shared across all the tags\n */\nriot.mixin = (function() {\n  var mixins = {}\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String } name - mixin name\n   * @param   { Object } mixin - mixin logic\n   * @returns { Object } the mixin logic\n   */\n  return function(name, mixin) {\n    if (!mixin) return mixins[name]\n    mixins[name] = mixin\n  }\n\n})()\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nriot.tag = function(name, html, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css\n      css = ''\n    } else attrs = ''\n  }\n  if (css) {\n    if (isFunction(css)) fn = css\n    else if (injectStyle) injectStyle(css)\n  }\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @param   { string }  [bpair] - brackets used in the compilation\n * @returns { String } name/id of the tag just created\n */\nriot.tag2 = function(name, html, css, attrs, fn, bpair) {\n  if (css && injectStyle) injectStyle(css)\n  //if (bpair) riot.settings.brackets = bpair\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { String } selector - tag DOM selector\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nriot.mount = function(selector, tagName, opts) {\n\n  var els,\n    allTags,\n    tags = []\n\n  // helper functions\n\n  function addRiotTags(arr) {\n    var list = ''\n    each(arr, function (e) {\n      list += ', *[' + RIOT_TAG + '=\"' + e.trim() + '\"]'\n    })\n    return list\n  }\n\n  function selectAllTags() {\n    var keys = Object.keys(__tagImpl)\n    return keys + addRiotTags(keys)\n  }\n\n  function pushTags(root) {\n    var last\n\n    if (root.tagName) {\n      if (tagName && (!(last = getAttr(root, RIOT_TAG)) || last != tagName))\n        setAttr(root, RIOT_TAG, tagName)\n\n      var tag = mountTo(root, tagName || root.getAttribute(RIOT_TAG) || root.tagName.toLowerCase(), opts)\n\n      if (tag) tags.push(tag)\n    } else if (root.length)\n      each(root, pushTags)   // assume nodeList\n\n  }\n\n  // ----- mount code -----\n\n  if (typeof tagName === T_OBJECT) {\n    opts = tagName\n    tagName = 0\n  }\n\n  // crawl the DOM to find the tag\n  if (typeof selector === T_STRING) {\n    if (selector === '*')\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selectAllTags()\n    else\n      // or just the ones named like the selector\n      selector += addRiotTags(selector.split(','))\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    els = selector ? $$(selector) : []\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    els = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectAllTags()\n    // if the root els it's just a single tag\n    if (els.tagName)\n      els = $$(tagName, els)\n    else {\n      // select all the children for all the different root elements\n      var nodeList = []\n      each(els, function (_el) {\n        nodeList.push($$(tagName, _el))\n      })\n      els = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  if (els.tagName)\n    pushTags(els)\n  else\n    each(els, pushTags)\n\n  return tags\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nriot.update = function() {\n  return each(__virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n/**\n * Export the Tag constructor\n */\nriot.Tag = Tag\n  // support CommonJS, AMD & browser\n  /* istanbul ignore next */\n  if (typeof exports === T_OBJECT)\n    module.exports = riot\n  else if (typeof define === T_FUNCTION && typeof define.amd !== T_UNDEF)\n    define(function() { return (window.riot = riot) })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : void 0);\n","source":"unrest/bower_components/riot/riot.js","raw":"/* Riot v2.3.12, @license MIT, (c) 2015 Muut Inc. + contributors */\n\n;(function(window, undefined) {\n  'use strict';\nvar riot = { version: 'v2.3.12', settings: {} },\n  // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n\n  // counter to give a unique id to all the Tag instances\n  __uid = 0,\n  // tags instances cache\n  __virtualDom = [],\n  // tags implementation cache\n  __tagImpl = {},\n\n  /**\n   * Const\n   */\n  // riot specific prefixes\n  RIOT_PREFIX = 'riot-',\n  RIOT_TAG = RIOT_PREFIX + 'tag',\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n  T_OBJECT = 'object',\n  T_UNDEF  = 'undefined',\n  T_FUNCTION = 'function',\n  // special native tags that cannot be treated like the others\n  SPECIAL_TAGS_REGEX = /^(?:opt(ion|group)|tbody|col|t[rhd])$/,\n  RESERVED_WORDS_BLACKLIST = ['_item', '_id', '_parent', 'update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isLoop', 'tags', 'parent', 'opts', 'trigger', 'on', 'off', 'one'],\n\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (window && window.document || {}).documentMode | 0\n/* istanbul ignore next */\nriot.observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {}\n\n  /**\n   * Private variables and methods\n   */\n\n  var callbacks = {},\n    onEachEvent = function(e, fn) { e.replace(/\\S+/g, fn) },\n    defineProperty = function (key, value) {\n      Object.defineProperty(el, key, {\n        value: value,\n        enumerable: false,\n        writable: false,\n        configurable: false\n      })\n    }\n\n  /**\n   * Listen to the given space separated list of `events` and execute the `callback` each time an event is triggered.\n   * @param  { String } events - events ids\n   * @param  { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('on', function(events, fn) {\n    if (typeof fn != 'function')  return el\n\n    onEachEvent(events, function(name, pos) {\n      (callbacks[name] = callbacks[name] || []).push(fn)\n      fn.typed = pos > 0\n    })\n\n    return el\n  })\n\n  /**\n   * Removes the given space separated list of `events` listeners\n   * @param   { String } events - events ids\n   * @param   { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('off', function(events, fn) {\n    if (events == '*') callbacks = {}\n    else {\n      onEachEvent(events, function(name) {\n        if (fn) {\n          var arr = callbacks[name]\n          for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n            if (cb == fn) arr.splice(i--, 1)\n          }\n        } else delete callbacks[name]\n      })\n    }\n    return el\n  })\n\n  /**\n   * Listen to the given space separated list of `events` and execute the `callback` at most once\n   * @param   { String } events - events ids\n   * @param   { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('one', function(events, fn) {\n    function on() {\n      el.off(events, on)\n      fn.apply(el, arguments)\n    }\n    return el.on(events, on)\n  })\n\n  /**\n   * Execute all callback functions that listen to the given space separated list of `events`\n   * @param   { String } events - events ids\n   * @returns { Object } el\n   */\n\n  defineProperty('trigger', function(events) {\n\n    // getting the arguments\n    // skipping the first one\n    var arglen = arguments.length - 1,\n      args = new Array(arglen)\n    for (var i = 0; i < arglen; i++) {\n      args[i] = arguments[i + 1]\n    }\n\n    onEachEvent(events, function(name) {\n\n      var fns = (callbacks[name] || []).slice(0)\n\n      for (var i = 0, fn; fn = fns[i]; ++i) {\n        if (fn.busy) return\n        fn.busy = 1\n\n        try {\n          fn.apply(el, fn.typed ? [name].concat(args) : args)\n        } catch (e) { el.trigger('error', e) }\n        if (fns[i] !== fn) { i-- }\n        fn.busy = 0\n      }\n\n      if (callbacks.all && name != 'all')\n        el.trigger.apply(el, ['all', name].concat(args))\n\n    })\n\n    return el\n  })\n\n  return el\n\n}\n/* istanbul ignore next */\n;(function(riot) { if (!window) return;\n\n/**\n * Simple client-side router\n * @module riot-route\n */\n\n\nvar RE_ORIGIN = /^.+?\\/+[^\\/]+/,\n  EVENT_LISTENER = 'EventListener',\n  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n  HAS_ATTRIBUTE = 'hasAttribute',\n  REPLACE = 'replace',\n  POPSTATE = 'popstate',\n  HASHCHANGE = 'hashchange',\n  TRIGGER = 'trigger',\n  MAX_EMIT_STACK_LEVEL = 3,\n  win = window,\n  doc = document,\n  loc = win.history.location || win.location, // see html5-history-api\n  prot = Router.prototype, // to minify more\n  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n  started = false,\n  central = riot.observable(),\n  routeFound = false,\n  debouncedEmit,\n  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/)\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var re = new RegExp('^' + filter[REPLACE](/\\*/g, '([^/?#]+?)')[REPLACE](/\\.\\./, '.*') + '$'),\n    args = path.match(re)\n\n  if (args) return args.slice(1)\n}\n\n/**\n * Simple/cheap debounce implementation\n * @param   {function} fn - callback\n * @param   {number} delay - delay in seconds\n * @returns {function} debounced function\n */\nfunction debounce(fn, delay) {\n  var t\n  return function () {\n    clearTimeout(t)\n    t = setTimeout(fn, delay)\n  }\n}\n\n/**\n * Set the window listeners to trigger the routes\n * @param {boolean} autoExec - see route.start\n */\nfunction start(autoExec) {\n  debouncedEmit = debounce(emit, 1)\n  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit)\n  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n  doc[ADD_EVENT_LISTENER](clickEvent, click)\n  if (autoExec) emit(true)\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = []\n  riot.observable(this) // make it observable\n  central.on('stop', this.s.bind(this))\n  central.on('emit', this.e.bind(this))\n}\n\nfunction normalize(path) {\n  return path[REPLACE](/^\\/|\\/$/, '')\n}\n\nfunction isString(str) {\n  return typeof str == 'string'\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href)[REPLACE](RE_ORIGIN, '')\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  return base[0] == '#'\n    ? (href || loc.href).split(base)[1] || ''\n    : getPathFromRoot(href)[REPLACE](base, '')\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel == 0\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return\n\n  emitStackLevel++\n  emitStack.push(function() {\n    var path = getPathFromBase()\n    if (force || path != current) {\n      central[TRIGGER]('emit', path)\n      current = path\n    }\n  })\n  if (isRoot) {\n    while (emitStack.length) {\n      emitStack[0]()\n      emitStack.shift()\n    }\n    emitStackLevel = 0\n  }\n}\n\nfunction click(e) {\n  if (\n    e.which != 1 // not left click\n    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n    || e.defaultPrevented // or default prevented\n  ) return\n\n  var el = e.target\n  while (el && el.nodeName != 'A') el = el.parentNode\n  if (\n    !el || el.nodeName != 'A' // not A tag\n    || el[HAS_ATTRIBUTE]('download') // has download attr\n    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n    || el.target && el.target != '_self' // another window or frame\n    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin\n  ) return\n\n  if (el.href != loc.href) {\n    if (\n      el.href.split('#')[0] == loc.href.split('#')[0] // internal jump\n      || base != '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n    ) return\n  }\n\n  e.preventDefault()\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n * @returns {boolean} - route not found flag\n */\nfunction go(path, title) {\n  title = title || doc.title\n  // browsers ignores the second parameter `title`\n  history.pushState(null, title, base + normalize(path))\n  // so we need to set it manually\n  doc.title = title\n  routeFound = false\n  emit()\n  return routeFound\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n */\nprot.m = function(first, second) {\n  if (isString(first) && (!second || isString(second))) go(first, second)\n  else if (second) this.r(first, second)\n  else this.r('@', first)\n}\n\n/**\n * Stop routing\n */\nprot.s = function() {\n  this.off('*')\n  this.$ = []\n}\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function(path) {\n  this.$.concat('@').some(function(filter) {\n    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))\n    if (typeof args != 'undefined') {\n      this[TRIGGER].apply(null, [filter].concat(args))\n      return routeFound = true // exit from loop\n    }\n  }, this)\n}\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function(filter, action) {\n  if (filter != '@') {\n    filter = '/' + normalize(filter)\n    this.$.push(filter)\n  }\n  this.on(filter, action)\n}\n\nvar mainRouter = new Router()\nvar route = mainRouter.m.bind(mainRouter)\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function() {\n  var newSubRouter = new Router()\n  // stop only this sub-router\n  newSubRouter.m.stop = newSubRouter.s.bind(newSubRouter)\n  // return sub-router's main method\n  return newSubRouter.m.bind(newSubRouter)\n}\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function(arg) {\n  base = arg || '#'\n  current = getPathFromBase() // recalculate current path\n}\n\n/** Exec routing right now **/\nroute.exec = function() {\n  emit(true)\n}\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function(fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER\n    secondParser = DEFAULT_SECOND_PARSER\n  }\n  if (fn) parser = fn\n  if (fn2) secondParser = fn2\n}\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function() {\n  var q = {}\n  loc.href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })\n  return q\n}\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit)\n    win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n    doc[REMOVE_EVENT_LISTENER](clickEvent, click)\n    central[TRIGGER]('stop')\n    started = false\n  }\n}\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    if (document.readyState == 'complete') start(autoExec)\n    // the timeout is needed to solve\n    // a weird safari bug https://github.com/riot/route/issues/33\n    else win[ADD_EVENT_LISTENER]('load', function() {\n      setTimeout(function() { start(autoExec) }, 1)\n    })\n    started = true\n  }\n}\n\n/** Prepare the router **/\nroute.base()\nroute.parser()\n\nriot.route = route\n})(riot)\n/* istanbul ignore next */\n\n/**\n * The riot template engine\n * @version v2.3.19\n */\n\n/**\n * @module brackets\n *\n * `brackets         ` Returns a string or regex based on its parameter\n * `brackets.settings` Mirrors the `riot.settings` object (use brackets.set in new code)\n * `brackets.set     ` Change the current riot brackets\n */\n\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB  = 'g',\n\n    MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n    STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\n    S_QBSRC = STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    DEFAULT = '{ }',\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBSRC, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBSRC, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBSRC, REGLOB)\n    }\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _pairs = []\n\n  function _loopback(re) { return re }\n\n  function _rewrite(re, bp) {\n    if (!bp) bp = _pairs\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create(pair) {\n    var\n      cvt,\n      arr = pair.split(' ')\n\n    if (pair === DEFAULT) {\n      arr[2] = arr[0]\n      arr[3] = arr[1]\n      cvt = _loopback\n    }\n    else {\n      if (arr.length !== 2 || /[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(pair)) {\n        throw new Error('Unsupported brackets \"' + pair + '\"')\n      }\n      arr = arr.concat(pair.replace(/(?=[[\\]()*+?.^$|])/g, '\\\\').split(' '))\n      cvt = _rewrite\n    }\n    arr[4] = cvt(arr[1].length > 1 ? /{[\\S\\s]*?}/ : /{[^}]*}/, arr)\n    arr[5] = cvt(/\\\\({|})/g, arr)\n    arr[6] = cvt(/(\\\\?)({)/g, arr)\n    arr[7] = RegExp('(\\\\\\\\?)(?:([[({])|(' + arr[3] + '))|' + S_QBSRC, REGLOB)\n    arr[8] = pair\n    return arr\n  }\n\n  function _reset(pair) {\n    if (!pair) pair = DEFAULT\n\n    if (pair !== _pairs[8]) {\n      _pairs = _create(pair)\n      _regex = pair === DEFAULT ? _loopback : _rewrite\n      _pairs[9] = _regex(/^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/)\n      _pairs[10] = _regex(/(^|[^\\\\]){=[\\S\\s]*?}/)\n      _brackets._rawOffset = _pairs[0].length\n    }\n    cachedBrackets = pair\n  }\n\n  function _brackets(reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _pairs[reOrIdx]\n  }\n\n  _brackets.split = function split(str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) _bp = _pairs\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6]\n\n    isexpr = start = re.lastIndex = 0\n\n    while (match = re.exec(str)) {\n\n      pos = match.index\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(match[2], re.lastIndex)\n          continue\n        }\n\n        if (!match[3])\n          continue\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos))\n        start = re.lastIndex\n        re = _bp[6 + (isexpr ^= 1)]\n        re.lastIndex = start\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start))\n    }\n\n    return parts\n\n    function unescapeStr(str) {\n      if (tmpl || isexpr)\n        parts.push(str && str.replace(_bp[5], '$1'))\n      else\n        parts.push(str)\n    }\n\n    function skipBraces(ch, pos) {\n      var\n        match,\n        recch = FINDBRACES[ch],\n        level = 1\n      recch.lastIndex = pos\n\n      while (match = recch.exec(str)) {\n        if (match[1] &&\n          !(match[1] === ch ? ++level : --level)) break\n      }\n      return match ? recch.lastIndex : str.length\n    }\n  }\n\n  _brackets.hasExpr = function hasExpr(str) {\n    return _brackets(4).test(str)\n  }\n\n  _brackets.loopKeys = function loopKeys(expr) {\n    var m = expr.match(_brackets(9))\n    return m ?\n      { key: m[1], pos: m[2], val: _pairs[0] + m[3].trim() + _pairs[1] } : { val: expr.trim() }\n  }\n\n  _brackets.array = function array(pair) {\n    return _create(pair || cachedBrackets)\n  }\n\n  var _settings\n  function _setSettings(o) {\n    var b\n    o = o || {}\n    b = o.brackets\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    })\n    _settings = o\n    _reset(b)\n  }\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  })\n\n  /* istanbul ignore next: in the node version riot is not in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}\n  _brackets.set = _reset\n\n  _brackets.R_STRINGS = STRINGS\n  _brackets.R_MLCOMMS = MLCOMMS\n  _brackets.S_QBLOCKS = S_QBSRC\n\n  return _brackets\n\n})()\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\nvar tmpl = (function () {\n\n  var _cache = {}\n\n  function _tmpl(str, data) {\n    if (!str) return str\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.isRaw = function (expr) {\n    return expr[brackets._rawOffset] === \"=\"\n  }\n\n  _tmpl.haveRaw = function (src) {\n    return brackets(10).test(src)\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr\n\n  _tmpl.loopKeys = brackets.loopKeys\n\n  _tmpl.errorHandler = null\n\n  function _logErr(err, ctx) {\n\n    if (_tmpl.errorHandler) {\n\n      err.riotData = {\n        tagName: ctx && ctx.root && ctx.root.tagName,\n        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n      }\n      _tmpl.errorHandler(err)\n    }\n  }\n\n  function _create(str) {\n\n    var expr = _getTmpl(str)\n    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr\n\n    return new Function('E', expr + ';')\n  }\n\n  var\n    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_QBMARK = /\\x01(\\d+)~/g\n\n  function _getTmpl(str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str.replace(/\\u2057/g, '\"'), 1)\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = []\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i]\n\n        if (expr && (expr = i & 1 ?\n\n              _parseExpr(expr, 1, qstr) :\n\n              '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) list[j++] = expr\n\n      }\n\n      expr = j < 2 ? list[0] :\n             '[' + list.join(',') + '].join(\"\")'\n    }\n    else {\n\n      expr = _parseExpr(parts[1], 0, qstr)\n    }\n\n    if (qstr[0])\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      })\n\n    return expr\n  }\n\n  var\n    CS_IDENT = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\x01(\\d+)~):/,\n    RE_BRACE = /,|([[{(])|$/g\n\n  function _parseExpr(expr, asText, qstr) {\n\n    if (expr[0] === \"=\") expr = expr.slice(1)\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? '\\x01' + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1')\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match\n\n      while (expr &&\n            (match = expr.match(CS_IDENT)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g\n\n        expr = RegExp.rightContext\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1]\n\n        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)\n\n        jsb  = expr.slice(0, match.index)\n        expr = RegExp.rightContext\n\n        list[cnt++] = _wrapExpr(jsb, 1, key)\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText) :\n          cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0]\n    }\n    return expr\n\n    function skipBraces(jsb, re) {\n      var\n        match,\n        lv = 1,\n        ir = jsb === '(' ? /[()]/g : jsb === '[' ? /[[\\]]/g : /[{}]/g\n\n      ir.lastIndex = re.lastIndex\n      while (match = ir.exec(expr)) {\n        if (match[0] === jsb) ++lv\n        else if (!--lv) break\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex\n    }\n  }\n\n  // istanbul ignore next: not both\n  var JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').'\n  var JS_VARNAME = /[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g\n\n  function _wrapExpr(expr, asText, key) {\n    var tb\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar\n          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['\n        }\n        else if (pos)\n          tb = !/^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/.test(s.slice(pos))\n      }\n      return match\n    })\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}'\n    }\n\n    if (key) {\n\n      expr = (tb ?\n          'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"'\n    }\n    else if (asText) {\n\n      expr = 'function(v){' + (tb ?\n          expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)'\n    }\n\n    return expr\n  }\n\n  // istanbul ignore next: compatibility fix for beta versions\n  _tmpl.parse = function (s) { return s }\n\n  return _tmpl\n\n})()\n\n  tmpl.version = brackets.version = 'v2.3.19'\n\n\n/*\n  lib/browser/tag/mkdom.js\n\n  Includes hacks needed for the Internet Explorer version 9 and bellow\n\n*/\n// http://kangax.github.io/compat-table/es5/#ie8\n// http://codeplanet.io/dropping-ie8/\n\nvar mkdom = (function (checkIE) {\n\n  var rootEls = {\n      'tr': 'tbody',\n      'th': 'tr',\n      'td': 'tr',\n      'tbody': 'table',\n      'col': 'colgroup'\n    },\n    GENERIC = 'div'\n\n  checkIE = checkIE && checkIE < 10\n\n  // creates any dom element in a div, table, or colgroup container\n  function _mkdom(html) {\n\n    var match = html && html.match(/^\\s*<([-\\w]+)/),\n      tagName = match && match[1].toLowerCase(),\n      rootTag = rootEls[tagName] || GENERIC,\n      el = mkEl(rootTag)\n\n    el.stub = true\n\n    /* istanbul ignore next */\n    if (checkIE && tagName && (match = tagName.match(SPECIAL_TAGS_REGEX)))\n      ie9elem(el, html, tagName, !!match[1])\n    else\n      el.innerHTML = html\n\n    return el\n  }\n\n  // creates tr, th, td, option, optgroup element for IE8-9\n  /* istanbul ignore next */\n  function ie9elem(el, html, tagName, select) {\n\n    var div = mkEl(GENERIC),\n      tag = select ? 'select>' : 'table>',\n      child\n\n    div.innerHTML = '<' + tag + html + '</' + tag\n\n    child = $(tagName, div)\n    if (child)\n      el.appendChild(child)\n\n  }\n  // end ie9elem()\n\n  return _mkdom\n\n})(IE_VERSION)\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n\n  var i = tags.length,\n    j = items.length\n\n  while (i > j) {\n    var t = tags[--i]\n    tags.splice(i, 1)\n    t.unmount()\n  }\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @param   { Object } child - non custom loop tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(child, i) {\n  Object.keys(child.tags).forEach(function(tagName) {\n    var tag = child.tags[tagName]\n    if (isArray(tag))\n      each(tag, function (t) {\n        moveChildTag(t, tagName, i)\n      })\n    else\n      moveChildTag(tag, tagName, i)\n  })\n}\n\n/**\n * Adds the elements for a virtual tag\n * @param { Tag } tag - the tag whose root's children will be inserted or appended\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction addVirtual(tag, src, target) {\n  var el = tag._root\n  tag._virts = []\n  while (el) {\n    var sib = el.nextSibling\n    if (target)\n      src.insertBefore(el, target._root)\n    else\n      src.appendChild(el)\n\n    tag._virts.push(el) // hold for unmounting\n    el = sib\n  }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @param { Tag } tag - first child reference used to start move\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n * @param { Number } len - how many child nodes to move\n */\nfunction moveVirtual(tag, src, target, len) {\n  var el = tag._root\n  for (var i = 0; i < len; i++) {\n    var sib = el.nextSibling\n    src.insertBefore(el, target._root)\n    el = sib\n  }\n}\n\n\n/**\n * Manage tags having the 'each'\n * @param   { Object } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, 'each')\n\n  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n    tagName = getTagName(dom),\n    impl = __tagImpl[tagName] || { tmpl: dom.outerHTML },\n    useRoot = SPECIAL_TAGS_REGEX.test(tagName),\n    root = dom.parentNode,\n    ref = document.createTextNode(''),\n    child = getTag(dom),\n    isOption = /option/gi.test(tagName), // the option tags must be treated differently\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isVirtual = dom.tagName == 'VIRTUAL'\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr)\n\n  // insert a marked where the loop tags will be injected\n  root.insertBefore(ref, dom)\n\n  // clean template code\n  parent.one('before-mount', function () {\n\n    // remove the original DOM node\n    dom.parentNode.removeChild(dom)\n    if (root.stub) root = parent.root\n\n  }).on('update', function () {\n    // get the new items collection\n    var items = tmpl(expr.val, parent),\n      // create a fragment to hold the new DOM nodes to inject in the parent tag\n      frag = document.createDocumentFragment()\n\n\n\n    // object loop. any changes cause full redraw\n    if (!isArray(items)) {\n      hasKeys = items || false\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, key, items[key])\n        }) : []\n    }\n\n    // loop all the new items\n    items.forEach(function(item, i) {\n      // reorder only if the items are objects\n      var _mustReorder = mustReorder && item instanceof Object,\n        oldPos = oldItems.indexOf(item),\n        pos = ~oldPos && _mustReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos]\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item\n\n      // new tag\n      if (\n        !_mustReorder && !tag // with no-reorder we just update the old tags\n        ||\n        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements\n      ) {\n\n        tag = new Tag(impl, {\n          parent: parent,\n          isLoop: true,\n          hasImpl: !!__tagImpl[tagName],\n          root: useRoot ? root : dom.cloneNode(),\n          item: item\n        }, dom.innerHTML)\n\n        tag.mount()\n        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts\n        // this tag must be appended\n        if (i == tags.length) {\n          if (isVirtual)\n            addVirtual(tag, frag)\n          else frag.appendChild(tag.root)\n        }\n        // this tag must be insert\n        else {\n          if (isVirtual)\n            addVirtual(tag, root, tags[i])\n          else root.insertBefore(tag.root, tags[i].root)\n          oldItems.splice(i, 0, item)\n        }\n\n        tags.splice(i, 0, tag)\n        pos = i // handled here so no move\n      } else tag.update(item)\n\n      // reorder the tag if it's not located in its previous position\n      if (pos !== i && _mustReorder) {\n        // update the DOM\n        if (isVirtual)\n          moveVirtual(tag, root, tags[i], dom.childNodes.length)\n        else root.insertBefore(tag.root, tags[i].root)\n        // update the position attribute if it exists\n        if (expr.pos)\n          tag[expr.pos] = i\n        // move the old tag instance\n        tags.splice(i, 0, tags.splice(pos, 1)[0])\n        // move the old item\n        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child) moveNestedTags(tag, i)\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag._item = item\n      // cache the real parent tag internally\n      defineProperty(tag, '_parent', parent)\n\n    }, true) // allow null values\n\n    // remove the redundant tags\n    unmountRedundant(items, tags)\n\n    // insert the new nodes\n    if (isOption) root.appendChild(frag)\n    else root.insertBefore(frag, ref)\n\n    // set the 'tags' property of the parent tag\n    // if child is 'undefined' it means that we don't need to set this property\n    // for example:\n    // we don't need store the `myTag.tags['div']` property if we are looping a div tag\n    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`\n    if (child) parent.tags[tagName] = tags\n\n    // clone the items array\n    oldItems = items.slice()\n\n  })\n\n}\n\n\nfunction parseNamedElements(root, tag, childTags, forceParsingNamed) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = dom.isLoop || (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each')) ? 1 : 0\n\n      // custom child tag\n      if (childTags) {\n        var child = getTag(dom)\n\n        if (child && !dom.isLoop)\n          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))\n      }\n\n      if (!dom.isLoop || forceParsingNamed)\n        setNamed(dom, tag, [])\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (tmpl.hasExpr(val)) {\n      var expr = { dom: dom, expr: val }\n      expressions.push(extend(expr, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    var attr = getAttr(dom, 'each')\n\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n    opts = inherit(conf.opts) || {},\n    dom = mkdom(impl.tmpl),\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    hasImpl = conf.hasImpl,\n    item = cleanUpData(conf.item),\n    expressions = [],\n    childTags = [],\n    root = conf.root,\n    fn = impl.fn,\n    tagName = root.tagName.toLowerCase(),\n    attr = {},\n    propsInSyncWithParent = []\n\n  if (fn && root._tag) root._tag.unmount(true)\n\n  // not yet mounted\n  this.isMounted = false\n  root.isLoop = isLoop\n\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id\n\n  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    var val = el.value\n    // remember attributes with expressions only\n    if (tmpl.hasExpr(val)) attr[el.name] = val\n  })\n\n  if (dom.innerHTML && !/^(select|optgroup|table|tbody|tr|col(?:group)?)$/.test(tagName))\n    // replace all the yield tags with the tag inner html\n    dom.innerHTML = replaceYield(dom.innerHTML, innerHTML)\n\n  // options\n  function updateOpts() {\n    var ctx = hasImpl && isLoop ? self : parent || self\n\n    // update opts from current DOM attributes\n    each(root.attributes, function(el) {\n      opts[toCamel(el.name)] = tmpl(el.value, ctx)\n    })\n    // recover those with expressions\n    each(Object.keys(attr), function(name) {\n      opts[toCamel(name)] = tmpl(attr[name], ctx)\n    })\n  }\n\n  function normalizeData(data) {\n    for (var key in item) {\n      if (typeof self[key] !== T_UNDEF && isWritable(self, key))\n        self[key] = data[key]\n    }\n  }\n\n  function inheritFromParent () {\n    if (!self.parent || !isLoop) return\n    each(Object.keys(self.parent), function(k) {\n      // some properties must be always in sync with the parent tag\n      var mustSync = !contains(RESERVED_WORDS_BLACKLIST, k) && contains(propsInSyncWithParent, k)\n      if (typeof self[k] === T_UNDEF || mustSync) {\n        // track the property to keep in sync\n        // so we can keep it updated\n        if (!mustSync) propsInSyncWithParent.push(k)\n        self[k] = self.parent[k]\n      }\n    })\n  }\n\n  defineProperty(this, 'update', function(data) {\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data)\n    // inherit properties from the parent\n    inheritFromParent()\n    // normalize the tag properties in case an item object was initially passed\n    if (data && typeof item === T_OBJECT) {\n      normalizeData(data)\n      item = data\n    }\n    extend(self, data)\n    updateOpts()\n    self.trigger('update', data)\n    update(expressions, self)\n    // the updated event will be triggered\n    // once the DOM will be ready and all the reflow are completed\n    // this is useful if you want to get the \"real\" root properties\n    // 4 ex: root.offsetWidth ...\n    rAF(function() { self.trigger('updated') })\n    return this\n  })\n\n  defineProperty(this, 'mixin', function() {\n    each(arguments, function(mix) {\n      var instance\n\n      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix()\n        // save the prototype to loop it afterwards\n        mix = mix.prototype\n      } else instance = mix\n\n      // loop the keys in the function prototype or the all object keys\n      each(Object.getOwnPropertyNames(mix), function(key) {\n        // bind methods to self\n        if (key != 'init')\n          self[key] = isFunction(instance[key]) ?\n                        instance[key].bind(self) :\n                        instance[key]\n      })\n\n      // init method will be called automatically\n      if (instance.init) instance.init.bind(self)()\n    })\n    return this\n  })\n\n  defineProperty(this, 'mount', function() {\n\n    updateOpts()\n\n    // initialiation\n    if (fn) fn.call(self, opts)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    // mount the child tags\n    toggle(true)\n\n    // update the root adding custom attributes coming from the compiler\n    // it fixes also #1087\n    if (impl.attrs || hasImpl) {\n      walkAttributes(impl.attrs, function (k, v) { setAttr(root, k, v) })\n      parseExpressions(self.root, self, expressions)\n    }\n\n    if (!self.parent || isLoop) self.update(item)\n\n    // internal use only, fixes #403\n    self.trigger('before-mount')\n\n    if (isLoop && !hasImpl) {\n      // update the root attribute for the looped elements\n      self.root = root = dom.firstChild\n\n    } else {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n      if (root.stub) self.root = root = parent.root\n    }\n\n    // parse the named dom nodes in the looped child\n    // adding them to the parent as well\n    if (isLoop)\n      parseNamedElements(self.root, self.parent, null, true)\n\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent || self.parent.isMounted) {\n      self.isMounted = true\n      self.trigger('mount')\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() {\n      // avoid to trigger the `mount` event for the tags\n      // not visible included in an if statement\n      if (!isInStub(self.root)) {\n        self.parent.isMounted = self.isMounted = true\n        self.trigger('mount')\n      }\n    })\n  })\n\n\n  defineProperty(this, 'unmount', function(keepRootTag) {\n    var el = root,\n      p = el.parentNode,\n      ptag\n\n    self.trigger('before-unmount')\n\n    // remove this tag instance from the global virtualDom variable\n    __virtualDom.splice(__virtualDom.indexOf(self), 1)\n\n    if (this._virts) {\n      each(this._virts, function(v) {\n        v.parentNode.removeChild(v)\n      })\n    }\n\n    if (p) {\n\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent)\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (isArray(ptag.tags[tagName]))\n          each(ptag.tags[tagName], function(tag, i) {\n            if (tag._riot_id == self._riot_id)\n              ptag.tags[tagName].splice(i, 1)\n          })\n        else\n          // otherwise just delete the tag instance\n          ptag.tags[tagName] = undefined\n      }\n\n      else\n        while (el.firstChild) el.removeChild(el.firstChild)\n\n      if (!keepRootTag)\n        p.removeChild(el)\n      else\n        // the riot-tag attribute isn't needed anymore, remove it\n        remAttr(p, 'riot-tag')\n    }\n\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    self.isMounted = false\n    // somehow ie8 does not like `delete root._tag`\n    root._tag = null\n\n  })\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (parent) {\n      var evt = isMount ? 'on' : 'off'\n\n      // the loop tags will be always in sync with the parent automatically\n      if (isLoop)\n        parent[evt]('unmount', self.unmount)\n      else\n        parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n    }\n  }\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n}\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n\n  dom[name] = function(e) {\n\n    var ptag = tag._parent,\n      item = tag._item,\n      el\n\n    if (!item)\n      while (ptag && !item) {\n        item = ptag._item\n        ptag = ptag._parent\n      }\n\n    // cross browser event fix\n    e = e || window.event\n\n    // override the event properties\n    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n    if (isWritable(e, 'target')) e.target = e.srcElement\n    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      if (e.preventDefault) e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      el = item ? getImmediateCustomParentTag(ptag) : tag\n      el.update()\n    }\n\n  }\n\n}\n\n\n/**\n * Insert a DOM node replacing another one (used by if- attribute)\n * @param   { Object } root - parent node\n * @param   { Object } node - node replaced\n * @param   { Object } before - node added\n */\nfunction insertTo(root, node, before) {\n  if (root) {\n    root.insertBefore(before, node)\n    root.removeChild(node)\n  }\n}\n\n/**\n * Update the expressions in a Tag instance\n * @param   { Array } expressions - expression that must be re evaluated\n * @param   { Tag } tag - tag instance\n */\nfunction update(expressions, tag) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n      attrName = expr.attr,\n      value = tmpl(expr.expr, tag),\n      parent = expr.dom.parentNode\n\n    if (expr.bool)\n      value = value ? attrName : false\n    else if (value == null)\n      value = ''\n\n    // leave out riot- prefixes from strings inside textarea\n    // fix #815: any value -> string\n    if (parent && parent.tagName == 'TEXTAREA') {\n      value = ('' + value).replace(/riot-/g, '')\n      // change textarea's value\n      parent.value = value\n    }\n\n    // no change\n    if (expr.value === value) return\n    expr.value = value\n\n    // text node\n    if (!attrName) {\n      dom.nodeValue = '' + value    // #815 related\n      return\n    }\n\n    // remove original attribute\n    remAttr(dom, attrName)\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, tag)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub,\n        add = function() { insertTo(stub.parentNode, stub, dom) },\n        remove = function() { insertTo(dom.parentNode, dom, stub) }\n\n      // add to DOM\n      if (value) {\n        if (stub) {\n          add()\n          dom.inStub = false\n          // avoid to trigger the mount event if the tags is not visible yet\n          // maybe we can optimize this avoiding to mount the tag at all\n          if (!isInStub(dom)) {\n            walk(dom, function(el) {\n              if (el._tag && !el._tag.isMounted) el._tag.isMounted = !!el._tag.trigger('mount')\n            })\n          }\n        }\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        // if the parentNode is defined we can easily replace the tag\n        if (dom.parentNode)\n          remove()\n        // otherwise we need to wait the updated event\n        else (tag.parent || tag).one('updated', remove)\n\n        dom.inStub = true\n      }\n    // show / hide\n    } else if (/^(show|hide)$/.test(attrName)) {\n      if (attrName == 'hide') value = !value\n      dom.style.display = value ? '' : 'none'\n\n    // field value\n    } else if (attrName == 'value') {\n      dom.value = value\n\n    // <img src=\"{ expr }\">\n    } else if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n      if (value)\n        setAttr(dom, attrName.slice(RIOT_PREFIX.length), value)\n\n    } else {\n      if (expr.bool) {\n        dom[attrName] = value\n        if (!value) return\n      }\n\n      if (value && value != 0 && typeof value !== T_OBJECT)\n        setAttr(dom, attrName, value)\n\n    }\n\n  })\n\n}\n/**\n * Loops an array\n * @param   { Array } els - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(els, fn) {\n  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n    el = els[i]\n    // return false -> remove current item during loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\n/**\n * Detect if the argument passed is a function\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isFunction(v) {\n  return typeof v === T_FUNCTION || false   // avoid IE problems\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } string - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(string) {\n  return string.replace(/-(\\w)/g, function(_, c) {\n    return c.toUpperCase()\n  })\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  dom.setAttribute(name, val)\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]\n}\n/**\n * Add a child tag to its parent into the `tags` object\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the new tag will be stored\n * @param   { Object } parent - tag instance where the new child tag will be included\n */\nfunction addChildTag(tag, tagName, parent) {\n  var cachedTag = parent.tags[tagName]\n\n  // if there are multiple children tags having the same name\n  if (cachedTag) {\n    // if the parent tags property is not yet an array\n    // create it adding the first cached tag\n    if (!isArray(cachedTag))\n      // don't add the same tag twice\n      if (cachedTag !== tag)\n        parent.tags[tagName] = [cachedTag]\n    // add the new nested tag to the array\n    if (!contains(parent.tags[tagName], tag))\n      parent.tags[tagName].push(tag)\n  } else {\n    parent.tags[tagName] = tag\n  }\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tag, tagName, newPos) {\n  var parent = tag.parent,\n    tags\n  // no parent no move\n  if (!parent) return\n\n  tags = parent.tags[tagName]\n\n  if (isArray(tags))\n    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])\n  else addChildTag(tag, tagName, parent)\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag(child, opts, innerHTML),\n    tagName = getTagName(opts.root),\n    ptag = getImmediateCustomParentTag(parent)\n  // fix for the parent attribute in the looped elements\n  tag.parent = ptag\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag._parent = parent\n\n  // add this tag to the custom parent tag\n  addChildTag(tag, tagName, ptag)\n  // and also to the real parent tag\n  if (ptag !== parent)\n    addChildTag(tag, tagName, parent)\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = ''\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag\n  while (!getTag(ptag.root)) {\n    if (!ptag.parent) break\n    ptag = ptag.parent\n  }\n  return ptag\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n* @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: false\n  }, options))\n  return el\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom) {\n  var child = getTag(dom),\n    namedTag = getAttr(dom, 'name'),\n    tagName = namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n\n  return tagName\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          src[key] = obj[key]\n      }\n    }\n  }\n  return src\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } arr - target array\n * @param   { * } item - item to test\n * @returns { Boolean } Does 'arr' contain 'item'?\n */\nfunction contains(arr, item) {\n  return ~arr.indexOf(item)\n}\n\n/**\n * Check whether an object is a kind of array\n * @param   { * } a - anything\n * @returns {Boolean} is 'a' an array?\n */\nfunction isArray(a) { return Array.isArray(a) || a instanceof Array }\n\n/**\n * Detect whether a property of an object could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } is this property writable?\n */\nfunction isWritable(obj, key) {\n  var props = Object.getOwnPropertyDescriptor(obj, key)\n  return typeof obj[key] === T_UNDEF || props && props.writable\n}\n\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION)) return data\n\n  var o = {}\n  for (var key in data) {\n    if (!contains(RESERVED_WORDS_BLACKLIST, key))\n      o[key] = data[key]\n  }\n  return o\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n */\nfunction walk(dom, fn) {\n  if (dom) {\n    // stop the recursion\n    if (fn(dom) === false) return\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttributes(html, fn) {\n  var m,\n    re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\n  while (m = re.exec(html)) {\n    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n  }\n}\n\n/**\n * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n * @param   { Object }  dom - DOM node we want to parse\n * @returns { Boolean } -\n */\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub) return true\n    dom = dom.parentNode\n  }\n  return false\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name) {\n  return document.createElement(name)\n}\n\n/**\n * Create a generic DOM node, and fill it with innerHTML\n * @param   { String } name - name of the DOM node we want to create\n * @param   { String } innerHTML - innerHTML of the new DOM\n * @returns { Object } DOM node just created\n */\nfunction mkElWithInnerHTML(name, innerHTML) {\n  var el = mkEl(name)\n  el.innerHTML = innerHTML || ''\n  return el\n}\n\n/**\n * Replace the yield tag from any tag template with the innerHTML of the\n * original tag in the page\n * @param   { String } tmpl - tag implementation template\n * @param   { String } innerHTML - original content of the tag in the DOM\n * @returns { String } tag template updated without the yield tag\n */\nfunction replaceYield(tmpl, innerHTML) {\n  var tmplElement = mkElWithInnerHTML('div', tmpl)\n  // if ($('yield[from]'.tmplElement)) { // this issues test errors\n  if (tmplElement.querySelector && tmplElement.querySelector('yield[from]')) { // code coverage path not taken (?)\n    // yield to(s) must be direct children from innerHTML(root), all other tags are ignored\n    each(mkElWithInnerHTML('div', innerHTML).childNodes, function(toYield) {\n      if (toYield.nodeType == 1 && toYield.tagName == 'YIELD' && toYield.getAttribute('to')) {\n        // replace all yield[from]\n        each($$('yield[from=\"'+toYield.getAttribute('to')+'\"]', tmplElement), function(fromYield) {\n          fromYield.outerHTML = toYield.innerHTML\n        })\n      }\n    })\n    return tmplElement.innerHTML\n  } else\n    // just replace yield in tmpl with the innerHTML\n    return tmpl.replace(/<yield\\s*(?:\\/>|>\\s*<\\/yield\\s*>)/gi, innerHTML || '')\n}\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Simple object prototypal inheritance\n * @param   { Object } parent - parent object\n * @returns { Object } child instance\n */\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n\n/**\n * Get the name property needed to identify a DOM node in riot\n * @param   { Object } dom - DOM node we need to parse\n * @returns { String | undefined } give us back a string to identify this dom node\n */\nfunction getNamedKey(dom) {\n  return getAttr(dom, 'id') || getAttr(dom, 'name')\n}\n\n/**\n * Set the named properties of a tag element\n * @param { Object } dom - DOM node we need to parse\n * @param { Object } parent - tag instance where the named dom element will be eventually added\n * @param { Array } keys - list of all the tag instance properties\n */\nfunction setNamed(dom, parent, keys) {\n  // get the key value we want to add to the tag instance\n  var key = getNamedKey(dom),\n    // add the node detected to a tag instance using the named property\n    add = function(value) {\n      // avoid to override the tag properties already set\n      if (contains(keys, key)) return\n      // check whether this value is an array\n      var isArr = isArray(value)\n      // if the key was never set\n      if (!value)\n        // set it once on the tag instance\n        parent[key] = dom\n      // if it was an array and not yet set\n      else if (!isArr || isArr && !contains(value, dom)) {\n        // add the dom node into the array\n        if (isArr)\n          value.push(dom)\n        else\n          parent[key] = [value, dom]\n      }\n    }\n\n  // skip the elements with no named properties\n  if (!key) return\n\n  // check whether this key has been already evaluated\n  if (tmpl.hasExpr(key))\n    // wait the first updated event only once\n    parent.one('updated', function() {\n      key = getNamedKey(dom)\n      add(parent[key])\n    })\n  else\n    add(parent[key])\n\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } src - source string\n * @param   { String } str - test string\n * @returns { Boolean } -\n */\nfunction startsWith(src, str) {\n  return src.slice(0, str.length) === str\n}\n\n/**\n * Function needed to inject in runtime the custom tags css\n */\nvar injectStyle = (function() {\n\n  if (!window) return // skip injection on the server\n\n  // create the style node\n  var styleNode = mkEl('style'),\n    placeholder = $('style[type=riot]')\n\n  setAttr(styleNode, 'type', 'text/css')\n\n  // inject the new node into the DOM -- in head\n  if (placeholder) {\n    placeholder.parentNode.replaceChild(styleNode, placeholder)\n    placeholder = null\n  }\n  else document.getElementsByTagName('head')[0].appendChild(styleNode)\n\n  /**\n   * This is the function exported that will be used to update the style tag just created\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @param   { String } css [description]\n   */\n  return styleNode.styleSheet ?\n    function (css) { styleNode.styleSheet.cssText += css } :\n    function (css) { styleNode.innerHTML += css }\n\n})()\n\n/**\n * requestAnimationFrame polyfill\n */\nvar rAF = (function(w) {\n  return  w.requestAnimationFrame       ||\n          w.webkitRequestAnimationFrame ||\n          w.mozRequestAnimationFrame    ||\n          function(cb) { setTimeout(cb, 1000 / 60) }\n})(window || {})\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts) {\n  var tag = __tagImpl[tagName],\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    // add this tag to the virtualDom variable\n    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)\n  }\n\n  return tag\n}\n/**\n * Riot public api\n */\n\n// share methods for other riot parts, e.g. compiler\nriot.util = { brackets: brackets, tmpl: tmpl }\n\n/**\n * Create a mixin that could be globally shared across all the tags\n */\nriot.mixin = (function() {\n  var mixins = {}\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String } name - mixin name\n   * @param   { Object } mixin - mixin logic\n   * @returns { Object } the mixin logic\n   */\n  return function(name, mixin) {\n    if (!mixin) return mixins[name]\n    mixins[name] = mixin\n  }\n\n})()\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nriot.tag = function(name, html, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css\n      css = ''\n    } else attrs = ''\n  }\n  if (css) {\n    if (isFunction(css)) fn = css\n    else if (injectStyle) injectStyle(css)\n  }\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @param   { string }  [bpair] - brackets used in the compilation\n * @returns { String } name/id of the tag just created\n */\nriot.tag2 = function(name, html, css, attrs, fn, bpair) {\n  if (css && injectStyle) injectStyle(css)\n  //if (bpair) riot.settings.brackets = bpair\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { String } selector - tag DOM selector\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nriot.mount = function(selector, tagName, opts) {\n\n  var els,\n    allTags,\n    tags = []\n\n  // helper functions\n\n  function addRiotTags(arr) {\n    var list = ''\n    each(arr, function (e) {\n      list += ', *[' + RIOT_TAG + '=\"' + e.trim() + '\"]'\n    })\n    return list\n  }\n\n  function selectAllTags() {\n    var keys = Object.keys(__tagImpl)\n    return keys + addRiotTags(keys)\n  }\n\n  function pushTags(root) {\n    var last\n\n    if (root.tagName) {\n      if (tagName && (!(last = getAttr(root, RIOT_TAG)) || last != tagName))\n        setAttr(root, RIOT_TAG, tagName)\n\n      var tag = mountTo(root, tagName || root.getAttribute(RIOT_TAG) || root.tagName.toLowerCase(), opts)\n\n      if (tag) tags.push(tag)\n    } else if (root.length)\n      each(root, pushTags)   // assume nodeList\n\n  }\n\n  // ----- mount code -----\n\n  if (typeof tagName === T_OBJECT) {\n    opts = tagName\n    tagName = 0\n  }\n\n  // crawl the DOM to find the tag\n  if (typeof selector === T_STRING) {\n    if (selector === '*')\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selectAllTags()\n    else\n      // or just the ones named like the selector\n      selector += addRiotTags(selector.split(','))\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    els = selector ? $$(selector) : []\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    els = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectAllTags()\n    // if the root els it's just a single tag\n    if (els.tagName)\n      els = $$(tagName, els)\n    else {\n      // select all the children for all the different root elements\n      var nodeList = []\n      each(els, function (_el) {\n        nodeList.push($$(tagName, _el))\n      })\n      els = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  if (els.tagName)\n    pushTags(els)\n  else\n    each(els, pushTags)\n\n  return tags\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nriot.update = function() {\n  return each(__virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n/**\n * Export the Tag constructor\n */\nriot.Tag = Tag\n  // support CommonJS, AMD & browser\n  /* istanbul ignore next */\n  if (typeof exports === T_OBJECT)\n    module.exports = riot\n  else if (typeof define === T_FUNCTION && typeof define.amd !== T_UNDEF)\n    define(function() { return (window.riot = riot) })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : void 0);\n","date":"2015-12-17T03:11:20.964Z","updated":"2015-12-15T21:11:22.000Z","path":"unrest/bower_components/riot/riot.js","layout":"false","title":"","comments":1,"_id":"cijth4lan000c0nfw0g9xlbby"},{"_content":"/* Riot v2.3.12, @license MIT, (c) 2015 Muut Inc. + contributors */\n(function(e,t){\"use strict\";var n={version:\"v2.3.12\",settings:{}},r=0,i=[],o={},f=\"riot-\",a=f+\"tag\",u=\"string\",s=\"object\",c=\"undefined\",l=\"function\",p=/^(?:opt(ion|group)|tbody|col|t[rhd])$/,d=[\"_item\",\"_id\",\"_parent\",\"update\",\"root\",\"mount\",\"unmount\",\"mixin\",\"isMounted\",\"isLoop\",\"tags\",\"parent\",\"opts\",\"trigger\",\"on\",\"off\",\"one\"],g=(e&&e.document||{}).documentMode|0;n.observable=function(e){e=e||{};var t={},n=function(e,t){e.replace(/\\S+/g,t)},r=function(t,n){Object.defineProperty(e,t,{value:n,enumerable:false,writable:false,configurable:false})};r(\"on\",function(r,i){if(typeof i!=\"function\")return e;n(r,function(e,n){(t[e]=t[e]||[]).push(i);i.typed=n>0});return e});r(\"off\",function(r,i){if(r==\"*\")t={};else{n(r,function(e){if(i){var n=t[e];for(var r=0,o;o=n&&n[r];++r){if(o==i)n.splice(r--,1)}}else delete t[e]})}return e});r(\"one\",function(t,n){function r(){e.off(t,r);n.apply(e,arguments)}return e.on(t,r)});r(\"trigger\",function(r){var i=arguments.length-1,o=new Array(i);for(var f=0;f<i;f++){o[f]=arguments[f+1]}n(r,function(n){var r=(t[n]||[]).slice(0);for(var i=0,f;f=r[i];++i){if(f.busy)return;f.busy=1;try{f.apply(e,f.typed?[n].concat(o):o)}catch(a){e.trigger(\"error\",a)}if(r[i]!==f){i--}f.busy=0}if(t.all&&n!=\"all\")e.trigger.apply(e,[\"all\",n].concat(o))});return e});return e};(function(t){if(!e)return;var n=/^.+?\\/+[^\\/]+/,r=\"EventListener\",i=\"remove\"+r,o=\"add\"+r,f=\"hasAttribute\",a=\"replace\",u=\"popstate\",s=\"hashchange\",c=\"trigger\",l=3,p=e,d=document,g=p.history.location||p.location,h=j.prototype,v=d&&d.ontouchstart?\"touchstart\":\"click\",m=false,b=t.observable(),y=false,w,x,_,S,L,N=[],C=0;function T(e){return e.split(/[\\/?#]/)}function E(e,t){var n=new RegExp(\"^\"+t[a](/\\*/g,\"([^/?#]+?)\")[a](/\\.\\./,\".*\")+\"$\"),r=e.match(n);if(r)return r.slice(1)}function M(e,t){var n;return function(){clearTimeout(n);n=setTimeout(e,t)}}function O(e){w=M(I,1);p[o](u,w);p[o](s,w);d[o](v,H);if(e)I(true)}function j(){this.$=[];t.observable(this);b.on(\"stop\",this.s.bind(this));b.on(\"emit\",this.e.bind(this))}function R(e){return e[a](/^\\/|\\/$/,\"\")}function A(e){return typeof e==\"string\"}function $(e){return(e||g.href)[a](n,\"\")}function k(e){return x[0]==\"#\"?(e||g.href).split(x)[1]||\"\":$(e)[a](x,\"\")}function I(e){var t=C==0;if(l<=C)return;C++;N.push(function(){var t=k();if(e||t!=_){b[c](\"emit\",t);_=t}});if(t){while(N.length){N[0]();N.shift()}C=0}}function H(e){if(e.which!=1||e.metaKey||e.ctrlKey||e.shiftKey||e.defaultPrevented)return;var t=e.target;while(t&&t.nodeName!=\"A\")t=t.parentNode;if(!t||t.nodeName!=\"A\"||t[f](\"download\")||!t[f](\"href\")||t.target&&t.target!=\"_self\"||t.href.indexOf(g.href.match(n)[0])==-1)return;if(t.href!=g.href){if(t.href.split(\"#\")[0]==g.href.split(\"#\")[0]||x!=\"#\"&&$(t.href).indexOf(x)!==0||!F(k(t.href),t.title||d.title))return}e.preventDefault()}function F(e,t){t=t||d.title;history.pushState(null,t,x+R(e));d.title=t;y=false;I();return y}h.m=function(e,t){if(A(e)&&(!t||A(t)))F(e,t);else if(t)this.r(e,t);else this.r(\"@\",e)};h.s=function(){this.off(\"*\");this.$=[]};h.e=function(e){this.$.concat(\"@\").some(function(t){var n=(t==\"@\"?S:L)(R(e),R(t));if(typeof n!=\"undefined\"){this[c].apply(null,[t].concat(n));return y=true}},this)};h.r=function(e,t){if(e!=\"@\"){e=\"/\"+R(e);this.$.push(e)}this.on(e,t)};var q=new j;var B=q.m.bind(q);B.create=function(){var e=new j;e.m.stop=e.s.bind(e);return e.m.bind(e)};B.base=function(e){x=e||\"#\";_=k()};B.exec=function(){I(true)};B.parser=function(e,t){if(!e&&!t){S=T;L=E}if(e)S=e;if(t)L=t};B.query=function(){var e={};g.href[a](/[?&](.+?)=([^&]*)/g,function(t,n,r){e[n]=r});return e};B.stop=function(){if(m){p[i](u,w);p[i](s,w);d[i](v,H);b[c](\"stop\");m=false}};B.start=function(e){if(!m){if(document.readyState==\"complete\")O(e);else p[o](\"load\",function(){setTimeout(function(){O(e)},1)});m=true}};B.base();B.parser();t.route=B})(n);var h=function(e){var t=\"g\",r=/\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,i=/\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,o=i.source+\"|\"+/(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source+\"|\"+/\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,f=\"{ }\",a={\"(\":RegExp(\"([()])|\"+o,t),\"[\":RegExp(\"([[\\\\]])|\"+o,t),\"{\":RegExp(\"([{}])|\"+o,t)};var u=e,s,c=[];function l(e){return e}function p(e,n){if(!n)n=c;return new RegExp(e.source.replace(/{/g,n[2]).replace(/}/g,n[3]),e.global?t:\"\")}function d(e){var n,r=e.split(\" \");if(e===f){r[2]=r[0];r[3]=r[1];n=l}else{if(r.length!==2||/[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(e)){throw new Error('Unsupported brackets \"'+e+'\"')}r=r.concat(e.replace(/(?=[[\\]()*+?.^$|])/g,\"\\\\\").split(\" \"));n=p}r[4]=n(r[1].length>1?/{[\\S\\s]*?}/:/{[^}]*}/,r);r[5]=n(/\\\\({|})/g,r);r[6]=n(/(\\\\?)({)/g,r);r[7]=RegExp(\"(\\\\\\\\?)(?:([[({])|(\"+r[3]+\"))|\"+o,t);r[8]=e;return r}function g(e){if(!e)e=f;if(e!==c[8]){c=d(e);s=e===f?l:p;c[9]=s(/^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/);c[10]=s(/(^|[^\\\\]){=[\\S\\s]*?}/);h._rawOffset=c[0].length}u=e}function h(e){return e instanceof RegExp?s(e):c[e]}h.split=function b(e,t,n){if(!n)n=c;var r=[],i,o,f,u,s=n[6];o=f=s.lastIndex=0;while(i=s.exec(e)){u=i.index;if(o){if(i[2]){s.lastIndex=p(i[2],s.lastIndex);continue}if(!i[3])continue}if(!i[1]){l(e.slice(f,u));f=s.lastIndex;s=n[6+(o^=1)];s.lastIndex=f}}if(e&&f<e.length){l(e.slice(f))}return r;function l(e){if(t||o)r.push(e&&e.replace(n[5],\"$1\"));else r.push(e)}function p(t,n){var r,i=a[t],o=1;i.lastIndex=n;while(r=i.exec(e)){if(r[1]&&!(r[1]===t?++o:--o))break}return r?i.lastIndex:e.length}};h.hasExpr=function y(e){return h(4).test(e)};h.loopKeys=function w(e){var t=e.match(h(9));return t?{key:t[1],pos:t[2],val:c[0]+t[3].trim()+c[1]}:{val:e.trim()}};h.array=function x(e){return d(e||u)};var v;function m(e){var t;e=e||{};t=e.brackets;Object.defineProperty(e,\"brackets\",{set:g,get:function(){return u},enumerable:true});v=e;g(t)}Object.defineProperty(h,\"settings\",{set:m,get:function(){return v}});h.settings=typeof n!==\"undefined\"&&n.settings||{};h.set=g;h.R_STRINGS=i;h.R_MLCOMMS=r;h.S_QBLOCKS=o;return h}();var v=function(){var t={};function n(e,n){if(!e)return e;return(t[e]||(t[e]=i(e))).call(n,r)}n.isRaw=function(e){return e[h._rawOffset]===\"=\"};n.haveRaw=function(e){return h(10).test(e)};n.hasExpr=h.hasExpr;n.loopKeys=h.loopKeys;n.errorHandler=null;function r(e,t){if(n.errorHandler){e.riotData={tagName:t&&t.root&&t.root.tagName,_riot_id:t&&t._riot_id};n.errorHandler(e)}}function i(e){var t=a(e);if(t.slice(0,11)!==\"try{return \")t=\"return \"+t;return new Function(\"E\",t+\";\")}var o=RegExp(h.S_QBLOCKS,\"g\"),f=/\\x01(\\d+)~/g;function a(e){var t=[],n,r=h.split(e.replace(/\\u2057/g,'\"'),1);if(r.length>2||r[0]){var i,o,a=[];for(i=o=0;i<r.length;++i){n=r[i];if(n&&(n=i&1?c(n,1,t):'\"'+n.replace(/\\\\/g,\"\\\\\\\\\").replace(/\\r\\n?|\\n/g,\"\\\\n\").replace(/\"/g,'\\\\\"')+'\"'))a[o++]=n}n=o<2?a[0]:\"[\"+a.join(\",\")+'].join(\"\")'}else{n=c(r[1],0,t)}if(t[0])n=n.replace(f,function(e,n){return t[n].replace(/\\r/g,\"\\\\r\").replace(/\\n/g,\"\\\\n\")});return n}var u=/^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\x01(\\d+)~):/,s=/,|([[{(])|$/g;function c(e,t,n){if(e[0]===\"=\")e=e.slice(1);e=e.replace(o,function(e,t){return e.length>2&&!t?\"\u0001\"+(n.push(e)-1)+\"~\":e}).replace(/\\s+/g,\" \").trim().replace(/\\ ?([[\\({},?\\.:])\\ ?/g,\"$1\");if(e){var r=[],i=0,f;while(e&&(f=e.match(u))&&!f.index){var a,s,c=/,|([[{(])|$/g;e=RegExp.rightContext;a=f[2]?n[f[2]].slice(1,-1).trim().replace(/\\s+/g,\" \"):f[1];while(s=(f=c.exec(e))[1])l(s,c);s=e.slice(0,f.index);e=RegExp.rightContext;r[i++]=d(s,1,a)}e=!i?d(e,t):i>1?\"[\"+r.join(\",\")+'].join(\" \").trim()':r[0]}return e;function l(t,n){var r,i=1,o=t===\"(\"?/[()]/g:t===\"[\"?/[[\\]]/g:/[{}]/g;o.lastIndex=n.lastIndex;while(r=o.exec(e)){if(r[0]===t)++i;else if(!--i)break}n.lastIndex=i?e.length:o.lastIndex}}var l='\"in this?this:'+(typeof e!==\"object\"?\"global\":\"window\")+\").\";var p=/[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g;function d(e,t,n){var r;e=e.replace(p,function(e,t,n,i,o){if(n){i=r?0:i+e.length;if(n!==\"this\"&&n!==\"global\"&&n!==\"window\"){e=t+'(\"'+n+l+n;if(i)r=(o=o[i])===\".\"||o===\"(\"||o===\"[\"}else if(i)r=!/^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/.test(o.slice(i))}return e});if(r){e=\"try{return \"+e+\"}catch(e){E(e,this)}\"}if(n){e=(r?\"function(){\"+e+\"}.call(this)\":\"(\"+e+\")\")+'?\"'+n+'\":\"\"'}else if(t){e=\"function(v){\"+(r?e.replace(\"return \",\"v=\"):\"v=(\"+e+\")\")+';return v||v===0?v:\"\"}.call(this)'}return e}n.parse=function(e){return e};return n}();v.version=h.version=\"v2.3.19\";var m=function(e){var t={tr:\"tbody\",th:\"tr\",td:\"tr\",tbody:\"table\",col:\"colgroup\"},n=\"div\";e=e&&e<10;function r(r){var o=r&&r.match(/^\\s*<([-\\w]+)/),f=o&&o[1].toLowerCase(),a=t[f]||n,u=X(a);u.stub=true;if(e&&f&&(o=f.match(p)))i(u,r,f,!!o[1]);else u.innerHTML=r;return u}function i(e,t,r,i){var o=X(n),f=i?\"select>\":\"table>\",a;o.innerHTML=\"<\"+f+t+\"</\"+f;a=te(r,o);if(a)e.appendChild(a)}return r}(g);function b(e,t,n){var r={};r[e.key]=t;if(e.pos)r[e.pos]=n;return r}function y(e,t){var n=t.length,r=e.length;while(n>r){var i=t[--n];t.splice(n,1);i.unmount()}}function w(e,t){Object.keys(e.tags).forEach(function(n){var r=e.tags[n];if(z(r))O(r,function(e){F(e,n,t)});else F(r,n,t)})}function x(e,t,n){var r=e._root;e._virts=[];while(r){var i=r.nextSibling;if(n)t.insertBefore(r,n._root);else t.appendChild(r);e._virts.push(r);r=i}}function _(e,t,n,r){var i=e._root;for(var o=0;o<r;o++){var f=i.nextSibling;t.insertBefore(i,n._root);i=f}}function S(e,t,n){R(e,\"each\");var r=typeof $(e,\"no-reorder\")!==u||R(e,\"no-reorder\"),i=P(e),f=o[i]||{tmpl:e.outerHTML},a=p.test(i),s=e.parentNode,c=document.createTextNode(\"\"),l=I(e),d=/option/gi.test(i),g=[],h=[],m,S=e.tagName==\"VIRTUAL\";n=v.loopKeys(n);s.insertBefore(c,e);t.one(\"before-mount\",function(){e.parentNode.removeChild(e);if(s.stub)s=t.root}).on(\"update\",function(){var u=v(n.val,t),p=document.createDocumentFragment();if(!z(u)){m=u||false;u=m?Object.keys(u).map(function(e){return b(n,e,u[e])}):[]}u.forEach(function(u,c){var d=r&&u instanceof Object,v=h.indexOf(u),y=~v&&d?v:c,L=g[y];u=!m&&n.key?b(n,u,c):u;if(!d&&!L||d&&!~v||!L){L=new C(f,{parent:t,isLoop:true,hasImpl:!!o[i],root:a?s:e.cloneNode(),item:u},e.innerHTML);L.mount();if(S)L._root=L.root.firstChild;if(c==g.length){if(S)x(L,p);else p.appendChild(L.root)}else{if(S)x(L,s,g[c]);else s.insertBefore(L.root,g[c].root);h.splice(c,0,u)}g.splice(c,0,L);y=c}else L.update(u);if(y!==c&&d){if(S)_(L,s,g[c],e.childNodes.length);else s.insertBefore(L.root,g[c].root);if(n.pos)L[n.pos]=c;g.splice(c,0,g.splice(y,1)[0]);h.splice(c,0,h.splice(y,1)[0]);if(!l)w(L,c)}L._item=u;K(L,\"_parent\",t)},true);y(u,g);if(d)s.appendChild(p);else s.insertBefore(p,c);if(l)t.tags[i]=g;h=u.slice()})}function L(e,t,n,r){V(e,function(e){if(e.nodeType==1){e.isLoop=e.isLoop||(e.parentNode&&e.parentNode.isLoop||$(e,\"each\"))?1:0;if(n){var i=I(e);if(i&&!e.isLoop)n.push(q(i,{root:e,parent:t},e.innerHTML,t))}if(!e.isLoop||r)ie(e,t,[])}})}function N(e,t,n){function r(e,t,r){if(v.hasExpr(t)){var i={dom:e,expr:t};n.push(D(i,r))}}V(e,function(e){var n=e.nodeType;if(n==3&&e.parentNode.tagName!=\"STYLE\")r(e,e.nodeValue);if(n!=1)return;var i=$(e,\"each\");if(i){S(e,t,i);return false}O(e.attributes,function(t){var n=t.name,i=n.split(\"__\")[1];r(e,t.value,{attr:i||n,bool:i});if(i){R(e,n);return false}});if(I(e))return false})}function C(e,o,f){var a=n.observable(this),l=ne(o.opts)||{},p=m(e.tmpl),g=o.parent,h=o.isLoop,b=o.hasImpl,y=U(o.item),w=[],x=[],_=o.root,S=e.fn,C=_.tagName.toLowerCase(),T={},E=[];if(S&&_._tag)_._tag.unmount(true);this.isMounted=false;_.isLoop=h;_._tag=this;K(this,\"_riot_id\",++r);D(this,{parent:g,root:_,opts:l,tags:{}},y);O(_.attributes,function(e){var t=e.value;if(v.hasExpr(t))T[e.name]=t});if(p.innerHTML&&!/^(select|optgroup|table|tbody|tr|col(?:group)?)$/.test(C))p.innerHTML=W(p.innerHTML,f);function $(){var e=b&&h?a:g||a;O(_.attributes,function(t){l[A(t.name)]=v(t.value,e)});O(Object.keys(T),function(t){l[A(t)]=v(T[t],e)})}function I(e){for(var t in y){if(typeof a[t]!==c&&G(a,t))a[t]=e[t]}}function H(){if(!a.parent||!h)return;O(Object.keys(a.parent),function(e){var t=!Q(d,e)&&Q(E,e);if(typeof a[e]===c||t){if(!t)E.push(e);a[e]=a.parent[e]}})}K(this,\"update\",function(e){e=U(e);H();if(e&&typeof y===s){I(e);y=e}D(a,e);$();a.trigger(\"update\",e);M(w,a);ae(function(){a.trigger(\"updated\")});return this});K(this,\"mixin\",function(){O(arguments,function(e){var t;e=typeof e===u?n.mixin(e):e;if(j(e)){t=new e;e=e.prototype}else t=e;O(Object.getOwnPropertyNames(e),function(e){if(e!=\"init\")a[e]=j(t[e])?t[e].bind(a):t[e]});if(t.init)t.init.bind(a)()});return this});K(this,\"mount\",function(){$();if(S)S.call(a,l);N(p,a,w);F(true);if(e.attrs||b){Z(e.attrs,function(e,t){k(_,e,t)});N(a.root,a,w)}if(!a.parent||h)a.update(y);a.trigger(\"before-mount\");if(h&&!b){a.root=_=p.firstChild}else{while(p.firstChild)_.appendChild(p.firstChild);if(_.stub)a.root=_=g.root}if(h)L(a.root,a.parent,null,true);if(!a.parent||a.parent.isMounted){a.isMounted=true;a.trigger(\"mount\")}else a.parent.one(\"mount\",function(){if(!J(a.root)){a.parent.isMounted=a.isMounted=true;a.trigger(\"mount\")}})});K(this,\"unmount\",function(e){var n=_,r=n.parentNode,o;a.trigger(\"before-unmount\");i.splice(i.indexOf(a),1);if(this._virts){O(this._virts,function(e){e.parentNode.removeChild(e)})}if(r){if(g){o=B(g);if(z(o.tags[C]))O(o.tags[C],function(e,t){if(e._riot_id==a._riot_id)o.tags[C].splice(t,1)});else o.tags[C]=t}else while(n.firstChild)n.removeChild(n.firstChild);if(!e)r.removeChild(n);else R(r,\"riot-tag\")}a.trigger(\"unmount\");F();a.off(\"*\");a.isMounted=false;_._tag=null});function F(e){O(x,function(t){t[e?\"mount\":\"unmount\"]()});if(g){var t=e?\"on\":\"off\";if(h)g[t](\"unmount\",a.unmount);else g[t](\"update\",a.update)[t](\"unmount\",a.unmount)}}L(p,this,x)}function T(t,n,r,i){r[t]=function(t){var o=i._parent,f=i._item,a;if(!f)while(o&&!f){f=o._item;o=o._parent}t=t||e.event;if(G(t,\"currentTarget\"))t.currentTarget=r;if(G(t,\"target\"))t.target=t.srcElement;if(G(t,\"which\"))t.which=t.charCode||t.keyCode;t.item=f;if(n.call(i,t)!==true&&!/radio|check/.test(r.type)){if(t.preventDefault)t.preventDefault();t.returnValue=false}if(!t.preventUpdate){a=f?B(o):i;a.update()}}}function E(e,t,n){if(e){e.insertBefore(n,t);e.removeChild(t)}}function M(e,t){O(e,function(e,n){var r=e.dom,i=e.attr,o=v(e.expr,t),u=e.dom.parentNode;if(e.bool)o=o?i:false;else if(o==null)o=\"\";if(u&&u.tagName==\"TEXTAREA\"){o=(\"\"+o).replace(/riot-/g,\"\");u.value=o}if(e.value===o)return;e.value=o;if(!i){r.nodeValue=\"\"+o;return}R(r,i);if(j(o)){T(i,o,r,t)}else if(i==\"if\"){var c=e.stub,l=function(){E(c.parentNode,c,r)},p=function(){E(r.parentNode,r,c)};if(o){if(c){l();r.inStub=false;if(!J(r)){V(r,function(e){if(e._tag&&!e._tag.isMounted)e._tag.isMounted=!!e._tag.trigger(\"mount\")})}}}else{c=e.stub=c||document.createTextNode(\"\");if(r.parentNode)p();else(t.parent||t).one(\"updated\",p);r.inStub=true}}else if(/^(show|hide)$/.test(i)){if(i==\"hide\")o=!o;r.style.display=o?\"\":\"none\"}else if(i==\"value\"){r.value=o}else if(oe(i,f)&&i!=a){if(o)k(r,i.slice(f.length),o)}else{if(e.bool){r[i]=o;if(!o)return}if(o&&o!=0&&typeof o!==s)k(r,i,o)}})}function O(e,t){for(var n=0,r=(e||[]).length,i;n<r;n++){i=e[n];if(i!=null&&t(i,n)===false)n--}return e}function j(e){return typeof e===l||false}function R(e,t){e.removeAttribute(t)}function A(e){return e.replace(/-(\\w)/g,function(e,t){return t.toUpperCase()})}function $(e,t){return e.getAttribute(t)}function k(e,t,n){e.setAttribute(t,n)}function I(e){return e.tagName&&o[$(e,a)||e.tagName.toLowerCase()]}function H(e,t,n){var r=n.tags[t];if(r){if(!z(r))if(r!==e)n.tags[t]=[r];if(!Q(n.tags[t],e))n.tags[t].push(e)}else{n.tags[t]=e}}function F(e,t,n){var r=e.parent,i;if(!r)return;i=r.tags[t];if(z(i))i.splice(n,0,i.splice(i.indexOf(e),1)[0]);else H(e,t,r)}function q(e,t,n,r){var i=new C(e,t,n),o=P(t.root),f=B(r);i.parent=f;i._parent=r;H(i,o,f);if(f!==r)H(i,o,r);t.root.innerHTML=\"\";return i}function B(e){var t=e;while(!I(t.root)){if(!t.parent)break;t=t.parent}return t}function K(e,t,n,r){Object.defineProperty(e,t,D({value:n,enumerable:false,writable:false,configurable:false},r));return e}function P(e){var t=I(e),n=$(e,\"name\"),r=n&&!v.hasExpr(n)?n:t?t.name:e.tagName.toLowerCase();return r}function D(e){var t,n=arguments;for(var r=1;r<n.length;++r){if(t=n[r]){for(var i in t){if(G(e,i))e[i]=t[i]}}}return e}function Q(e,t){return~e.indexOf(t)}function z(e){return Array.isArray(e)||e instanceof Array}function G(e,t){var n=Object.getOwnPropertyDescriptor(e,t);return typeof e[t]===c||n&&n.writable}function U(e){if(!(e instanceof C)&&!(e&&typeof e.trigger==l))return e;var t={};for(var n in e){if(!Q(d,n))t[n]=e[n]}return t}function V(e,t){if(e){if(t(e)===false)return;else{e=e.firstChild;while(e){V(e,t);e=e.nextSibling}}}}function Z(e,t){var n,r=/([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;while(n=r.exec(e)){t(n[1].toLowerCase(),n[2]||n[3]||n[4])}}function J(e){while(e){if(e.inStub)return true;e=e.parentNode}return false}function X(e){return document.createElement(e)}function Y(e,t){var n=X(e);n.innerHTML=t||\"\";return n}function W(e,t){var n=Y(\"div\",e);if(n.querySelector&&n.querySelector(\"yield[from]\")){O(Y(\"div\",t).childNodes,function(e){if(e.nodeType==1&&e.tagName==\"YIELD\"&&e.getAttribute(\"to\")){O(ee('yield[from=\"'+e.getAttribute(\"to\")+'\"]',n),function(t){t.outerHTML=e.innerHTML})}});return n.innerHTML}else return e.replace(/<yield\\s*(?:\\/>|>\\s*<\\/yield\\s*>)/gi,t||\"\")}function ee(e,t){return(t||document).querySelectorAll(e)}function te(e,t){return(t||document).querySelector(e)}function ne(e){function t(){}t.prototype=e;return new t}function re(e){return $(e,\"id\")||$(e,\"name\")}function ie(e,t,n){var r=re(e),i=function(i){if(Q(n,r))return;var o=z(i);if(!i)t[r]=e;else if(!o||o&&!Q(i,e)){if(o)i.push(e);else t[r]=[i,e]}};if(!r)return;if(v.hasExpr(r))t.one(\"updated\",function(){r=re(e);i(t[r])});else i(t[r])}function oe(e,t){return e.slice(0,t.length)===t}var fe=function(){if(!e)return;var t=X(\"style\"),n=te(\"style[type=riot]\");k(t,\"type\",\"text/css\");if(n){n.parentNode.replaceChild(t,n);n=null}else document.getElementsByTagName(\"head\")[0].appendChild(t);return t.styleSheet?function(e){t.styleSheet.cssText+=e}:function(e){t.innerHTML+=e}}();var ae=function(e){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(e||{});function ue(e,t,n){var r=o[t],f=e._innerHTML=e._innerHTML||e.innerHTML;e.innerHTML=\"\";if(r&&e)r=new C(r,{root:e,opts:n},f);if(r&&r.mount){r.mount();if(!Q(i,r))i.push(r)}return r}n.util={brackets:h,tmpl:v};n.mixin=function(){var e={};return function(t,n){if(!n)return e[t];e[t]=n}}();n.tag=function(e,t,n,r,i){if(j(r)){i=r;if(/^[\\w\\-]+\\s?=/.test(n)){r=n;n=\"\"}else r=\"\"}if(n){if(j(n))i=n;else if(fe)fe(n)}o[e]={name:e,tmpl:t,attrs:r,fn:i};return e};n.tag2=function(e,t,n,r,i,f){if(n&&fe)fe(n);o[e]={name:e,tmpl:t,attrs:r,fn:i};return e};n.mount=function(e,t,n){var r,i,f=[];function c(e){var t=\"\";O(e,function(e){t+=\", *[\"+a+'=\"'+e.trim()+'\"]'});return t}function l(){var e=Object.keys(o);return e+c(e)}function p(e){var r;if(e.tagName){if(t&&(!(r=$(e,a))||r!=t))k(e,a,t);var i=ue(e,t||e.getAttribute(a)||e.tagName.toLowerCase(),n);if(i)f.push(i)}else if(e.length)O(e,p)}if(typeof t===s){n=t;t=0}if(typeof e===u){if(e===\"*\")e=i=l();else e+=c(e.split(\",\"));r=e?ee(e):[]}else r=e;if(t===\"*\"){t=i||l();if(r.tagName)r=ee(t,r);else{var d=[];O(r,function(e){d.push(ee(t,e))});r=d}t=0}if(r.tagName)p(r);else O(r,p);return f};n.update=function(){return O(i,function(e){e.update()})};n.Tag=C;var se=function(){var t={none:function(e){return e}};t.javascript=t.none;function n(n,r){var i;switch(n){case\"coffee\":r=\"CoffeeScript\";break;case\"es6\":case\"babel\":r=\"babel\";break;case\"none\":case\"javascript\":return t.none;default:if(!r)r=n;break}i=e[r];if(!i)throw new Error(r+\" parser not found.\");t[n]=i;return i}function r(e,r){return e in t?t[e]:n(e,r)}var i={jade:function(e,t,n){return r(\"jade\").render(e,D({pretty:true,filename:n,doctype:\"html\"},t))}};var o={less:function(e,t,n,i){var o=r(\"less\"),f;o.render(t,D({sync:true,compress:true},n),function(e,t){if(e)throw e;f=t.css});return f},stylus:function(e,t,n,i){var o=r(\"stylus\"),f=r(\"nib\");return f?o(t).use(f()).import(\"nib\").render():o.render(t)}};var f={livescript:function(e,t,n){return r(\"livescript\").compile(e,D({bare:true,header:false},t))},typescript:function(e,t,n){return r(\"typescript\")(e,t).replace(/\\r\\n?/g,\"\\n\")},es6:function(e,t,n){return r(\"es6\").transform(e,D({blacklist:[\"useStrict\",\"strict\",\"react\"],sourceMaps:false,comments:false},t)).code},babel:function(e,t,n){return r(\"babel\").transform(e,D({filename:n||\"\"},t)).code},coffee:function(e,t,n){return r(\"coffee\").compile(e,D({bare:true},t))},none:t.none};f.javascript=f.none;f.coffeescript=f.coffee;return{html:i,css:o,js:f,_req:r}}();n.parsers=se;var ce=function(){function e(e,t){return new RegExp(e,t)}var t=e(\"^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|\"+\"compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|\"+\"multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|\"+\"selected|sortable|truespeed|typemustmatch)$\"),r=[\"style\",\"src\",\"d\"],i=/^(?:input|img|br|wbr|hr|area|base|col|embed|keygen|link|meta|param|source|track)$/,o=/\\s*([-\\w:\\xA0-\\xFF]+)\\s*(?:=\\s*('[^']+'|\"[^\"]+\"|\\S+))?/g,f=/[ \\t]+$/gm;function a(e){return\"'\"+(e?e.replace(/\\\\/g,\"\\\\\\\\\").replace(/'/g,\"\\\\'\").replace(/\\n/g,\"\\\\n\").replace(/\\r/g,\"\\\\r\"):\"\")+\"'\"}function u(e,t,n,r,i,o){var f=\", \",u=\"}\"+(o.length?\", \"+a(o._bp[8]):\"\")+\");\";if(i&&i.slice(-1)!==\"\\n\")u=\"\\n\"+u;return\"riot.tag2('\"+e+\"'\"+f+a(t)+f+a(n)+f+a(r)+\", function(opts) {\\n\"+i+u}function s(e,t){for(var n in t){if(t.hasOwnProperty(n)){e[n]=t[n]}}return e}function c(e,n){var i=[],f,a,u,s=n._bp,c='\"';o.lastIndex=0;e=e.replace(/\\s+/g,\" \");while(f=o.exec(e)){a=f[1].toLowerCase();u=f[2];if(!u){i.push(a)}else{if(u[0]!==c)u=c+(u[0]===\"'\"?u.slice(1,-1):u)+c;if(a===\"type\"&&u.toLowerCase()==='\"number\"'){u=c+s[0]+\"'number'\"+s[1]+c}else if(/\\u0001\\d/.test(u)){if(t.test(a)){a=\"__\"+a}else if(~r.indexOf(a)){a=\"riot-\"+a}}i.push(a+\"=\"+u)}}return i.join(\" \")}function l(e,t,n){var r=n._bp;if(e&&r[4].test(e)){var i=t.expr&&(t.parser||t.type)?_:0,o=h.split(e,0,r),f;for(var a=1;a<o.length;a+=2){f=o[a];if(f[0]===\"^\")f=f.slice(1);else if(i){var u=f[0]===\"=\";f=i(u?f.slice(1):f,t).trim();if(f.slice(-1)===\";\")f=f.slice(0,-1);if(u)f=\"=\"+f}o[a]=\"\u0001\"+(n.push(f.replace(/[\\r\\n]+/g,\" \").trim())-1)+r[1]}e=o.join(\"\")}return e}function p(e,t){if(t.length){e=e.replace(/\\u0001(\\d+)/g,function(e,n){var r=t[n];if(r[0]===\"=\"){r=r.replace(h.R_STRINGS,function(e){return e.replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\")})}return t._bp[0]+r.replace(/\"/g,\"⁗\")})}return e}var d=/<!--(?!>)[\\S\\s]*?-->/g,g=/<([-\\w]+)\\s*([^\"'\\/>]*(?:(?:\"[^\"]*\"|'[^']*'|\\/[^>])[^'\"\\/>]*)*)(\\/?)>/g,v=e(/<pre(?:\\s+[^'\">]+(?:(?:@Q)[^'\">]*)*|\\s*)?>([\\S\\s]*?)<\\/pre\\s*>/.source.replace(\"@Q\",h.R_STRINGS.source),\"gi\");function m(e,t,n){e=l(e,t,n).replace(g,function(e,t,r,o){t=t.toLowerCase();o=o&&!i.test(t)?\"></\"+t:\"\";if(r)t+=\" \"+c(r,n);return\"<\"+t+o+\">\"});if(!t.whitespace){if(/<pre[\\s>]/.test(e)){var r=[];e=e.replace(v,function(e){return r.push(e)&&\"\u0002\"}).trim().replace(/\\s+/g,\" \");if(r.length)e=e.replace(/\\u0002/g,function(e){return r.shift()})}else e=e.trim().replace(/\\s+/g,\" \")}if(t.compact)e=e.replace(/> <([-\\w\\/])/g,\"><$1\");return p(e,n)}function b(e,t,n){if(Array.isArray(t)){n=t;t={}}else{if(!n)n=[];if(!t)t={}}if(!n.__intflag)e=e.replace(/\\r\\n?/g,\"\\n\").replace(d,\"\").replace(f,\"\");if(!n._bp)n._bp=h.array(t.brackets);return m(e,t,n)}var y=e(\"(\"+h.S_QBLOCKS+\")|\"+h.R_MLCOMMS.source+\"|//[^\\r\\n]*\",\"g\"),w=/^([ \\t]*)([$_A-Za-z][$\\w]*)\\s*(\\([^()]*\\)\\s*{)/m;function x(t){var n,r,i=[],o;t=t.replace(y,function(e,t){return t?e:\" \"});while(n=t.match(w)){i.push(RegExp.leftContext);t=RegExp.rightContext;o=f(t);r=!/^(?:if|while|for|switch|catch|function)$/.test(n[2]);if(r)n[0]=n[1]+\"this.\"+n[2]+\" = function\"+n[3];i.push(n[0],t.slice(0,o));t=t.slice(o);if(r&&!/^\\s*.\\s*bind\\b/.test(t))i.push(\".bind(this)\")}return i.length?i.join(\"\")+t:t;function f(t){var n=e(\"([{}])|\"+h.S_QBLOCKS,\"g\"),r=1,i;while(r&&(i=n.exec(t))){if(i[1])i[1]===\"{\"?++r:--r}return r?t.length:n.lastIndex}}function _(e,t,n,r,i){if(!e)return\"\";if(!n)n=t.type;var o=t.parser||(n?se.js[n]:x);if(!o)throw new Error('JS parser not found: \"'+n+'\"');return o(e,r,i).replace(f,\"\")}function S(e,t,n,r){if(typeof t===\"string\"){r=n;n=t;t={}}if(typeof n===\"object\"){r=n;n=\"\"}else if(!r)r={};return _(e,t,n,r.parserOptions,r.url)}var L=e(\"(}|{|^)[ ;]*([^@ ;{}][^{}]*)(?={)|\"+h.R_STRINGS.source,\"g\");function N(e,t){var n=\":scope\";return t.replace(L,function(t,r,i){if(!i)return t;i=i.replace(/[^,]+/g,function(t){var r=t.trim();if(r&&r!==\"from\"&&r!==\"to\"&&r.slice(-1)!==\"%\"){if(r.indexOf(n)<0)r=n+\" \"+r;r=r.replace(n,e)+\",\"+r.replace(n,'[riot-tag=\"'+e+'\"]')}return t.slice(-1)===\" \"?r+\" \":r});return r?r+\" \"+i:i})}function C(e,t,n,r){var i=(r||(r={})).scoped;if(n){if(n===\"scoped-css\"){i=true}else if(se.css[n]){e=se.css[n](t,e,r.parserOpts,r.url)}else if(n!==\"css\"){throw new Error('CSS parser not found: \"'+n+'\"')}}e=e.replace(h.R_MLCOMMS,\"\").replace(/\\s+/g,\" \").trim();if(i){if(!t)throw new Error(\"Can not parse scoped CSS without a tagName\");e=N(t,e)}return e}function T(e,t,n){if(typeof t===\"object\"){n=t;t=\"\"}else if(!n)n={};return C(e,n.tagName,t,n)}var E=/\\stype\\s*=\\s*(?:(['\"])(.+?)\\1|(\\S+))/i,M=/\\s*=\\s*(\"(?:\\\\[\\S\\s]|[^\"\\\\]*)*\"|'(?:\\\\[\\S\\s]|[^'\\\\]*)*'|\\{[^}]+}|\\S+)/.source;function O(e){if(e){var t=e.match(E);e=t&&(t[2]||t[3])}return e?e.replace(\"text/\",\"\"):\"\"}function j(t,n){if(t){var r=e(\"\\\\s\"+n+M,\"i\"),i=t.match(r);t=i&&i[1];if(t)return/^['\"]/.test(t)?t.slice(1,-1):t}return\"\"}function R(e){var t=j(e,\"options\");if(t)t=JSON.parse(t);return t}function A(e,t,n,r){var i=O(n),o=R(n);return _(e,t,i,o,r)}var $=/\\/>\\n|^<(?:\\/[\\w\\-]+\\s*|[\\w\\-]+(?:\\s+(?:[-\\w:\\xA0-\\xFF][\\S\\s]*?)?)?)>\\n/;function k(e){var t,n;if(e[e.length-1]===\">\")return[e,\"\"];t=e.lastIndexOf(\"<\");while(~t){if(n=e.slice(t).match($)){t+=n.index+n[0].length;return[e.slice(0,t),e.slice(t)]}t=e.lastIndexOf(\"<\",t-1)}return[\"\",e]}function I(e,t,n,r){var i=se.html[n];if(!i)throw new Error('Template parser not found: \"'+n+'\"');return i(e,r,t)}var H=e(/^([ \\t]*)<([-\\w]+)(?:\\s+([^'\"\\/>]+(?:(?:@Q|\\/[^>])[^'\"\\/>]*)*)|\\s*)?(?:\\/>|>[ \\t]*\\n?([\\S\\s]*)^\\1<\\/\\2\\s*>|>(.*)<\\/\\2\\s*>)/.source.replace(\"@Q\",h.R_STRINGS.source),\"gim\"),F=/<style(\\s+[^>]*)?>\\n?([^<]*(?:<(?!\\/style\\s*>)[^<]*)*)<\\/style\\s*>/gi,q=e(F.source.replace(/tyle/g,\"cript\"),\"gi\");function B(t,n,r){var i=[],o;if(!n)n={};o=n.exclude||false;function a(e){return!(o&&~o.indexOf(e))}var s=h.array(n.brackets);if(n.template)t=I(t,r,n.template,n.templateOptions);t=t.replace(/\\r\\n?/g,\"\\n\").replace(H,function(t,o,g,h,v,b){var y=\"\",w=\"\",x=\"\",S=[];S._bp=s;S.__intflag=1;g=g.toLowerCase();h=h&&a(\"attribs\")?p(c(l(h,n,S),S),S):\"\";if(b)v=b;if(v&&(v=v.replace(d,\"\"))&&/\\S/.test(v)){if(b){x=a(\"html\")?m(b,n,S):\"\"}else{v=v.replace(e(\"^\"+o,\"gm\"),\"\");v=v.replace(F,a(\"css\")?function(e,t,i){var o={scoped:t&&/\\sscoped(\\s|=|$)/i.test(t),url:r,parserOpts:R(t)};w+=(w?\" \":\"\")+C(i,g,O(t)||n.style,o);return\"\"}:\"\");v=v.replace(q,a(\"js\")?function(e,t,i){y+=(y?\"\\n\":\"\")+A(i,n,t,r);return\"\"}:\"\");var L=k(v.replace(f,\"\"));if(a(\"html\")){v=L[0];if(v)x=m(v,n,S)}if(a(\"js\")){v=L[1];if(/\\S/.test(v))y+=(y?\"\\n\":\"\")+_(v,n,null,null,r)}}}y=/\\S/.test(y)?y.replace(/\\n{3,}/g,\"\\n\\n\"):\"\";if(n.entities){i.push({tagName:g,html:x,css:w,attribs:h,js:y});return\"\"}return u(g,x,w,h,y,S)});if(n.entities)return i;return t}n.util.compiler={compile:B,html:b,css:T,js:S,version:\"v2.3.19\"};return B}();n.compile=function(){var r=e.document,i,o;function f(e,t,n){var r=new XMLHttpRequest;r.onreadystatechange=function(){if(r.readyState===4&&(r.status===200||!r.status&&r.responseText.length))t(r.responseText,n,e)};r.open(\"GET\",e,true);r.send(\"\")}function a(e){var t=r.createElement(\"script\"),n=r.documentElement;t.text=e;n.appendChild(t);n.removeChild(t)}function u(e,t){var n=r.querySelectorAll('script[type=\"riot/tag\"]'),u=n.length;function s(){i.trigger(\"ready\");o=true;if(e)e()}function c(e,t,n){var r=ce(e,t,n);if(n)r+=\"\\n//# sourceURL=\"+n+\".js\";a(r);if(!--u)s()}if(!u)s();else{for(var l=0;l<n.length;++l){var p=n[l],d={template:p.getAttribute(\"template\")},g=p.getAttribute(\"src\");if(t)d=D(d,t);g?f(g,c,d):c(p.innerHTML,d)}}}return function(e,r,s){if(typeof e===\"string\"){if(typeof r===\"object\"){s=r;r=false}if(/^\\s*</.test(e)){var c=ce(e,s);if(!r)a(c);return c}f(e,function(t){var n=ce(t,s,e);a(n);if(r)r(n,t)})}else{if(typeof e===\"function\"){s=r;r=e}else{s=e;r=t}if(o)return r&&r();if(i){if(r)i.on(\"ready\",r)}else{i=n.observable();u(r,s)}}}}();var le=n.mount;n.mount=function(e,t,r){var i;n.compile(function(){i=le(e,t,r)});return i};if(typeof exports===s)module.exports=n;else if(typeof define===l&&typeof define.amd!==c)define(function(){return e.riot=n});else e.riot=n})(typeof window!=\"undefined\"?window:void 0);\n","source":"unrest/bower_components/riot/riot+compiler.min.js","raw":"/* Riot v2.3.12, @license MIT, (c) 2015 Muut Inc. + contributors */\n(function(e,t){\"use strict\";var n={version:\"v2.3.12\",settings:{}},r=0,i=[],o={},f=\"riot-\",a=f+\"tag\",u=\"string\",s=\"object\",c=\"undefined\",l=\"function\",p=/^(?:opt(ion|group)|tbody|col|t[rhd])$/,d=[\"_item\",\"_id\",\"_parent\",\"update\",\"root\",\"mount\",\"unmount\",\"mixin\",\"isMounted\",\"isLoop\",\"tags\",\"parent\",\"opts\",\"trigger\",\"on\",\"off\",\"one\"],g=(e&&e.document||{}).documentMode|0;n.observable=function(e){e=e||{};var t={},n=function(e,t){e.replace(/\\S+/g,t)},r=function(t,n){Object.defineProperty(e,t,{value:n,enumerable:false,writable:false,configurable:false})};r(\"on\",function(r,i){if(typeof i!=\"function\")return e;n(r,function(e,n){(t[e]=t[e]||[]).push(i);i.typed=n>0});return e});r(\"off\",function(r,i){if(r==\"*\")t={};else{n(r,function(e){if(i){var n=t[e];for(var r=0,o;o=n&&n[r];++r){if(o==i)n.splice(r--,1)}}else delete t[e]})}return e});r(\"one\",function(t,n){function r(){e.off(t,r);n.apply(e,arguments)}return e.on(t,r)});r(\"trigger\",function(r){var i=arguments.length-1,o=new Array(i);for(var f=0;f<i;f++){o[f]=arguments[f+1]}n(r,function(n){var r=(t[n]||[]).slice(0);for(var i=0,f;f=r[i];++i){if(f.busy)return;f.busy=1;try{f.apply(e,f.typed?[n].concat(o):o)}catch(a){e.trigger(\"error\",a)}if(r[i]!==f){i--}f.busy=0}if(t.all&&n!=\"all\")e.trigger.apply(e,[\"all\",n].concat(o))});return e});return e};(function(t){if(!e)return;var n=/^.+?\\/+[^\\/]+/,r=\"EventListener\",i=\"remove\"+r,o=\"add\"+r,f=\"hasAttribute\",a=\"replace\",u=\"popstate\",s=\"hashchange\",c=\"trigger\",l=3,p=e,d=document,g=p.history.location||p.location,h=j.prototype,v=d&&d.ontouchstart?\"touchstart\":\"click\",m=false,b=t.observable(),y=false,w,x,_,S,L,N=[],C=0;function T(e){return e.split(/[\\/?#]/)}function E(e,t){var n=new RegExp(\"^\"+t[a](/\\*/g,\"([^/?#]+?)\")[a](/\\.\\./,\".*\")+\"$\"),r=e.match(n);if(r)return r.slice(1)}function M(e,t){var n;return function(){clearTimeout(n);n=setTimeout(e,t)}}function O(e){w=M(I,1);p[o](u,w);p[o](s,w);d[o](v,H);if(e)I(true)}function j(){this.$=[];t.observable(this);b.on(\"stop\",this.s.bind(this));b.on(\"emit\",this.e.bind(this))}function R(e){return e[a](/^\\/|\\/$/,\"\")}function A(e){return typeof e==\"string\"}function $(e){return(e||g.href)[a](n,\"\")}function k(e){return x[0]==\"#\"?(e||g.href).split(x)[1]||\"\":$(e)[a](x,\"\")}function I(e){var t=C==0;if(l<=C)return;C++;N.push(function(){var t=k();if(e||t!=_){b[c](\"emit\",t);_=t}});if(t){while(N.length){N[0]();N.shift()}C=0}}function H(e){if(e.which!=1||e.metaKey||e.ctrlKey||e.shiftKey||e.defaultPrevented)return;var t=e.target;while(t&&t.nodeName!=\"A\")t=t.parentNode;if(!t||t.nodeName!=\"A\"||t[f](\"download\")||!t[f](\"href\")||t.target&&t.target!=\"_self\"||t.href.indexOf(g.href.match(n)[0])==-1)return;if(t.href!=g.href){if(t.href.split(\"#\")[0]==g.href.split(\"#\")[0]||x!=\"#\"&&$(t.href).indexOf(x)!==0||!F(k(t.href),t.title||d.title))return}e.preventDefault()}function F(e,t){t=t||d.title;history.pushState(null,t,x+R(e));d.title=t;y=false;I();return y}h.m=function(e,t){if(A(e)&&(!t||A(t)))F(e,t);else if(t)this.r(e,t);else this.r(\"@\",e)};h.s=function(){this.off(\"*\");this.$=[]};h.e=function(e){this.$.concat(\"@\").some(function(t){var n=(t==\"@\"?S:L)(R(e),R(t));if(typeof n!=\"undefined\"){this[c].apply(null,[t].concat(n));return y=true}},this)};h.r=function(e,t){if(e!=\"@\"){e=\"/\"+R(e);this.$.push(e)}this.on(e,t)};var q=new j;var B=q.m.bind(q);B.create=function(){var e=new j;e.m.stop=e.s.bind(e);return e.m.bind(e)};B.base=function(e){x=e||\"#\";_=k()};B.exec=function(){I(true)};B.parser=function(e,t){if(!e&&!t){S=T;L=E}if(e)S=e;if(t)L=t};B.query=function(){var e={};g.href[a](/[?&](.+?)=([^&]*)/g,function(t,n,r){e[n]=r});return e};B.stop=function(){if(m){p[i](u,w);p[i](s,w);d[i](v,H);b[c](\"stop\");m=false}};B.start=function(e){if(!m){if(document.readyState==\"complete\")O(e);else p[o](\"load\",function(){setTimeout(function(){O(e)},1)});m=true}};B.base();B.parser();t.route=B})(n);var h=function(e){var t=\"g\",r=/\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,i=/\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,o=i.source+\"|\"+/(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source+\"|\"+/\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,f=\"{ }\",a={\"(\":RegExp(\"([()])|\"+o,t),\"[\":RegExp(\"([[\\\\]])|\"+o,t),\"{\":RegExp(\"([{}])|\"+o,t)};var u=e,s,c=[];function l(e){return e}function p(e,n){if(!n)n=c;return new RegExp(e.source.replace(/{/g,n[2]).replace(/}/g,n[3]),e.global?t:\"\")}function d(e){var n,r=e.split(\" \");if(e===f){r[2]=r[0];r[3]=r[1];n=l}else{if(r.length!==2||/[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(e)){throw new Error('Unsupported brackets \"'+e+'\"')}r=r.concat(e.replace(/(?=[[\\]()*+?.^$|])/g,\"\\\\\").split(\" \"));n=p}r[4]=n(r[1].length>1?/{[\\S\\s]*?}/:/{[^}]*}/,r);r[5]=n(/\\\\({|})/g,r);r[6]=n(/(\\\\?)({)/g,r);r[7]=RegExp(\"(\\\\\\\\?)(?:([[({])|(\"+r[3]+\"))|\"+o,t);r[8]=e;return r}function g(e){if(!e)e=f;if(e!==c[8]){c=d(e);s=e===f?l:p;c[9]=s(/^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/);c[10]=s(/(^|[^\\\\]){=[\\S\\s]*?}/);h._rawOffset=c[0].length}u=e}function h(e){return e instanceof RegExp?s(e):c[e]}h.split=function b(e,t,n){if(!n)n=c;var r=[],i,o,f,u,s=n[6];o=f=s.lastIndex=0;while(i=s.exec(e)){u=i.index;if(o){if(i[2]){s.lastIndex=p(i[2],s.lastIndex);continue}if(!i[3])continue}if(!i[1]){l(e.slice(f,u));f=s.lastIndex;s=n[6+(o^=1)];s.lastIndex=f}}if(e&&f<e.length){l(e.slice(f))}return r;function l(e){if(t||o)r.push(e&&e.replace(n[5],\"$1\"));else r.push(e)}function p(t,n){var r,i=a[t],o=1;i.lastIndex=n;while(r=i.exec(e)){if(r[1]&&!(r[1]===t?++o:--o))break}return r?i.lastIndex:e.length}};h.hasExpr=function y(e){return h(4).test(e)};h.loopKeys=function w(e){var t=e.match(h(9));return t?{key:t[1],pos:t[2],val:c[0]+t[3].trim()+c[1]}:{val:e.trim()}};h.array=function x(e){return d(e||u)};var v;function m(e){var t;e=e||{};t=e.brackets;Object.defineProperty(e,\"brackets\",{set:g,get:function(){return u},enumerable:true});v=e;g(t)}Object.defineProperty(h,\"settings\",{set:m,get:function(){return v}});h.settings=typeof n!==\"undefined\"&&n.settings||{};h.set=g;h.R_STRINGS=i;h.R_MLCOMMS=r;h.S_QBLOCKS=o;return h}();var v=function(){var t={};function n(e,n){if(!e)return e;return(t[e]||(t[e]=i(e))).call(n,r)}n.isRaw=function(e){return e[h._rawOffset]===\"=\"};n.haveRaw=function(e){return h(10).test(e)};n.hasExpr=h.hasExpr;n.loopKeys=h.loopKeys;n.errorHandler=null;function r(e,t){if(n.errorHandler){e.riotData={tagName:t&&t.root&&t.root.tagName,_riot_id:t&&t._riot_id};n.errorHandler(e)}}function i(e){var t=a(e);if(t.slice(0,11)!==\"try{return \")t=\"return \"+t;return new Function(\"E\",t+\";\")}var o=RegExp(h.S_QBLOCKS,\"g\"),f=/\\x01(\\d+)~/g;function a(e){var t=[],n,r=h.split(e.replace(/\\u2057/g,'\"'),1);if(r.length>2||r[0]){var i,o,a=[];for(i=o=0;i<r.length;++i){n=r[i];if(n&&(n=i&1?c(n,1,t):'\"'+n.replace(/\\\\/g,\"\\\\\\\\\").replace(/\\r\\n?|\\n/g,\"\\\\n\").replace(/\"/g,'\\\\\"')+'\"'))a[o++]=n}n=o<2?a[0]:\"[\"+a.join(\",\")+'].join(\"\")'}else{n=c(r[1],0,t)}if(t[0])n=n.replace(f,function(e,n){return t[n].replace(/\\r/g,\"\\\\r\").replace(/\\n/g,\"\\\\n\")});return n}var u=/^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\x01(\\d+)~):/,s=/,|([[{(])|$/g;function c(e,t,n){if(e[0]===\"=\")e=e.slice(1);e=e.replace(o,function(e,t){return e.length>2&&!t?\"\u0001\"+(n.push(e)-1)+\"~\":e}).replace(/\\s+/g,\" \").trim().replace(/\\ ?([[\\({},?\\.:])\\ ?/g,\"$1\");if(e){var r=[],i=0,f;while(e&&(f=e.match(u))&&!f.index){var a,s,c=/,|([[{(])|$/g;e=RegExp.rightContext;a=f[2]?n[f[2]].slice(1,-1).trim().replace(/\\s+/g,\" \"):f[1];while(s=(f=c.exec(e))[1])l(s,c);s=e.slice(0,f.index);e=RegExp.rightContext;r[i++]=d(s,1,a)}e=!i?d(e,t):i>1?\"[\"+r.join(\",\")+'].join(\" \").trim()':r[0]}return e;function l(t,n){var r,i=1,o=t===\"(\"?/[()]/g:t===\"[\"?/[[\\]]/g:/[{}]/g;o.lastIndex=n.lastIndex;while(r=o.exec(e)){if(r[0]===t)++i;else if(!--i)break}n.lastIndex=i?e.length:o.lastIndex}}var l='\"in this?this:'+(typeof e!==\"object\"?\"global\":\"window\")+\").\";var p=/[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g;function d(e,t,n){var r;e=e.replace(p,function(e,t,n,i,o){if(n){i=r?0:i+e.length;if(n!==\"this\"&&n!==\"global\"&&n!==\"window\"){e=t+'(\"'+n+l+n;if(i)r=(o=o[i])===\".\"||o===\"(\"||o===\"[\"}else if(i)r=!/^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/.test(o.slice(i))}return e});if(r){e=\"try{return \"+e+\"}catch(e){E(e,this)}\"}if(n){e=(r?\"function(){\"+e+\"}.call(this)\":\"(\"+e+\")\")+'?\"'+n+'\":\"\"'}else if(t){e=\"function(v){\"+(r?e.replace(\"return \",\"v=\"):\"v=(\"+e+\")\")+';return v||v===0?v:\"\"}.call(this)'}return e}n.parse=function(e){return e};return n}();v.version=h.version=\"v2.3.19\";var m=function(e){var t={tr:\"tbody\",th:\"tr\",td:\"tr\",tbody:\"table\",col:\"colgroup\"},n=\"div\";e=e&&e<10;function r(r){var o=r&&r.match(/^\\s*<([-\\w]+)/),f=o&&o[1].toLowerCase(),a=t[f]||n,u=X(a);u.stub=true;if(e&&f&&(o=f.match(p)))i(u,r,f,!!o[1]);else u.innerHTML=r;return u}function i(e,t,r,i){var o=X(n),f=i?\"select>\":\"table>\",a;o.innerHTML=\"<\"+f+t+\"</\"+f;a=te(r,o);if(a)e.appendChild(a)}return r}(g);function b(e,t,n){var r={};r[e.key]=t;if(e.pos)r[e.pos]=n;return r}function y(e,t){var n=t.length,r=e.length;while(n>r){var i=t[--n];t.splice(n,1);i.unmount()}}function w(e,t){Object.keys(e.tags).forEach(function(n){var r=e.tags[n];if(z(r))O(r,function(e){F(e,n,t)});else F(r,n,t)})}function x(e,t,n){var r=e._root;e._virts=[];while(r){var i=r.nextSibling;if(n)t.insertBefore(r,n._root);else t.appendChild(r);e._virts.push(r);r=i}}function _(e,t,n,r){var i=e._root;for(var o=0;o<r;o++){var f=i.nextSibling;t.insertBefore(i,n._root);i=f}}function S(e,t,n){R(e,\"each\");var r=typeof $(e,\"no-reorder\")!==u||R(e,\"no-reorder\"),i=P(e),f=o[i]||{tmpl:e.outerHTML},a=p.test(i),s=e.parentNode,c=document.createTextNode(\"\"),l=I(e),d=/option/gi.test(i),g=[],h=[],m,S=e.tagName==\"VIRTUAL\";n=v.loopKeys(n);s.insertBefore(c,e);t.one(\"before-mount\",function(){e.parentNode.removeChild(e);if(s.stub)s=t.root}).on(\"update\",function(){var u=v(n.val,t),p=document.createDocumentFragment();if(!z(u)){m=u||false;u=m?Object.keys(u).map(function(e){return b(n,e,u[e])}):[]}u.forEach(function(u,c){var d=r&&u instanceof Object,v=h.indexOf(u),y=~v&&d?v:c,L=g[y];u=!m&&n.key?b(n,u,c):u;if(!d&&!L||d&&!~v||!L){L=new C(f,{parent:t,isLoop:true,hasImpl:!!o[i],root:a?s:e.cloneNode(),item:u},e.innerHTML);L.mount();if(S)L._root=L.root.firstChild;if(c==g.length){if(S)x(L,p);else p.appendChild(L.root)}else{if(S)x(L,s,g[c]);else s.insertBefore(L.root,g[c].root);h.splice(c,0,u)}g.splice(c,0,L);y=c}else L.update(u);if(y!==c&&d){if(S)_(L,s,g[c],e.childNodes.length);else s.insertBefore(L.root,g[c].root);if(n.pos)L[n.pos]=c;g.splice(c,0,g.splice(y,1)[0]);h.splice(c,0,h.splice(y,1)[0]);if(!l)w(L,c)}L._item=u;K(L,\"_parent\",t)},true);y(u,g);if(d)s.appendChild(p);else s.insertBefore(p,c);if(l)t.tags[i]=g;h=u.slice()})}function L(e,t,n,r){V(e,function(e){if(e.nodeType==1){e.isLoop=e.isLoop||(e.parentNode&&e.parentNode.isLoop||$(e,\"each\"))?1:0;if(n){var i=I(e);if(i&&!e.isLoop)n.push(q(i,{root:e,parent:t},e.innerHTML,t))}if(!e.isLoop||r)ie(e,t,[])}})}function N(e,t,n){function r(e,t,r){if(v.hasExpr(t)){var i={dom:e,expr:t};n.push(D(i,r))}}V(e,function(e){var n=e.nodeType;if(n==3&&e.parentNode.tagName!=\"STYLE\")r(e,e.nodeValue);if(n!=1)return;var i=$(e,\"each\");if(i){S(e,t,i);return false}O(e.attributes,function(t){var n=t.name,i=n.split(\"__\")[1];r(e,t.value,{attr:i||n,bool:i});if(i){R(e,n);return false}});if(I(e))return false})}function C(e,o,f){var a=n.observable(this),l=ne(o.opts)||{},p=m(e.tmpl),g=o.parent,h=o.isLoop,b=o.hasImpl,y=U(o.item),w=[],x=[],_=o.root,S=e.fn,C=_.tagName.toLowerCase(),T={},E=[];if(S&&_._tag)_._tag.unmount(true);this.isMounted=false;_.isLoop=h;_._tag=this;K(this,\"_riot_id\",++r);D(this,{parent:g,root:_,opts:l,tags:{}},y);O(_.attributes,function(e){var t=e.value;if(v.hasExpr(t))T[e.name]=t});if(p.innerHTML&&!/^(select|optgroup|table|tbody|tr|col(?:group)?)$/.test(C))p.innerHTML=W(p.innerHTML,f);function $(){var e=b&&h?a:g||a;O(_.attributes,function(t){l[A(t.name)]=v(t.value,e)});O(Object.keys(T),function(t){l[A(t)]=v(T[t],e)})}function I(e){for(var t in y){if(typeof a[t]!==c&&G(a,t))a[t]=e[t]}}function H(){if(!a.parent||!h)return;O(Object.keys(a.parent),function(e){var t=!Q(d,e)&&Q(E,e);if(typeof a[e]===c||t){if(!t)E.push(e);a[e]=a.parent[e]}})}K(this,\"update\",function(e){e=U(e);H();if(e&&typeof y===s){I(e);y=e}D(a,e);$();a.trigger(\"update\",e);M(w,a);ae(function(){a.trigger(\"updated\")});return this});K(this,\"mixin\",function(){O(arguments,function(e){var t;e=typeof e===u?n.mixin(e):e;if(j(e)){t=new e;e=e.prototype}else t=e;O(Object.getOwnPropertyNames(e),function(e){if(e!=\"init\")a[e]=j(t[e])?t[e].bind(a):t[e]});if(t.init)t.init.bind(a)()});return this});K(this,\"mount\",function(){$();if(S)S.call(a,l);N(p,a,w);F(true);if(e.attrs||b){Z(e.attrs,function(e,t){k(_,e,t)});N(a.root,a,w)}if(!a.parent||h)a.update(y);a.trigger(\"before-mount\");if(h&&!b){a.root=_=p.firstChild}else{while(p.firstChild)_.appendChild(p.firstChild);if(_.stub)a.root=_=g.root}if(h)L(a.root,a.parent,null,true);if(!a.parent||a.parent.isMounted){a.isMounted=true;a.trigger(\"mount\")}else a.parent.one(\"mount\",function(){if(!J(a.root)){a.parent.isMounted=a.isMounted=true;a.trigger(\"mount\")}})});K(this,\"unmount\",function(e){var n=_,r=n.parentNode,o;a.trigger(\"before-unmount\");i.splice(i.indexOf(a),1);if(this._virts){O(this._virts,function(e){e.parentNode.removeChild(e)})}if(r){if(g){o=B(g);if(z(o.tags[C]))O(o.tags[C],function(e,t){if(e._riot_id==a._riot_id)o.tags[C].splice(t,1)});else o.tags[C]=t}else while(n.firstChild)n.removeChild(n.firstChild);if(!e)r.removeChild(n);else R(r,\"riot-tag\")}a.trigger(\"unmount\");F();a.off(\"*\");a.isMounted=false;_._tag=null});function F(e){O(x,function(t){t[e?\"mount\":\"unmount\"]()});if(g){var t=e?\"on\":\"off\";if(h)g[t](\"unmount\",a.unmount);else g[t](\"update\",a.update)[t](\"unmount\",a.unmount)}}L(p,this,x)}function T(t,n,r,i){r[t]=function(t){var o=i._parent,f=i._item,a;if(!f)while(o&&!f){f=o._item;o=o._parent}t=t||e.event;if(G(t,\"currentTarget\"))t.currentTarget=r;if(G(t,\"target\"))t.target=t.srcElement;if(G(t,\"which\"))t.which=t.charCode||t.keyCode;t.item=f;if(n.call(i,t)!==true&&!/radio|check/.test(r.type)){if(t.preventDefault)t.preventDefault();t.returnValue=false}if(!t.preventUpdate){a=f?B(o):i;a.update()}}}function E(e,t,n){if(e){e.insertBefore(n,t);e.removeChild(t)}}function M(e,t){O(e,function(e,n){var r=e.dom,i=e.attr,o=v(e.expr,t),u=e.dom.parentNode;if(e.bool)o=o?i:false;else if(o==null)o=\"\";if(u&&u.tagName==\"TEXTAREA\"){o=(\"\"+o).replace(/riot-/g,\"\");u.value=o}if(e.value===o)return;e.value=o;if(!i){r.nodeValue=\"\"+o;return}R(r,i);if(j(o)){T(i,o,r,t)}else if(i==\"if\"){var c=e.stub,l=function(){E(c.parentNode,c,r)},p=function(){E(r.parentNode,r,c)};if(o){if(c){l();r.inStub=false;if(!J(r)){V(r,function(e){if(e._tag&&!e._tag.isMounted)e._tag.isMounted=!!e._tag.trigger(\"mount\")})}}}else{c=e.stub=c||document.createTextNode(\"\");if(r.parentNode)p();else(t.parent||t).one(\"updated\",p);r.inStub=true}}else if(/^(show|hide)$/.test(i)){if(i==\"hide\")o=!o;r.style.display=o?\"\":\"none\"}else if(i==\"value\"){r.value=o}else if(oe(i,f)&&i!=a){if(o)k(r,i.slice(f.length),o)}else{if(e.bool){r[i]=o;if(!o)return}if(o&&o!=0&&typeof o!==s)k(r,i,o)}})}function O(e,t){for(var n=0,r=(e||[]).length,i;n<r;n++){i=e[n];if(i!=null&&t(i,n)===false)n--}return e}function j(e){return typeof e===l||false}function R(e,t){e.removeAttribute(t)}function A(e){return e.replace(/-(\\w)/g,function(e,t){return t.toUpperCase()})}function $(e,t){return e.getAttribute(t)}function k(e,t,n){e.setAttribute(t,n)}function I(e){return e.tagName&&o[$(e,a)||e.tagName.toLowerCase()]}function H(e,t,n){var r=n.tags[t];if(r){if(!z(r))if(r!==e)n.tags[t]=[r];if(!Q(n.tags[t],e))n.tags[t].push(e)}else{n.tags[t]=e}}function F(e,t,n){var r=e.parent,i;if(!r)return;i=r.tags[t];if(z(i))i.splice(n,0,i.splice(i.indexOf(e),1)[0]);else H(e,t,r)}function q(e,t,n,r){var i=new C(e,t,n),o=P(t.root),f=B(r);i.parent=f;i._parent=r;H(i,o,f);if(f!==r)H(i,o,r);t.root.innerHTML=\"\";return i}function B(e){var t=e;while(!I(t.root)){if(!t.parent)break;t=t.parent}return t}function K(e,t,n,r){Object.defineProperty(e,t,D({value:n,enumerable:false,writable:false,configurable:false},r));return e}function P(e){var t=I(e),n=$(e,\"name\"),r=n&&!v.hasExpr(n)?n:t?t.name:e.tagName.toLowerCase();return r}function D(e){var t,n=arguments;for(var r=1;r<n.length;++r){if(t=n[r]){for(var i in t){if(G(e,i))e[i]=t[i]}}}return e}function Q(e,t){return~e.indexOf(t)}function z(e){return Array.isArray(e)||e instanceof Array}function G(e,t){var n=Object.getOwnPropertyDescriptor(e,t);return typeof e[t]===c||n&&n.writable}function U(e){if(!(e instanceof C)&&!(e&&typeof e.trigger==l))return e;var t={};for(var n in e){if(!Q(d,n))t[n]=e[n]}return t}function V(e,t){if(e){if(t(e)===false)return;else{e=e.firstChild;while(e){V(e,t);e=e.nextSibling}}}}function Z(e,t){var n,r=/([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;while(n=r.exec(e)){t(n[1].toLowerCase(),n[2]||n[3]||n[4])}}function J(e){while(e){if(e.inStub)return true;e=e.parentNode}return false}function X(e){return document.createElement(e)}function Y(e,t){var n=X(e);n.innerHTML=t||\"\";return n}function W(e,t){var n=Y(\"div\",e);if(n.querySelector&&n.querySelector(\"yield[from]\")){O(Y(\"div\",t).childNodes,function(e){if(e.nodeType==1&&e.tagName==\"YIELD\"&&e.getAttribute(\"to\")){O(ee('yield[from=\"'+e.getAttribute(\"to\")+'\"]',n),function(t){t.outerHTML=e.innerHTML})}});return n.innerHTML}else return e.replace(/<yield\\s*(?:\\/>|>\\s*<\\/yield\\s*>)/gi,t||\"\")}function ee(e,t){return(t||document).querySelectorAll(e)}function te(e,t){return(t||document).querySelector(e)}function ne(e){function t(){}t.prototype=e;return new t}function re(e){return $(e,\"id\")||$(e,\"name\")}function ie(e,t,n){var r=re(e),i=function(i){if(Q(n,r))return;var o=z(i);if(!i)t[r]=e;else if(!o||o&&!Q(i,e)){if(o)i.push(e);else t[r]=[i,e]}};if(!r)return;if(v.hasExpr(r))t.one(\"updated\",function(){r=re(e);i(t[r])});else i(t[r])}function oe(e,t){return e.slice(0,t.length)===t}var fe=function(){if(!e)return;var t=X(\"style\"),n=te(\"style[type=riot]\");k(t,\"type\",\"text/css\");if(n){n.parentNode.replaceChild(t,n);n=null}else document.getElementsByTagName(\"head\")[0].appendChild(t);return t.styleSheet?function(e){t.styleSheet.cssText+=e}:function(e){t.innerHTML+=e}}();var ae=function(e){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(e||{});function ue(e,t,n){var r=o[t],f=e._innerHTML=e._innerHTML||e.innerHTML;e.innerHTML=\"\";if(r&&e)r=new C(r,{root:e,opts:n},f);if(r&&r.mount){r.mount();if(!Q(i,r))i.push(r)}return r}n.util={brackets:h,tmpl:v};n.mixin=function(){var e={};return function(t,n){if(!n)return e[t];e[t]=n}}();n.tag=function(e,t,n,r,i){if(j(r)){i=r;if(/^[\\w\\-]+\\s?=/.test(n)){r=n;n=\"\"}else r=\"\"}if(n){if(j(n))i=n;else if(fe)fe(n)}o[e]={name:e,tmpl:t,attrs:r,fn:i};return e};n.tag2=function(e,t,n,r,i,f){if(n&&fe)fe(n);o[e]={name:e,tmpl:t,attrs:r,fn:i};return e};n.mount=function(e,t,n){var r,i,f=[];function c(e){var t=\"\";O(e,function(e){t+=\", *[\"+a+'=\"'+e.trim()+'\"]'});return t}function l(){var e=Object.keys(o);return e+c(e)}function p(e){var r;if(e.tagName){if(t&&(!(r=$(e,a))||r!=t))k(e,a,t);var i=ue(e,t||e.getAttribute(a)||e.tagName.toLowerCase(),n);if(i)f.push(i)}else if(e.length)O(e,p)}if(typeof t===s){n=t;t=0}if(typeof e===u){if(e===\"*\")e=i=l();else e+=c(e.split(\",\"));r=e?ee(e):[]}else r=e;if(t===\"*\"){t=i||l();if(r.tagName)r=ee(t,r);else{var d=[];O(r,function(e){d.push(ee(t,e))});r=d}t=0}if(r.tagName)p(r);else O(r,p);return f};n.update=function(){return O(i,function(e){e.update()})};n.Tag=C;var se=function(){var t={none:function(e){return e}};t.javascript=t.none;function n(n,r){var i;switch(n){case\"coffee\":r=\"CoffeeScript\";break;case\"es6\":case\"babel\":r=\"babel\";break;case\"none\":case\"javascript\":return t.none;default:if(!r)r=n;break}i=e[r];if(!i)throw new Error(r+\" parser not found.\");t[n]=i;return i}function r(e,r){return e in t?t[e]:n(e,r)}var i={jade:function(e,t,n){return r(\"jade\").render(e,D({pretty:true,filename:n,doctype:\"html\"},t))}};var o={less:function(e,t,n,i){var o=r(\"less\"),f;o.render(t,D({sync:true,compress:true},n),function(e,t){if(e)throw e;f=t.css});return f},stylus:function(e,t,n,i){var o=r(\"stylus\"),f=r(\"nib\");return f?o(t).use(f()).import(\"nib\").render():o.render(t)}};var f={livescript:function(e,t,n){return r(\"livescript\").compile(e,D({bare:true,header:false},t))},typescript:function(e,t,n){return r(\"typescript\")(e,t).replace(/\\r\\n?/g,\"\\n\")},es6:function(e,t,n){return r(\"es6\").transform(e,D({blacklist:[\"useStrict\",\"strict\",\"react\"],sourceMaps:false,comments:false},t)).code},babel:function(e,t,n){return r(\"babel\").transform(e,D({filename:n||\"\"},t)).code},coffee:function(e,t,n){return r(\"coffee\").compile(e,D({bare:true},t))},none:t.none};f.javascript=f.none;f.coffeescript=f.coffee;return{html:i,css:o,js:f,_req:r}}();n.parsers=se;var ce=function(){function e(e,t){return new RegExp(e,t)}var t=e(\"^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|\"+\"compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|\"+\"multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|\"+\"selected|sortable|truespeed|typemustmatch)$\"),r=[\"style\",\"src\",\"d\"],i=/^(?:input|img|br|wbr|hr|area|base|col|embed|keygen|link|meta|param|source|track)$/,o=/\\s*([-\\w:\\xA0-\\xFF]+)\\s*(?:=\\s*('[^']+'|\"[^\"]+\"|\\S+))?/g,f=/[ \\t]+$/gm;function a(e){return\"'\"+(e?e.replace(/\\\\/g,\"\\\\\\\\\").replace(/'/g,\"\\\\'\").replace(/\\n/g,\"\\\\n\").replace(/\\r/g,\"\\\\r\"):\"\")+\"'\"}function u(e,t,n,r,i,o){var f=\", \",u=\"}\"+(o.length?\", \"+a(o._bp[8]):\"\")+\");\";if(i&&i.slice(-1)!==\"\\n\")u=\"\\n\"+u;return\"riot.tag2('\"+e+\"'\"+f+a(t)+f+a(n)+f+a(r)+\", function(opts) {\\n\"+i+u}function s(e,t){for(var n in t){if(t.hasOwnProperty(n)){e[n]=t[n]}}return e}function c(e,n){var i=[],f,a,u,s=n._bp,c='\"';o.lastIndex=0;e=e.replace(/\\s+/g,\" \");while(f=o.exec(e)){a=f[1].toLowerCase();u=f[2];if(!u){i.push(a)}else{if(u[0]!==c)u=c+(u[0]===\"'\"?u.slice(1,-1):u)+c;if(a===\"type\"&&u.toLowerCase()==='\"number\"'){u=c+s[0]+\"'number'\"+s[1]+c}else if(/\\u0001\\d/.test(u)){if(t.test(a)){a=\"__\"+a}else if(~r.indexOf(a)){a=\"riot-\"+a}}i.push(a+\"=\"+u)}}return i.join(\" \")}function l(e,t,n){var r=n._bp;if(e&&r[4].test(e)){var i=t.expr&&(t.parser||t.type)?_:0,o=h.split(e,0,r),f;for(var a=1;a<o.length;a+=2){f=o[a];if(f[0]===\"^\")f=f.slice(1);else if(i){var u=f[0]===\"=\";f=i(u?f.slice(1):f,t).trim();if(f.slice(-1)===\";\")f=f.slice(0,-1);if(u)f=\"=\"+f}o[a]=\"\u0001\"+(n.push(f.replace(/[\\r\\n]+/g,\" \").trim())-1)+r[1]}e=o.join(\"\")}return e}function p(e,t){if(t.length){e=e.replace(/\\u0001(\\d+)/g,function(e,n){var r=t[n];if(r[0]===\"=\"){r=r.replace(h.R_STRINGS,function(e){return e.replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\")})}return t._bp[0]+r.replace(/\"/g,\"⁗\")})}return e}var d=/<!--(?!>)[\\S\\s]*?-->/g,g=/<([-\\w]+)\\s*([^\"'\\/>]*(?:(?:\"[^\"]*\"|'[^']*'|\\/[^>])[^'\"\\/>]*)*)(\\/?)>/g,v=e(/<pre(?:\\s+[^'\">]+(?:(?:@Q)[^'\">]*)*|\\s*)?>([\\S\\s]*?)<\\/pre\\s*>/.source.replace(\"@Q\",h.R_STRINGS.source),\"gi\");function m(e,t,n){e=l(e,t,n).replace(g,function(e,t,r,o){t=t.toLowerCase();o=o&&!i.test(t)?\"></\"+t:\"\";if(r)t+=\" \"+c(r,n);return\"<\"+t+o+\">\"});if(!t.whitespace){if(/<pre[\\s>]/.test(e)){var r=[];e=e.replace(v,function(e){return r.push(e)&&\"\u0002\"}).trim().replace(/\\s+/g,\" \");if(r.length)e=e.replace(/\\u0002/g,function(e){return r.shift()})}else e=e.trim().replace(/\\s+/g,\" \")}if(t.compact)e=e.replace(/> <([-\\w\\/])/g,\"><$1\");return p(e,n)}function b(e,t,n){if(Array.isArray(t)){n=t;t={}}else{if(!n)n=[];if(!t)t={}}if(!n.__intflag)e=e.replace(/\\r\\n?/g,\"\\n\").replace(d,\"\").replace(f,\"\");if(!n._bp)n._bp=h.array(t.brackets);return m(e,t,n)}var y=e(\"(\"+h.S_QBLOCKS+\")|\"+h.R_MLCOMMS.source+\"|//[^\\r\\n]*\",\"g\"),w=/^([ \\t]*)([$_A-Za-z][$\\w]*)\\s*(\\([^()]*\\)\\s*{)/m;function x(t){var n,r,i=[],o;t=t.replace(y,function(e,t){return t?e:\" \"});while(n=t.match(w)){i.push(RegExp.leftContext);t=RegExp.rightContext;o=f(t);r=!/^(?:if|while|for|switch|catch|function)$/.test(n[2]);if(r)n[0]=n[1]+\"this.\"+n[2]+\" = function\"+n[3];i.push(n[0],t.slice(0,o));t=t.slice(o);if(r&&!/^\\s*.\\s*bind\\b/.test(t))i.push(\".bind(this)\")}return i.length?i.join(\"\")+t:t;function f(t){var n=e(\"([{}])|\"+h.S_QBLOCKS,\"g\"),r=1,i;while(r&&(i=n.exec(t))){if(i[1])i[1]===\"{\"?++r:--r}return r?t.length:n.lastIndex}}function _(e,t,n,r,i){if(!e)return\"\";if(!n)n=t.type;var o=t.parser||(n?se.js[n]:x);if(!o)throw new Error('JS parser not found: \"'+n+'\"');return o(e,r,i).replace(f,\"\")}function S(e,t,n,r){if(typeof t===\"string\"){r=n;n=t;t={}}if(typeof n===\"object\"){r=n;n=\"\"}else if(!r)r={};return _(e,t,n,r.parserOptions,r.url)}var L=e(\"(}|{|^)[ ;]*([^@ ;{}][^{}]*)(?={)|\"+h.R_STRINGS.source,\"g\");function N(e,t){var n=\":scope\";return t.replace(L,function(t,r,i){if(!i)return t;i=i.replace(/[^,]+/g,function(t){var r=t.trim();if(r&&r!==\"from\"&&r!==\"to\"&&r.slice(-1)!==\"%\"){if(r.indexOf(n)<0)r=n+\" \"+r;r=r.replace(n,e)+\",\"+r.replace(n,'[riot-tag=\"'+e+'\"]')}return t.slice(-1)===\" \"?r+\" \":r});return r?r+\" \"+i:i})}function C(e,t,n,r){var i=(r||(r={})).scoped;if(n){if(n===\"scoped-css\"){i=true}else if(se.css[n]){e=se.css[n](t,e,r.parserOpts,r.url)}else if(n!==\"css\"){throw new Error('CSS parser not found: \"'+n+'\"')}}e=e.replace(h.R_MLCOMMS,\"\").replace(/\\s+/g,\" \").trim();if(i){if(!t)throw new Error(\"Can not parse scoped CSS without a tagName\");e=N(t,e)}return e}function T(e,t,n){if(typeof t===\"object\"){n=t;t=\"\"}else if(!n)n={};return C(e,n.tagName,t,n)}var E=/\\stype\\s*=\\s*(?:(['\"])(.+?)\\1|(\\S+))/i,M=/\\s*=\\s*(\"(?:\\\\[\\S\\s]|[^\"\\\\]*)*\"|'(?:\\\\[\\S\\s]|[^'\\\\]*)*'|\\{[^}]+}|\\S+)/.source;function O(e){if(e){var t=e.match(E);e=t&&(t[2]||t[3])}return e?e.replace(\"text/\",\"\"):\"\"}function j(t,n){if(t){var r=e(\"\\\\s\"+n+M,\"i\"),i=t.match(r);t=i&&i[1];if(t)return/^['\"]/.test(t)?t.slice(1,-1):t}return\"\"}function R(e){var t=j(e,\"options\");if(t)t=JSON.parse(t);return t}function A(e,t,n,r){var i=O(n),o=R(n);return _(e,t,i,o,r)}var $=/\\/>\\n|^<(?:\\/[\\w\\-]+\\s*|[\\w\\-]+(?:\\s+(?:[-\\w:\\xA0-\\xFF][\\S\\s]*?)?)?)>\\n/;function k(e){var t,n;if(e[e.length-1]===\">\")return[e,\"\"];t=e.lastIndexOf(\"<\");while(~t){if(n=e.slice(t).match($)){t+=n.index+n[0].length;return[e.slice(0,t),e.slice(t)]}t=e.lastIndexOf(\"<\",t-1)}return[\"\",e]}function I(e,t,n,r){var i=se.html[n];if(!i)throw new Error('Template parser not found: \"'+n+'\"');return i(e,r,t)}var H=e(/^([ \\t]*)<([-\\w]+)(?:\\s+([^'\"\\/>]+(?:(?:@Q|\\/[^>])[^'\"\\/>]*)*)|\\s*)?(?:\\/>|>[ \\t]*\\n?([\\S\\s]*)^\\1<\\/\\2\\s*>|>(.*)<\\/\\2\\s*>)/.source.replace(\"@Q\",h.R_STRINGS.source),\"gim\"),F=/<style(\\s+[^>]*)?>\\n?([^<]*(?:<(?!\\/style\\s*>)[^<]*)*)<\\/style\\s*>/gi,q=e(F.source.replace(/tyle/g,\"cript\"),\"gi\");function B(t,n,r){var i=[],o;if(!n)n={};o=n.exclude||false;function a(e){return!(o&&~o.indexOf(e))}var s=h.array(n.brackets);if(n.template)t=I(t,r,n.template,n.templateOptions);t=t.replace(/\\r\\n?/g,\"\\n\").replace(H,function(t,o,g,h,v,b){var y=\"\",w=\"\",x=\"\",S=[];S._bp=s;S.__intflag=1;g=g.toLowerCase();h=h&&a(\"attribs\")?p(c(l(h,n,S),S),S):\"\";if(b)v=b;if(v&&(v=v.replace(d,\"\"))&&/\\S/.test(v)){if(b){x=a(\"html\")?m(b,n,S):\"\"}else{v=v.replace(e(\"^\"+o,\"gm\"),\"\");v=v.replace(F,a(\"css\")?function(e,t,i){var o={scoped:t&&/\\sscoped(\\s|=|$)/i.test(t),url:r,parserOpts:R(t)};w+=(w?\" \":\"\")+C(i,g,O(t)||n.style,o);return\"\"}:\"\");v=v.replace(q,a(\"js\")?function(e,t,i){y+=(y?\"\\n\":\"\")+A(i,n,t,r);return\"\"}:\"\");var L=k(v.replace(f,\"\"));if(a(\"html\")){v=L[0];if(v)x=m(v,n,S)}if(a(\"js\")){v=L[1];if(/\\S/.test(v))y+=(y?\"\\n\":\"\")+_(v,n,null,null,r)}}}y=/\\S/.test(y)?y.replace(/\\n{3,}/g,\"\\n\\n\"):\"\";if(n.entities){i.push({tagName:g,html:x,css:w,attribs:h,js:y});return\"\"}return u(g,x,w,h,y,S)});if(n.entities)return i;return t}n.util.compiler={compile:B,html:b,css:T,js:S,version:\"v2.3.19\"};return B}();n.compile=function(){var r=e.document,i,o;function f(e,t,n){var r=new XMLHttpRequest;r.onreadystatechange=function(){if(r.readyState===4&&(r.status===200||!r.status&&r.responseText.length))t(r.responseText,n,e)};r.open(\"GET\",e,true);r.send(\"\")}function a(e){var t=r.createElement(\"script\"),n=r.documentElement;t.text=e;n.appendChild(t);n.removeChild(t)}function u(e,t){var n=r.querySelectorAll('script[type=\"riot/tag\"]'),u=n.length;function s(){i.trigger(\"ready\");o=true;if(e)e()}function c(e,t,n){var r=ce(e,t,n);if(n)r+=\"\\n//# sourceURL=\"+n+\".js\";a(r);if(!--u)s()}if(!u)s();else{for(var l=0;l<n.length;++l){var p=n[l],d={template:p.getAttribute(\"template\")},g=p.getAttribute(\"src\");if(t)d=D(d,t);g?f(g,c,d):c(p.innerHTML,d)}}}return function(e,r,s){if(typeof e===\"string\"){if(typeof r===\"object\"){s=r;r=false}if(/^\\s*</.test(e)){var c=ce(e,s);if(!r)a(c);return c}f(e,function(t){var n=ce(t,s,e);a(n);if(r)r(n,t)})}else{if(typeof e===\"function\"){s=r;r=e}else{s=e;r=t}if(o)return r&&r();if(i){if(r)i.on(\"ready\",r)}else{i=n.observable();u(r,s)}}}}();var le=n.mount;n.mount=function(e,t,r){var i;n.compile(function(){i=le(e,t,r)});return i};if(typeof exports===s)module.exports=n;else if(typeof define===l&&typeof define.amd!==c)define(function(){return e.riot=n});else e.riot=n})(typeof window!=\"undefined\"?window:void 0);\n","date":"2015-12-17T03:11:20.960Z","updated":"2015-12-15T21:11:22.000Z","path":"unrest/bower_components/riot/riot+compiler.min.js","layout":"false","title":"","comments":1,"_id":"cijth4lap000d0nfwxcwkaub6"},{"_content":"/* Riot v2.3.12, @license MIT, (c) 2015 Muut Inc. + contributors */\n\n;(function(window, undefined) {\n  'use strict';\nvar riot = { version: 'v2.3.12', settings: {} },\n  // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n\n  // counter to give a unique id to all the Tag instances\n  __uid = 0,\n  // tags instances cache\n  __virtualDom = [],\n  // tags implementation cache\n  __tagImpl = {},\n\n  /**\n   * Const\n   */\n  // riot specific prefixes\n  RIOT_PREFIX = 'riot-',\n  RIOT_TAG = RIOT_PREFIX + 'tag',\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n  T_OBJECT = 'object',\n  T_UNDEF  = 'undefined',\n  T_FUNCTION = 'function',\n  // special native tags that cannot be treated like the others\n  SPECIAL_TAGS_REGEX = /^(?:opt(ion|group)|tbody|col|t[rhd])$/,\n  RESERVED_WORDS_BLACKLIST = ['_item', '_id', '_parent', 'update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isLoop', 'tags', 'parent', 'opts', 'trigger', 'on', 'off', 'one'],\n\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (window && window.document || {}).documentMode | 0\n/* istanbul ignore next */\nriot.observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {}\n\n  /**\n   * Private variables and methods\n   */\n\n  var callbacks = {},\n    onEachEvent = function(e, fn) { e.replace(/\\S+/g, fn) },\n    defineProperty = function (key, value) {\n      Object.defineProperty(el, key, {\n        value: value,\n        enumerable: false,\n        writable: false,\n        configurable: false\n      })\n    }\n\n  /**\n   * Listen to the given space separated list of `events` and execute the `callback` each time an event is triggered.\n   * @param  { String } events - events ids\n   * @param  { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('on', function(events, fn) {\n    if (typeof fn != 'function')  return el\n\n    onEachEvent(events, function(name, pos) {\n      (callbacks[name] = callbacks[name] || []).push(fn)\n      fn.typed = pos > 0\n    })\n\n    return el\n  })\n\n  /**\n   * Removes the given space separated list of `events` listeners\n   * @param   { String } events - events ids\n   * @param   { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('off', function(events, fn) {\n    if (events == '*') callbacks = {}\n    else {\n      onEachEvent(events, function(name) {\n        if (fn) {\n          var arr = callbacks[name]\n          for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n            if (cb == fn) arr.splice(i--, 1)\n          }\n        } else delete callbacks[name]\n      })\n    }\n    return el\n  })\n\n  /**\n   * Listen to the given space separated list of `events` and execute the `callback` at most once\n   * @param   { String } events - events ids\n   * @param   { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('one', function(events, fn) {\n    function on() {\n      el.off(events, on)\n      fn.apply(el, arguments)\n    }\n    return el.on(events, on)\n  })\n\n  /**\n   * Execute all callback functions that listen to the given space separated list of `events`\n   * @param   { String } events - events ids\n   * @returns { Object } el\n   */\n\n  defineProperty('trigger', function(events) {\n\n    // getting the arguments\n    // skipping the first one\n    var arglen = arguments.length - 1,\n      args = new Array(arglen)\n    for (var i = 0; i < arglen; i++) {\n      args[i] = arguments[i + 1]\n    }\n\n    onEachEvent(events, function(name) {\n\n      var fns = (callbacks[name] || []).slice(0)\n\n      for (var i = 0, fn; fn = fns[i]; ++i) {\n        if (fn.busy) return\n        fn.busy = 1\n\n        try {\n          fn.apply(el, fn.typed ? [name].concat(args) : args)\n        } catch (e) { el.trigger('error', e) }\n        if (fns[i] !== fn) { i-- }\n        fn.busy = 0\n      }\n\n      if (callbacks.all && name != 'all')\n        el.trigger.apply(el, ['all', name].concat(args))\n\n    })\n\n    return el\n  })\n\n  return el\n\n}\n/* istanbul ignore next */\n;(function(riot) { if (!window) return;\n\n/**\n * Simple client-side router\n * @module riot-route\n */\n\n\nvar RE_ORIGIN = /^.+?\\/+[^\\/]+/,\n  EVENT_LISTENER = 'EventListener',\n  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n  HAS_ATTRIBUTE = 'hasAttribute',\n  REPLACE = 'replace',\n  POPSTATE = 'popstate',\n  HASHCHANGE = 'hashchange',\n  TRIGGER = 'trigger',\n  MAX_EMIT_STACK_LEVEL = 3,\n  win = window,\n  doc = document,\n  loc = win.history.location || win.location, // see html5-history-api\n  prot = Router.prototype, // to minify more\n  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n  started = false,\n  central = riot.observable(),\n  routeFound = false,\n  debouncedEmit,\n  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/)\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var re = new RegExp('^' + filter[REPLACE](/\\*/g, '([^/?#]+?)')[REPLACE](/\\.\\./, '.*') + '$'),\n    args = path.match(re)\n\n  if (args) return args.slice(1)\n}\n\n/**\n * Simple/cheap debounce implementation\n * @param   {function} fn - callback\n * @param   {number} delay - delay in seconds\n * @returns {function} debounced function\n */\nfunction debounce(fn, delay) {\n  var t\n  return function () {\n    clearTimeout(t)\n    t = setTimeout(fn, delay)\n  }\n}\n\n/**\n * Set the window listeners to trigger the routes\n * @param {boolean} autoExec - see route.start\n */\nfunction start(autoExec) {\n  debouncedEmit = debounce(emit, 1)\n  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit)\n  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n  doc[ADD_EVENT_LISTENER](clickEvent, click)\n  if (autoExec) emit(true)\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = []\n  riot.observable(this) // make it observable\n  central.on('stop', this.s.bind(this))\n  central.on('emit', this.e.bind(this))\n}\n\nfunction normalize(path) {\n  return path[REPLACE](/^\\/|\\/$/, '')\n}\n\nfunction isString(str) {\n  return typeof str == 'string'\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href)[REPLACE](RE_ORIGIN, '')\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  return base[0] == '#'\n    ? (href || loc.href).split(base)[1] || ''\n    : getPathFromRoot(href)[REPLACE](base, '')\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel == 0\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return\n\n  emitStackLevel++\n  emitStack.push(function() {\n    var path = getPathFromBase()\n    if (force || path != current) {\n      central[TRIGGER]('emit', path)\n      current = path\n    }\n  })\n  if (isRoot) {\n    while (emitStack.length) {\n      emitStack[0]()\n      emitStack.shift()\n    }\n    emitStackLevel = 0\n  }\n}\n\nfunction click(e) {\n  if (\n    e.which != 1 // not left click\n    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n    || e.defaultPrevented // or default prevented\n  ) return\n\n  var el = e.target\n  while (el && el.nodeName != 'A') el = el.parentNode\n  if (\n    !el || el.nodeName != 'A' // not A tag\n    || el[HAS_ATTRIBUTE]('download') // has download attr\n    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n    || el.target && el.target != '_self' // another window or frame\n    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin\n  ) return\n\n  if (el.href != loc.href) {\n    if (\n      el.href.split('#')[0] == loc.href.split('#')[0] // internal jump\n      || base != '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n    ) return\n  }\n\n  e.preventDefault()\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n * @returns {boolean} - route not found flag\n */\nfunction go(path, title) {\n  title = title || doc.title\n  // browsers ignores the second parameter `title`\n  history.pushState(null, title, base + normalize(path))\n  // so we need to set it manually\n  doc.title = title\n  routeFound = false\n  emit()\n  return routeFound\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n */\nprot.m = function(first, second) {\n  if (isString(first) && (!second || isString(second))) go(first, second)\n  else if (second) this.r(first, second)\n  else this.r('@', first)\n}\n\n/**\n * Stop routing\n */\nprot.s = function() {\n  this.off('*')\n  this.$ = []\n}\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function(path) {\n  this.$.concat('@').some(function(filter) {\n    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))\n    if (typeof args != 'undefined') {\n      this[TRIGGER].apply(null, [filter].concat(args))\n      return routeFound = true // exit from loop\n    }\n  }, this)\n}\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function(filter, action) {\n  if (filter != '@') {\n    filter = '/' + normalize(filter)\n    this.$.push(filter)\n  }\n  this.on(filter, action)\n}\n\nvar mainRouter = new Router()\nvar route = mainRouter.m.bind(mainRouter)\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function() {\n  var newSubRouter = new Router()\n  // stop only this sub-router\n  newSubRouter.m.stop = newSubRouter.s.bind(newSubRouter)\n  // return sub-router's main method\n  return newSubRouter.m.bind(newSubRouter)\n}\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function(arg) {\n  base = arg || '#'\n  current = getPathFromBase() // recalculate current path\n}\n\n/** Exec routing right now **/\nroute.exec = function() {\n  emit(true)\n}\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function(fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER\n    secondParser = DEFAULT_SECOND_PARSER\n  }\n  if (fn) parser = fn\n  if (fn2) secondParser = fn2\n}\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function() {\n  var q = {}\n  loc.href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })\n  return q\n}\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit)\n    win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n    doc[REMOVE_EVENT_LISTENER](clickEvent, click)\n    central[TRIGGER]('stop')\n    started = false\n  }\n}\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    if (document.readyState == 'complete') start(autoExec)\n    // the timeout is needed to solve\n    // a weird safari bug https://github.com/riot/route/issues/33\n    else win[ADD_EVENT_LISTENER]('load', function() {\n      setTimeout(function() { start(autoExec) }, 1)\n    })\n    started = true\n  }\n}\n\n/** Prepare the router **/\nroute.base()\nroute.parser()\n\nriot.route = route\n})(riot)\n/* istanbul ignore next */\n\n/**\n * The riot template engine\n * @version v2.3.19\n */\n\n/**\n * @module brackets\n *\n * `brackets         ` Returns a string or regex based on its parameter\n * `brackets.settings` Mirrors the `riot.settings` object (use brackets.set in new code)\n * `brackets.set     ` Change the current riot brackets\n */\n\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB  = 'g',\n\n    MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n    STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\n    S_QBSRC = STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    DEFAULT = '{ }',\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBSRC, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBSRC, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBSRC, REGLOB)\n    }\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _pairs = []\n\n  function _loopback(re) { return re }\n\n  function _rewrite(re, bp) {\n    if (!bp) bp = _pairs\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create(pair) {\n    var\n      cvt,\n      arr = pair.split(' ')\n\n    if (pair === DEFAULT) {\n      arr[2] = arr[0]\n      arr[3] = arr[1]\n      cvt = _loopback\n    }\n    else {\n      if (arr.length !== 2 || /[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(pair)) {\n        throw new Error('Unsupported brackets \"' + pair + '\"')\n      }\n      arr = arr.concat(pair.replace(/(?=[[\\]()*+?.^$|])/g, '\\\\').split(' '))\n      cvt = _rewrite\n    }\n    arr[4] = cvt(arr[1].length > 1 ? /{[\\S\\s]*?}/ : /{[^}]*}/, arr)\n    arr[5] = cvt(/\\\\({|})/g, arr)\n    arr[6] = cvt(/(\\\\?)({)/g, arr)\n    arr[7] = RegExp('(\\\\\\\\?)(?:([[({])|(' + arr[3] + '))|' + S_QBSRC, REGLOB)\n    arr[8] = pair\n    return arr\n  }\n\n  function _reset(pair) {\n    if (!pair) pair = DEFAULT\n\n    if (pair !== _pairs[8]) {\n      _pairs = _create(pair)\n      _regex = pair === DEFAULT ? _loopback : _rewrite\n      _pairs[9] = _regex(/^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/)\n      _pairs[10] = _regex(/(^|[^\\\\]){=[\\S\\s]*?}/)\n      _brackets._rawOffset = _pairs[0].length\n    }\n    cachedBrackets = pair\n  }\n\n  function _brackets(reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _pairs[reOrIdx]\n  }\n\n  _brackets.split = function split(str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) _bp = _pairs\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6]\n\n    isexpr = start = re.lastIndex = 0\n\n    while (match = re.exec(str)) {\n\n      pos = match.index\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(match[2], re.lastIndex)\n          continue\n        }\n\n        if (!match[3])\n          continue\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos))\n        start = re.lastIndex\n        re = _bp[6 + (isexpr ^= 1)]\n        re.lastIndex = start\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start))\n    }\n\n    return parts\n\n    function unescapeStr(str) {\n      if (tmpl || isexpr)\n        parts.push(str && str.replace(_bp[5], '$1'))\n      else\n        parts.push(str)\n    }\n\n    function skipBraces(ch, pos) {\n      var\n        match,\n        recch = FINDBRACES[ch],\n        level = 1\n      recch.lastIndex = pos\n\n      while (match = recch.exec(str)) {\n        if (match[1] &&\n          !(match[1] === ch ? ++level : --level)) break\n      }\n      return match ? recch.lastIndex : str.length\n    }\n  }\n\n  _brackets.hasExpr = function hasExpr(str) {\n    return _brackets(4).test(str)\n  }\n\n  _brackets.loopKeys = function loopKeys(expr) {\n    var m = expr.match(_brackets(9))\n    return m ?\n      { key: m[1], pos: m[2], val: _pairs[0] + m[3].trim() + _pairs[1] } : { val: expr.trim() }\n  }\n\n  _brackets.array = function array(pair) {\n    return _create(pair || cachedBrackets)\n  }\n\n  var _settings\n  function _setSettings(o) {\n    var b\n    o = o || {}\n    b = o.brackets\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    })\n    _settings = o\n    _reset(b)\n  }\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  })\n\n  /* istanbul ignore next: in the node version riot is not in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}\n  _brackets.set = _reset\n\n  _brackets.R_STRINGS = STRINGS\n  _brackets.R_MLCOMMS = MLCOMMS\n  _brackets.S_QBLOCKS = S_QBSRC\n\n  return _brackets\n\n})()\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\nvar tmpl = (function () {\n\n  var _cache = {}\n\n  function _tmpl(str, data) {\n    if (!str) return str\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.isRaw = function (expr) {\n    return expr[brackets._rawOffset] === \"=\"\n  }\n\n  _tmpl.haveRaw = function (src) {\n    return brackets(10).test(src)\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr\n\n  _tmpl.loopKeys = brackets.loopKeys\n\n  _tmpl.errorHandler = null\n\n  function _logErr(err, ctx) {\n\n    if (_tmpl.errorHandler) {\n\n      err.riotData = {\n        tagName: ctx && ctx.root && ctx.root.tagName,\n        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n      }\n      _tmpl.errorHandler(err)\n    }\n  }\n\n  function _create(str) {\n\n    var expr = _getTmpl(str)\n    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr\n\n    return new Function('E', expr + ';')\n  }\n\n  var\n    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_QBMARK = /\\x01(\\d+)~/g\n\n  function _getTmpl(str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str.replace(/\\u2057/g, '\"'), 1)\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = []\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i]\n\n        if (expr && (expr = i & 1 ?\n\n              _parseExpr(expr, 1, qstr) :\n\n              '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) list[j++] = expr\n\n      }\n\n      expr = j < 2 ? list[0] :\n             '[' + list.join(',') + '].join(\"\")'\n    }\n    else {\n\n      expr = _parseExpr(parts[1], 0, qstr)\n    }\n\n    if (qstr[0])\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      })\n\n    return expr\n  }\n\n  var\n    CS_IDENT = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\x01(\\d+)~):/,\n    RE_BRACE = /,|([[{(])|$/g\n\n  function _parseExpr(expr, asText, qstr) {\n\n    if (expr[0] === \"=\") expr = expr.slice(1)\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? '\\x01' + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1')\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match\n\n      while (expr &&\n            (match = expr.match(CS_IDENT)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g\n\n        expr = RegExp.rightContext\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1]\n\n        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)\n\n        jsb  = expr.slice(0, match.index)\n        expr = RegExp.rightContext\n\n        list[cnt++] = _wrapExpr(jsb, 1, key)\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText) :\n          cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0]\n    }\n    return expr\n\n    function skipBraces(jsb, re) {\n      var\n        match,\n        lv = 1,\n        ir = jsb === '(' ? /[()]/g : jsb === '[' ? /[[\\]]/g : /[{}]/g\n\n      ir.lastIndex = re.lastIndex\n      while (match = ir.exec(expr)) {\n        if (match[0] === jsb) ++lv\n        else if (!--lv) break\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex\n    }\n  }\n\n  // istanbul ignore next: not both\n  var JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').'\n  var JS_VARNAME = /[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g\n\n  function _wrapExpr(expr, asText, key) {\n    var tb\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar\n          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['\n        }\n        else if (pos)\n          tb = !/^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/.test(s.slice(pos))\n      }\n      return match\n    })\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}'\n    }\n\n    if (key) {\n\n      expr = (tb ?\n          'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"'\n    }\n    else if (asText) {\n\n      expr = 'function(v){' + (tb ?\n          expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)'\n    }\n\n    return expr\n  }\n\n  // istanbul ignore next: compatibility fix for beta versions\n  _tmpl.parse = function (s) { return s }\n\n  return _tmpl\n\n})()\n\n  tmpl.version = brackets.version = 'v2.3.19'\n\n\n/*\n  lib/browser/tag/mkdom.js\n\n  Includes hacks needed for the Internet Explorer version 9 and bellow\n\n*/\n// http://kangax.github.io/compat-table/es5/#ie8\n// http://codeplanet.io/dropping-ie8/\n\nvar mkdom = (function (checkIE) {\n\n  var rootEls = {\n      'tr': 'tbody',\n      'th': 'tr',\n      'td': 'tr',\n      'tbody': 'table',\n      'col': 'colgroup'\n    },\n    GENERIC = 'div'\n\n  checkIE = checkIE && checkIE < 10\n\n  // creates any dom element in a div, table, or colgroup container\n  function _mkdom(html) {\n\n    var match = html && html.match(/^\\s*<([-\\w]+)/),\n      tagName = match && match[1].toLowerCase(),\n      rootTag = rootEls[tagName] || GENERIC,\n      el = mkEl(rootTag)\n\n    el.stub = true\n\n    /* istanbul ignore next */\n    if (checkIE && tagName && (match = tagName.match(SPECIAL_TAGS_REGEX)))\n      ie9elem(el, html, tagName, !!match[1])\n    else\n      el.innerHTML = html\n\n    return el\n  }\n\n  // creates tr, th, td, option, optgroup element for IE8-9\n  /* istanbul ignore next */\n  function ie9elem(el, html, tagName, select) {\n\n    var div = mkEl(GENERIC),\n      tag = select ? 'select>' : 'table>',\n      child\n\n    div.innerHTML = '<' + tag + html + '</' + tag\n\n    child = $(tagName, div)\n    if (child)\n      el.appendChild(child)\n\n  }\n  // end ie9elem()\n\n  return _mkdom\n\n})(IE_VERSION)\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n\n  var i = tags.length,\n    j = items.length\n\n  while (i > j) {\n    var t = tags[--i]\n    tags.splice(i, 1)\n    t.unmount()\n  }\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @param   { Object } child - non custom loop tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(child, i) {\n  Object.keys(child.tags).forEach(function(tagName) {\n    var tag = child.tags[tagName]\n    if (isArray(tag))\n      each(tag, function (t) {\n        moveChildTag(t, tagName, i)\n      })\n    else\n      moveChildTag(tag, tagName, i)\n  })\n}\n\n/**\n * Adds the elements for a virtual tag\n * @param { Tag } tag - the tag whose root's children will be inserted or appended\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction addVirtual(tag, src, target) {\n  var el = tag._root\n  tag._virts = []\n  while (el) {\n    var sib = el.nextSibling\n    if (target)\n      src.insertBefore(el, target._root)\n    else\n      src.appendChild(el)\n\n    tag._virts.push(el) // hold for unmounting\n    el = sib\n  }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @param { Tag } tag - first child reference used to start move\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n * @param { Number } len - how many child nodes to move\n */\nfunction moveVirtual(tag, src, target, len) {\n  var el = tag._root\n  for (var i = 0; i < len; i++) {\n    var sib = el.nextSibling\n    src.insertBefore(el, target._root)\n    el = sib\n  }\n}\n\n\n/**\n * Manage tags having the 'each'\n * @param   { Object } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, 'each')\n\n  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n    tagName = getTagName(dom),\n    impl = __tagImpl[tagName] || { tmpl: dom.outerHTML },\n    useRoot = SPECIAL_TAGS_REGEX.test(tagName),\n    root = dom.parentNode,\n    ref = document.createTextNode(''),\n    child = getTag(dom),\n    isOption = /option/gi.test(tagName), // the option tags must be treated differently\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isVirtual = dom.tagName == 'VIRTUAL'\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr)\n\n  // insert a marked where the loop tags will be injected\n  root.insertBefore(ref, dom)\n\n  // clean template code\n  parent.one('before-mount', function () {\n\n    // remove the original DOM node\n    dom.parentNode.removeChild(dom)\n    if (root.stub) root = parent.root\n\n  }).on('update', function () {\n    // get the new items collection\n    var items = tmpl(expr.val, parent),\n      // create a fragment to hold the new DOM nodes to inject in the parent tag\n      frag = document.createDocumentFragment()\n\n\n\n    // object loop. any changes cause full redraw\n    if (!isArray(items)) {\n      hasKeys = items || false\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, key, items[key])\n        }) : []\n    }\n\n    // loop all the new items\n    items.forEach(function(item, i) {\n      // reorder only if the items are objects\n      var _mustReorder = mustReorder && item instanceof Object,\n        oldPos = oldItems.indexOf(item),\n        pos = ~oldPos && _mustReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos]\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item\n\n      // new tag\n      if (\n        !_mustReorder && !tag // with no-reorder we just update the old tags\n        ||\n        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements\n      ) {\n\n        tag = new Tag(impl, {\n          parent: parent,\n          isLoop: true,\n          hasImpl: !!__tagImpl[tagName],\n          root: useRoot ? root : dom.cloneNode(),\n          item: item\n        }, dom.innerHTML)\n\n        tag.mount()\n        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts\n        // this tag must be appended\n        if (i == tags.length) {\n          if (isVirtual)\n            addVirtual(tag, frag)\n          else frag.appendChild(tag.root)\n        }\n        // this tag must be insert\n        else {\n          if (isVirtual)\n            addVirtual(tag, root, tags[i])\n          else root.insertBefore(tag.root, tags[i].root)\n          oldItems.splice(i, 0, item)\n        }\n\n        tags.splice(i, 0, tag)\n        pos = i // handled here so no move\n      } else tag.update(item)\n\n      // reorder the tag if it's not located in its previous position\n      if (pos !== i && _mustReorder) {\n        // update the DOM\n        if (isVirtual)\n          moveVirtual(tag, root, tags[i], dom.childNodes.length)\n        else root.insertBefore(tag.root, tags[i].root)\n        // update the position attribute if it exists\n        if (expr.pos)\n          tag[expr.pos] = i\n        // move the old tag instance\n        tags.splice(i, 0, tags.splice(pos, 1)[0])\n        // move the old item\n        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child) moveNestedTags(tag, i)\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag._item = item\n      // cache the real parent tag internally\n      defineProperty(tag, '_parent', parent)\n\n    }, true) // allow null values\n\n    // remove the redundant tags\n    unmountRedundant(items, tags)\n\n    // insert the new nodes\n    if (isOption) root.appendChild(frag)\n    else root.insertBefore(frag, ref)\n\n    // set the 'tags' property of the parent tag\n    // if child is 'undefined' it means that we don't need to set this property\n    // for example:\n    // we don't need store the `myTag.tags['div']` property if we are looping a div tag\n    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`\n    if (child) parent.tags[tagName] = tags\n\n    // clone the items array\n    oldItems = items.slice()\n\n  })\n\n}\n\n\nfunction parseNamedElements(root, tag, childTags, forceParsingNamed) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = dom.isLoop || (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each')) ? 1 : 0\n\n      // custom child tag\n      if (childTags) {\n        var child = getTag(dom)\n\n        if (child && !dom.isLoop)\n          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))\n      }\n\n      if (!dom.isLoop || forceParsingNamed)\n        setNamed(dom, tag, [])\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (tmpl.hasExpr(val)) {\n      var expr = { dom: dom, expr: val }\n      expressions.push(extend(expr, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    var attr = getAttr(dom, 'each')\n\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n    opts = inherit(conf.opts) || {},\n    dom = mkdom(impl.tmpl),\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    hasImpl = conf.hasImpl,\n    item = cleanUpData(conf.item),\n    expressions = [],\n    childTags = [],\n    root = conf.root,\n    fn = impl.fn,\n    tagName = root.tagName.toLowerCase(),\n    attr = {},\n    propsInSyncWithParent = []\n\n  if (fn && root._tag) root._tag.unmount(true)\n\n  // not yet mounted\n  this.isMounted = false\n  root.isLoop = isLoop\n\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id\n\n  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    var val = el.value\n    // remember attributes with expressions only\n    if (tmpl.hasExpr(val)) attr[el.name] = val\n  })\n\n  if (dom.innerHTML && !/^(select|optgroup|table|tbody|tr|col(?:group)?)$/.test(tagName))\n    // replace all the yield tags with the tag inner html\n    dom.innerHTML = replaceYield(dom.innerHTML, innerHTML)\n\n  // options\n  function updateOpts() {\n    var ctx = hasImpl && isLoop ? self : parent || self\n\n    // update opts from current DOM attributes\n    each(root.attributes, function(el) {\n      opts[toCamel(el.name)] = tmpl(el.value, ctx)\n    })\n    // recover those with expressions\n    each(Object.keys(attr), function(name) {\n      opts[toCamel(name)] = tmpl(attr[name], ctx)\n    })\n  }\n\n  function normalizeData(data) {\n    for (var key in item) {\n      if (typeof self[key] !== T_UNDEF && isWritable(self, key))\n        self[key] = data[key]\n    }\n  }\n\n  function inheritFromParent () {\n    if (!self.parent || !isLoop) return\n    each(Object.keys(self.parent), function(k) {\n      // some properties must be always in sync with the parent tag\n      var mustSync = !contains(RESERVED_WORDS_BLACKLIST, k) && contains(propsInSyncWithParent, k)\n      if (typeof self[k] === T_UNDEF || mustSync) {\n        // track the property to keep in sync\n        // so we can keep it updated\n        if (!mustSync) propsInSyncWithParent.push(k)\n        self[k] = self.parent[k]\n      }\n    })\n  }\n\n  defineProperty(this, 'update', function(data) {\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data)\n    // inherit properties from the parent\n    inheritFromParent()\n    // normalize the tag properties in case an item object was initially passed\n    if (data && typeof item === T_OBJECT) {\n      normalizeData(data)\n      item = data\n    }\n    extend(self, data)\n    updateOpts()\n    self.trigger('update', data)\n    update(expressions, self)\n    // the updated event will be triggered\n    // once the DOM will be ready and all the reflow are completed\n    // this is useful if you want to get the \"real\" root properties\n    // 4 ex: root.offsetWidth ...\n    rAF(function() { self.trigger('updated') })\n    return this\n  })\n\n  defineProperty(this, 'mixin', function() {\n    each(arguments, function(mix) {\n      var instance\n\n      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix()\n        // save the prototype to loop it afterwards\n        mix = mix.prototype\n      } else instance = mix\n\n      // loop the keys in the function prototype or the all object keys\n      each(Object.getOwnPropertyNames(mix), function(key) {\n        // bind methods to self\n        if (key != 'init')\n          self[key] = isFunction(instance[key]) ?\n                        instance[key].bind(self) :\n                        instance[key]\n      })\n\n      // init method will be called automatically\n      if (instance.init) instance.init.bind(self)()\n    })\n    return this\n  })\n\n  defineProperty(this, 'mount', function() {\n\n    updateOpts()\n\n    // initialiation\n    if (fn) fn.call(self, opts)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    // mount the child tags\n    toggle(true)\n\n    // update the root adding custom attributes coming from the compiler\n    // it fixes also #1087\n    if (impl.attrs || hasImpl) {\n      walkAttributes(impl.attrs, function (k, v) { setAttr(root, k, v) })\n      parseExpressions(self.root, self, expressions)\n    }\n\n    if (!self.parent || isLoop) self.update(item)\n\n    // internal use only, fixes #403\n    self.trigger('before-mount')\n\n    if (isLoop && !hasImpl) {\n      // update the root attribute for the looped elements\n      self.root = root = dom.firstChild\n\n    } else {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n      if (root.stub) self.root = root = parent.root\n    }\n\n    // parse the named dom nodes in the looped child\n    // adding them to the parent as well\n    if (isLoop)\n      parseNamedElements(self.root, self.parent, null, true)\n\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent || self.parent.isMounted) {\n      self.isMounted = true\n      self.trigger('mount')\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() {\n      // avoid to trigger the `mount` event for the tags\n      // not visible included in an if statement\n      if (!isInStub(self.root)) {\n        self.parent.isMounted = self.isMounted = true\n        self.trigger('mount')\n      }\n    })\n  })\n\n\n  defineProperty(this, 'unmount', function(keepRootTag) {\n    var el = root,\n      p = el.parentNode,\n      ptag\n\n    self.trigger('before-unmount')\n\n    // remove this tag instance from the global virtualDom variable\n    __virtualDom.splice(__virtualDom.indexOf(self), 1)\n\n    if (this._virts) {\n      each(this._virts, function(v) {\n        v.parentNode.removeChild(v)\n      })\n    }\n\n    if (p) {\n\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent)\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (isArray(ptag.tags[tagName]))\n          each(ptag.tags[tagName], function(tag, i) {\n            if (tag._riot_id == self._riot_id)\n              ptag.tags[tagName].splice(i, 1)\n          })\n        else\n          // otherwise just delete the tag instance\n          ptag.tags[tagName] = undefined\n      }\n\n      else\n        while (el.firstChild) el.removeChild(el.firstChild)\n\n      if (!keepRootTag)\n        p.removeChild(el)\n      else\n        // the riot-tag attribute isn't needed anymore, remove it\n        remAttr(p, 'riot-tag')\n    }\n\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    self.isMounted = false\n    // somehow ie8 does not like `delete root._tag`\n    root._tag = null\n\n  })\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (parent) {\n      var evt = isMount ? 'on' : 'off'\n\n      // the loop tags will be always in sync with the parent automatically\n      if (isLoop)\n        parent[evt]('unmount', self.unmount)\n      else\n        parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n    }\n  }\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n}\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n\n  dom[name] = function(e) {\n\n    var ptag = tag._parent,\n      item = tag._item,\n      el\n\n    if (!item)\n      while (ptag && !item) {\n        item = ptag._item\n        ptag = ptag._parent\n      }\n\n    // cross browser event fix\n    e = e || window.event\n\n    // override the event properties\n    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n    if (isWritable(e, 'target')) e.target = e.srcElement\n    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      if (e.preventDefault) e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      el = item ? getImmediateCustomParentTag(ptag) : tag\n      el.update()\n    }\n\n  }\n\n}\n\n\n/**\n * Insert a DOM node replacing another one (used by if- attribute)\n * @param   { Object } root - parent node\n * @param   { Object } node - node replaced\n * @param   { Object } before - node added\n */\nfunction insertTo(root, node, before) {\n  if (root) {\n    root.insertBefore(before, node)\n    root.removeChild(node)\n  }\n}\n\n/**\n * Update the expressions in a Tag instance\n * @param   { Array } expressions - expression that must be re evaluated\n * @param   { Tag } tag - tag instance\n */\nfunction update(expressions, tag) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n      attrName = expr.attr,\n      value = tmpl(expr.expr, tag),\n      parent = expr.dom.parentNode\n\n    if (expr.bool)\n      value = value ? attrName : false\n    else if (value == null)\n      value = ''\n\n    // leave out riot- prefixes from strings inside textarea\n    // fix #815: any value -> string\n    if (parent && parent.tagName == 'TEXTAREA') {\n      value = ('' + value).replace(/riot-/g, '')\n      // change textarea's value\n      parent.value = value\n    }\n\n    // no change\n    if (expr.value === value) return\n    expr.value = value\n\n    // text node\n    if (!attrName) {\n      dom.nodeValue = '' + value    // #815 related\n      return\n    }\n\n    // remove original attribute\n    remAttr(dom, attrName)\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, tag)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub,\n        add = function() { insertTo(stub.parentNode, stub, dom) },\n        remove = function() { insertTo(dom.parentNode, dom, stub) }\n\n      // add to DOM\n      if (value) {\n        if (stub) {\n          add()\n          dom.inStub = false\n          // avoid to trigger the mount event if the tags is not visible yet\n          // maybe we can optimize this avoiding to mount the tag at all\n          if (!isInStub(dom)) {\n            walk(dom, function(el) {\n              if (el._tag && !el._tag.isMounted) el._tag.isMounted = !!el._tag.trigger('mount')\n            })\n          }\n        }\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        // if the parentNode is defined we can easily replace the tag\n        if (dom.parentNode)\n          remove()\n        // otherwise we need to wait the updated event\n        else (tag.parent || tag).one('updated', remove)\n\n        dom.inStub = true\n      }\n    // show / hide\n    } else if (/^(show|hide)$/.test(attrName)) {\n      if (attrName == 'hide') value = !value\n      dom.style.display = value ? '' : 'none'\n\n    // field value\n    } else if (attrName == 'value') {\n      dom.value = value\n\n    // <img src=\"{ expr }\">\n    } else if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n      if (value)\n        setAttr(dom, attrName.slice(RIOT_PREFIX.length), value)\n\n    } else {\n      if (expr.bool) {\n        dom[attrName] = value\n        if (!value) return\n      }\n\n      if (value && value != 0 && typeof value !== T_OBJECT)\n        setAttr(dom, attrName, value)\n\n    }\n\n  })\n\n}\n/**\n * Loops an array\n * @param   { Array } els - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(els, fn) {\n  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n    el = els[i]\n    // return false -> remove current item during loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\n/**\n * Detect if the argument passed is a function\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isFunction(v) {\n  return typeof v === T_FUNCTION || false   // avoid IE problems\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } string - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(string) {\n  return string.replace(/-(\\w)/g, function(_, c) {\n    return c.toUpperCase()\n  })\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  dom.setAttribute(name, val)\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]\n}\n/**\n * Add a child tag to its parent into the `tags` object\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the new tag will be stored\n * @param   { Object } parent - tag instance where the new child tag will be included\n */\nfunction addChildTag(tag, tagName, parent) {\n  var cachedTag = parent.tags[tagName]\n\n  // if there are multiple children tags having the same name\n  if (cachedTag) {\n    // if the parent tags property is not yet an array\n    // create it adding the first cached tag\n    if (!isArray(cachedTag))\n      // don't add the same tag twice\n      if (cachedTag !== tag)\n        parent.tags[tagName] = [cachedTag]\n    // add the new nested tag to the array\n    if (!contains(parent.tags[tagName], tag))\n      parent.tags[tagName].push(tag)\n  } else {\n    parent.tags[tagName] = tag\n  }\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tag, tagName, newPos) {\n  var parent = tag.parent,\n    tags\n  // no parent no move\n  if (!parent) return\n\n  tags = parent.tags[tagName]\n\n  if (isArray(tags))\n    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])\n  else addChildTag(tag, tagName, parent)\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag(child, opts, innerHTML),\n    tagName = getTagName(opts.root),\n    ptag = getImmediateCustomParentTag(parent)\n  // fix for the parent attribute in the looped elements\n  tag.parent = ptag\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag._parent = parent\n\n  // add this tag to the custom parent tag\n  addChildTag(tag, tagName, ptag)\n  // and also to the real parent tag\n  if (ptag !== parent)\n    addChildTag(tag, tagName, parent)\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = ''\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag\n  while (!getTag(ptag.root)) {\n    if (!ptag.parent) break\n    ptag = ptag.parent\n  }\n  return ptag\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n* @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: false\n  }, options))\n  return el\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom) {\n  var child = getTag(dom),\n    namedTag = getAttr(dom, 'name'),\n    tagName = namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n\n  return tagName\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          src[key] = obj[key]\n      }\n    }\n  }\n  return src\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } arr - target array\n * @param   { * } item - item to test\n * @returns { Boolean } Does 'arr' contain 'item'?\n */\nfunction contains(arr, item) {\n  return ~arr.indexOf(item)\n}\n\n/**\n * Check whether an object is a kind of array\n * @param   { * } a - anything\n * @returns {Boolean} is 'a' an array?\n */\nfunction isArray(a) { return Array.isArray(a) || a instanceof Array }\n\n/**\n * Detect whether a property of an object could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } is this property writable?\n */\nfunction isWritable(obj, key) {\n  var props = Object.getOwnPropertyDescriptor(obj, key)\n  return typeof obj[key] === T_UNDEF || props && props.writable\n}\n\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION)) return data\n\n  var o = {}\n  for (var key in data) {\n    if (!contains(RESERVED_WORDS_BLACKLIST, key))\n      o[key] = data[key]\n  }\n  return o\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n */\nfunction walk(dom, fn) {\n  if (dom) {\n    // stop the recursion\n    if (fn(dom) === false) return\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttributes(html, fn) {\n  var m,\n    re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\n  while (m = re.exec(html)) {\n    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n  }\n}\n\n/**\n * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n * @param   { Object }  dom - DOM node we want to parse\n * @returns { Boolean } -\n */\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub) return true\n    dom = dom.parentNode\n  }\n  return false\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name) {\n  return document.createElement(name)\n}\n\n/**\n * Create a generic DOM node, and fill it with innerHTML\n * @param   { String } name - name of the DOM node we want to create\n * @param   { String } innerHTML - innerHTML of the new DOM\n * @returns { Object } DOM node just created\n */\nfunction mkElWithInnerHTML(name, innerHTML) {\n  var el = mkEl(name)\n  el.innerHTML = innerHTML || ''\n  return el\n}\n\n/**\n * Replace the yield tag from any tag template with the innerHTML of the\n * original tag in the page\n * @param   { String } tmpl - tag implementation template\n * @param   { String } innerHTML - original content of the tag in the DOM\n * @returns { String } tag template updated without the yield tag\n */\nfunction replaceYield(tmpl, innerHTML) {\n  var tmplElement = mkElWithInnerHTML('div', tmpl)\n  // if ($('yield[from]'.tmplElement)) { // this issues test errors\n  if (tmplElement.querySelector && tmplElement.querySelector('yield[from]')) { // code coverage path not taken (?)\n    // yield to(s) must be direct children from innerHTML(root), all other tags are ignored\n    each(mkElWithInnerHTML('div', innerHTML).childNodes, function(toYield) {\n      if (toYield.nodeType == 1 && toYield.tagName == 'YIELD' && toYield.getAttribute('to')) {\n        // replace all yield[from]\n        each($$('yield[from=\"'+toYield.getAttribute('to')+'\"]', tmplElement), function(fromYield) {\n          fromYield.outerHTML = toYield.innerHTML\n        })\n      }\n    })\n    return tmplElement.innerHTML\n  } else\n    // just replace yield in tmpl with the innerHTML\n    return tmpl.replace(/<yield\\s*(?:\\/>|>\\s*<\\/yield\\s*>)/gi, innerHTML || '')\n}\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Simple object prototypal inheritance\n * @param   { Object } parent - parent object\n * @returns { Object } child instance\n */\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n\n/**\n * Get the name property needed to identify a DOM node in riot\n * @param   { Object } dom - DOM node we need to parse\n * @returns { String | undefined } give us back a string to identify this dom node\n */\nfunction getNamedKey(dom) {\n  return getAttr(dom, 'id') || getAttr(dom, 'name')\n}\n\n/**\n * Set the named properties of a tag element\n * @param { Object } dom - DOM node we need to parse\n * @param { Object } parent - tag instance where the named dom element will be eventually added\n * @param { Array } keys - list of all the tag instance properties\n */\nfunction setNamed(dom, parent, keys) {\n  // get the key value we want to add to the tag instance\n  var key = getNamedKey(dom),\n    // add the node detected to a tag instance using the named property\n    add = function(value) {\n      // avoid to override the tag properties already set\n      if (contains(keys, key)) return\n      // check whether this value is an array\n      var isArr = isArray(value)\n      // if the key was never set\n      if (!value)\n        // set it once on the tag instance\n        parent[key] = dom\n      // if it was an array and not yet set\n      else if (!isArr || isArr && !contains(value, dom)) {\n        // add the dom node into the array\n        if (isArr)\n          value.push(dom)\n        else\n          parent[key] = [value, dom]\n      }\n    }\n\n  // skip the elements with no named properties\n  if (!key) return\n\n  // check whether this key has been already evaluated\n  if (tmpl.hasExpr(key))\n    // wait the first updated event only once\n    parent.one('updated', function() {\n      key = getNamedKey(dom)\n      add(parent[key])\n    })\n  else\n    add(parent[key])\n\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } src - source string\n * @param   { String } str - test string\n * @returns { Boolean } -\n */\nfunction startsWith(src, str) {\n  return src.slice(0, str.length) === str\n}\n\n/**\n * Function needed to inject in runtime the custom tags css\n */\nvar injectStyle = (function() {\n\n  if (!window) return // skip injection on the server\n\n  // create the style node\n  var styleNode = mkEl('style'),\n    placeholder = $('style[type=riot]')\n\n  setAttr(styleNode, 'type', 'text/css')\n\n  // inject the new node into the DOM -- in head\n  if (placeholder) {\n    placeholder.parentNode.replaceChild(styleNode, placeholder)\n    placeholder = null\n  }\n  else document.getElementsByTagName('head')[0].appendChild(styleNode)\n\n  /**\n   * This is the function exported that will be used to update the style tag just created\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @param   { String } css [description]\n   */\n  return styleNode.styleSheet ?\n    function (css) { styleNode.styleSheet.cssText += css } :\n    function (css) { styleNode.innerHTML += css }\n\n})()\n\n/**\n * requestAnimationFrame polyfill\n */\nvar rAF = (function(w) {\n  return  w.requestAnimationFrame       ||\n          w.webkitRequestAnimationFrame ||\n          w.mozRequestAnimationFrame    ||\n          function(cb) { setTimeout(cb, 1000 / 60) }\n})(window || {})\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts) {\n  var tag = __tagImpl[tagName],\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    // add this tag to the virtualDom variable\n    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)\n  }\n\n  return tag\n}\n/**\n * Riot public api\n */\n\n// share methods for other riot parts, e.g. compiler\nriot.util = { brackets: brackets, tmpl: tmpl }\n\n/**\n * Create a mixin that could be globally shared across all the tags\n */\nriot.mixin = (function() {\n  var mixins = {}\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String } name - mixin name\n   * @param   { Object } mixin - mixin logic\n   * @returns { Object } the mixin logic\n   */\n  return function(name, mixin) {\n    if (!mixin) return mixins[name]\n    mixins[name] = mixin\n  }\n\n})()\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nriot.tag = function(name, html, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css\n      css = ''\n    } else attrs = ''\n  }\n  if (css) {\n    if (isFunction(css)) fn = css\n    else if (injectStyle) injectStyle(css)\n  }\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @param   { string }  [bpair] - brackets used in the compilation\n * @returns { String } name/id of the tag just created\n */\nriot.tag2 = function(name, html, css, attrs, fn, bpair) {\n  if (css && injectStyle) injectStyle(css)\n  //if (bpair) riot.settings.brackets = bpair\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { String } selector - tag DOM selector\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nriot.mount = function(selector, tagName, opts) {\n\n  var els,\n    allTags,\n    tags = []\n\n  // helper functions\n\n  function addRiotTags(arr) {\n    var list = ''\n    each(arr, function (e) {\n      list += ', *[' + RIOT_TAG + '=\"' + e.trim() + '\"]'\n    })\n    return list\n  }\n\n  function selectAllTags() {\n    var keys = Object.keys(__tagImpl)\n    return keys + addRiotTags(keys)\n  }\n\n  function pushTags(root) {\n    var last\n\n    if (root.tagName) {\n      if (tagName && (!(last = getAttr(root, RIOT_TAG)) || last != tagName))\n        setAttr(root, RIOT_TAG, tagName)\n\n      var tag = mountTo(root, tagName || root.getAttribute(RIOT_TAG) || root.tagName.toLowerCase(), opts)\n\n      if (tag) tags.push(tag)\n    } else if (root.length)\n      each(root, pushTags)   // assume nodeList\n\n  }\n\n  // ----- mount code -----\n\n  if (typeof tagName === T_OBJECT) {\n    opts = tagName\n    tagName = 0\n  }\n\n  // crawl the DOM to find the tag\n  if (typeof selector === T_STRING) {\n    if (selector === '*')\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selectAllTags()\n    else\n      // or just the ones named like the selector\n      selector += addRiotTags(selector.split(','))\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    els = selector ? $$(selector) : []\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    els = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectAllTags()\n    // if the root els it's just a single tag\n    if (els.tagName)\n      els = $$(tagName, els)\n    else {\n      // select all the children for all the different root elements\n      var nodeList = []\n      each(els, function (_el) {\n        nodeList.push($$(tagName, _el))\n      })\n      els = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  if (els.tagName)\n    pushTags(els)\n  else\n    each(els, pushTags)\n\n  return tags\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nriot.update = function() {\n  return each(__virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n/**\n * Export the Tag constructor\n */\nriot.Tag = Tag\n/* istanbul ignore next */\n\n/**\n * @module parsers\n */\nvar parsers = (function () {\n  var _mods = {\n    none: function (js) {\n      return js\n    }\n  }\n  _mods.javascript = _mods.none\n\n  function _try(name, req) {  //eslint-disable-line complexity\n    var parser\n\n    switch (name) {\n    case 'coffee':\n      req = 'CoffeeScript'\n      break\n    case 'es6':\n    case 'babel':\n      req = 'babel'\n      break\n    case 'none':\n    case 'javascript':\n      return _mods.none\n    default:\n      if (!req) req = name\n      break\n    }\n    parser = window[req]\n\n    if (!parser)\n      throw new Error(req + ' parser not found.')\n    _mods[name] = parser\n\n    return parser\n  }\n\n  function _req(name, req) {\n    return name in _mods ? _mods[name] : _try(name, req)\n  }\n\n  var _html = {\n    jade: function (html, opts, url) {\n      return _req('jade').render(html, extend({\n        pretty: true,\n        filename: url,\n        doctype: 'html'\n      }, opts))\n    }\n  }\n\n  var _css = {\n    less: function(tag, css, opts, url) {\n      var less = _req('less'),\n        ret\n\n      less.render(css, extend({\n        sync: true,\n        compress: true\n      }, opts), function (err, result) {\n        // istanbul ignore next\n        if (err) throw err\n        ret = result.css\n      })\n      return ret\n    },\n    stylus: function (tag, css, opts, url) {\n      var\n        stylus = _req('stylus'), nib = _req('nib')\n      /* istanbul ignore next: can't run both */\n      return nib ?\n        stylus(css).use(nib()).import('nib').render() : stylus.render(css)\n    }\n  }\n\n  var _js = {\n    livescript: function (js, opts, url) {\n      return _req('livescript').compile(js, extend({bare: true, header: false}, opts))\n    },\n    typescript: function (js, opts, url) {\n      return _req('typescript')(js, opts).replace(/\\r\\n?/g, '\\n')\n    },\n    es6: function (js, opts, url) {\n      return _req('es6').transform(js, extend({\n        blacklist: ['useStrict', 'strict', 'react'], sourceMaps: false, comments: false\n      }, opts)).code\n    },\n    babel: function (js, opts, url) {\n      // istanbul ignore next: url empty if comming from expression\n      return _req('babel').transform(js,\n        extend({\n          filename: url || ''\n        }, opts)\n      ).code\n    },\n    coffee: function (js, opts, url) {\n      return _req('coffee').compile(js, extend({bare: true}, opts))\n    },\n    none: _mods.none\n  }\n\n  _js.javascript   = _js.none\n  _js.coffeescript = _js.coffee\n\n  return {\n    html: _html,\n    css: _css,\n    js: _js,\n    _req: _req}\n\n})()\n\nriot.parsers = parsers\n\n/**\n * Compiler for riot custom tags\n * @version v2.3.19\n */\nvar compile = (function () {\n\n  function _regEx(str, opt) { return new RegExp(str, opt) }\n\n  var\n\n    BOOL_ATTRS = _regEx(\n      '^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|' +\n      'compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|' +\n      'multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|' +\n      'selected|sortable|truespeed|typemustmatch)$'),\n\n    RIOT_ATTRS = ['style', 'src', 'd'],\n\n    VOID_TAGS  = /^(?:input|img|br|wbr|hr|area|base|col|embed|keygen|link|meta|param|source|track)$/,\n\n    HTML_ATTR  = /\\s*([-\\w:\\xA0-\\xFF]+)\\s*(?:=\\s*('[^']+'|\"[^\"]+\"|\\S+))?/g,\n\n    TRIM_TRAIL = /[ \\t]+$/gm\n\n  function q(s) {\n    return \"'\" + (s ? s\n      .replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\").replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r') :\n      '') + \"'\"\n  }\n\n  function mktag(name, html, css, attrs, js, pcex) {\n    var\n      c = ', ',\n      s = '}' + (pcex.length ? ', ' + q(pcex._bp[8]) : '') + ');'\n\n    if (js && js.slice(-1) !== '\\n') s = '\\n' + s\n\n    return 'riot.tag2(\\'' + name + \"'\" + c + q(html) + c + q(css) + c + q(attrs) +\n           ', function(opts) {\\n' + js + s\n  }\n\n  function extend(obj, props) {\n    for (var prop in props) {\n      /* istanbul ignore next */\n      if (props.hasOwnProperty(prop)) {\n        obj[prop] = props[prop]\n      }\n    }\n    return obj\n  }\n\n  function parseAttrs(str, pcex) {\n    var\n      list = [],\n      match,\n      k, v,\n      _bp = pcex._bp,\n      DQ = '\"'\n\n    HTML_ATTR.lastIndex = 0\n\n    str = str.replace(/\\s+/g, ' ')\n\n    while (match = HTML_ATTR.exec(str)) {\n\n      k = match[1].toLowerCase()\n      v = match[2]\n\n      if (!v) {\n        list.push(k)\n      }\n      else {\n\n        if (v[0] !== DQ)\n          v = DQ + (v[0] === \"'\" ? v.slice(1, -1) : v) + DQ\n\n        if (k === 'type' && v.toLowerCase() === '\"number\"') {\n          v = DQ + _bp[0] + \"'number'\" + _bp[1] + DQ\n        }\n        else if (/\\u0001\\d/.test(v)) {\n\n          if (BOOL_ATTRS.test(k)) {\n            k = '__' + k\n          }\n          else if (~RIOT_ATTRS.indexOf(k)) {\n            k = 'riot-' + k\n          }\n        }\n\n        list.push(k + '=' + v)\n      }\n    }\n    return list.join(' ')\n  }\n\n  function splitHtml(html, opts, pcex) {\n    var _bp = pcex._bp\n\n    if (html && _bp[4].test(html)) {\n      var\n        jsfn = opts.expr && (opts.parser || opts.type) ? _compileJS : 0,\n        list = brackets.split(html, 0, _bp),\n        expr\n\n      for (var i = 1; i < list.length; i += 2) {\n        expr = list[i]\n        if (expr[0] === '^')\n          expr = expr.slice(1)\n        else if (jsfn) {\n          var israw = expr[0] === '='\n          expr = jsfn(israw ? expr.slice(1) : expr, opts).trim()\n          if (expr.slice(-1) === ';') expr = expr.slice(0, -1)\n          if (israw) expr = '=' + expr\n        }\n        list[i] = '\\u0001' + (pcex.push(expr.replace(/[\\r\\n]+/g, ' ').trim()) - 1) + _bp[1]\n      }\n      html = list.join('')\n    }\n    return html\n  }\n\n  function restoreExpr(html, pcex) {\n    if (pcex.length) {\n      html = html\n        .replace(/\\u0001(\\d+)/g, function (_, d) {\n          var expr = pcex[d]\n          if (expr[0] === '=') {\n            expr = expr.replace(brackets.R_STRINGS, function (qs) {\n              return qs\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;')\n            })\n          }\n          return pcex._bp[0] + expr.replace(/\"/g, '\\u2057')\n        })\n    }\n    return html\n  }\n\n  var\n    HTML_COMMENT = /<!--(?!>)[\\S\\s]*?-->/g,\n    HTML_TAGS = /<([-\\w]+)\\s*([^\"'\\/>]*(?:(?:\"[^\"]*\"|'[^']*'|\\/[^>])[^'\"\\/>]*)*)(\\/?)>/g,\n    PRE_TAG = _regEx(\n      /<pre(?:\\s+[^'\">]+(?:(?:@Q)[^'\">]*)*|\\s*)?>([\\S\\s]*?)<\\/pre\\s*>/\n      .source.replace('@Q', brackets.R_STRINGS.source), 'gi')\n\n  function _compileHTML(html, opts, pcex) {\n\n    html = splitHtml(html, opts, pcex)\n      .replace(HTML_TAGS, function (_, name, attr, ends) {\n\n        name = name.toLowerCase()\n\n        ends = ends && !VOID_TAGS.test(name) ? '></' + name : ''\n\n        if (attr) name += ' ' + parseAttrs(attr, pcex)\n\n        return '<' + name + ends + '>'\n      })\n\n    if (!opts.whitespace) {\n      if (/<pre[\\s>]/.test(html)) {\n        var p = []\n        html = html.replace(PRE_TAG, function (q)\n          { return p.push(q) && '\\u0002' }).trim().replace(/\\s+/g, ' ')\n        // istanbul ignore else\n        if (p.length)\n          html = html.replace(/\\u0002/g, function (_) { return p.shift() })\n      }\n      else\n        html = html.trim().replace(/\\s+/g, ' ')\n    }\n\n    if (opts.compact) html = html.replace(/> <([-\\w\\/])/g, '><$1')\n\n    return restoreExpr(html, pcex)\n  }\n\n  // istanbul ignore next\n  function compileHTML(html, opts, pcex) {\n    if (Array.isArray(opts)) {\n      pcex = opts\n      opts = {}\n    }\n    else {\n      if (!pcex) pcex = []\n      if (!opts) opts = {}\n    }\n\n    if (!pcex.__intflag)\n      html = html.replace(/\\r\\n?/g, '\\n').replace(HTML_COMMENT, '').replace(TRIM_TRAIL, '')\n\n    if (!pcex._bp) pcex._bp = brackets.array(opts.brackets)\n\n    return _compileHTML(html, opts, pcex)\n  }\n\n  var\n    JS_RMCOMMS = _regEx('(' + brackets.S_QBLOCKS + ')|' + brackets.R_MLCOMMS.source + '|//[^\\r\\n]*', 'g'),\n    JS_ES6SIGN = /^([ \\t]*)([$_A-Za-z][$\\w]*)\\s*(\\([^()]*\\)\\s*{)/m\n\n  function riotjs(js) {\n    var\n      match,\n      toes5,\n      parts = [],\n      pos\n\n    js = js.replace(JS_RMCOMMS, function (m, q) { return q ? m : ' ' })\n\n    while (match = js.match(JS_ES6SIGN)) {\n\n      parts.push(RegExp.leftContext)\n      js  = RegExp.rightContext\n      pos = skipBlock(js)\n\n      toes5 = !/^(?:if|while|for|switch|catch|function)$/.test(match[2])\n      if (toes5)\n        match[0] = match[1] + 'this.' + match[2] + ' = function' + match[3]\n\n      parts.push(match[0], js.slice(0, pos))\n      js = js.slice(pos)\n      if (toes5 && !/^\\s*.\\s*bind\\b/.test(js)) parts.push('.bind(this)')\n    }\n\n    return parts.length ? parts.join('') + js : js\n\n    function skipBlock(str) {\n      var\n        re = _regEx('([{}])|' + brackets.S_QBLOCKS, 'g'),\n        level = 1,\n        match\n\n      while (level && (match = re.exec(str))) {\n        if (match[1])\n          match[1] === '{' ? ++level : --level\n      }\n      return level ? str.length : re.lastIndex\n    }\n  }\n\n  function _compileJS(js, opts, type, parserOpts, url) {\n    if (!js) return ''\n    if (!type) type = opts.type\n\n    var parser = opts.parser || (type ? parsers.js[type] : riotjs)\n    if (!parser)\n      throw new Error('JS parser not found: \"' + type + '\"')\n\n    return parser(js, parserOpts, url).replace(TRIM_TRAIL, '')\n  }\n\n  // istanbul ignore next\n  function compileJS(js, opts, type, extra) {\n    if (typeof opts === 'string') {\n      extra = type\n      type = opts\n      opts = {}\n    }\n    if (typeof type === 'object') {\n      extra = type\n      type = ''\n    }\n    else if (!extra) extra = {}\n\n    return _compileJS(js, opts, type, extra.parserOptions, extra.url)\n  }\n\n  var CSS_SELECTOR = _regEx('(}|{|^)[ ;]*([^@ ;{}][^{}]*)(?={)|' + brackets.R_STRINGS.source, 'g')\n\n  function scopedCSS(tag, style) {\n    var scope = ':scope'\n\n    return style.replace(CSS_SELECTOR, function (m, p1, p2) {\n\n      if (!p2) return m\n\n      p2 = p2.replace(/[^,]+/g, function (sel) {\n        var s = sel.trim()\n\n        if (s && s !== 'from' && s !== 'to' && s.slice(-1) !== '%') {\n\n          if (s.indexOf(scope) < 0) s = scope + ' ' + s\n          s = s.replace(scope, tag) + ',' +\n              s.replace(scope, '[riot-tag=\"' + tag + '\"]')\n        }\n        return sel.slice(-1) === ' ' ? s + ' ' : s\n      })\n\n      return p1 ? p1 + ' ' + p2 : p2\n    })\n  }\n\n  function _compileCSS(style, tag, type, opts) {\n    var scoped = (opts || (opts = {})).scoped\n\n    if (type) {\n      if (type === 'scoped-css') {\n        scoped = true\n      }\n      else if (parsers.css[type]) {\n        style = parsers.css[type](tag, style, opts.parserOpts, opts.url)\n      }\n      else if (type !== 'css') {\n        throw new Error('CSS parser not found: \"' + type + '\"')\n      }\n    }\n\n    style = style.replace(brackets.R_MLCOMMS, '').replace(/\\s+/g, ' ').trim()\n\n    if (scoped) {\n      // istanbul ignore next\n      if (!tag)\n        throw new Error('Can not parse scoped CSS without a tagName')\n      style = scopedCSS(tag, style)\n    }\n    return style\n  }\n\n  // istanbul ignore next\n  function compileCSS(style, parser, opts) {\n    if (typeof parser === 'object') {\n      opts = parser\n      parser = ''\n    }\n    else if (!opts) opts = {}\n    return _compileCSS(style, opts.tagName, parser, opts)\n  }\n\n  var\n    TYPE_ATTR = /\\stype\\s*=\\s*(?:(['\"])(.+?)\\1|(\\S+))/i,\n    MISC_ATTR = /\\s*=\\s*(\"(?:\\\\[\\S\\s]|[^\"\\\\]*)*\"|'(?:\\\\[\\S\\s]|[^'\\\\]*)*'|\\{[^}]+}|\\S+)/.source\n\n  function getType(str) {\n\n    if (str) {\n      var match = str.match(TYPE_ATTR)\n      str = match && (match[2] || match[3])\n    }\n    return str ? str.replace('text/', '') : ''\n  }\n\n  function getAttr(str, name) {\n\n    if (str) {\n      var\n        re = _regEx('\\\\s' + name + MISC_ATTR, 'i'),\n        match = str.match(re)\n      str = match && match[1]\n      if (str)\n        return (/^['\"]/).test(str) ? str.slice(1, -1) : str\n    }\n    return ''\n  }\n\n  function getParserOptions(attrs) {\n    var opts = getAttr(attrs, 'options')\n\n    if (opts) opts = JSON.parse(opts)\n    return opts\n  }\n\n  function getCode(code, opts, attrs, url) {\n    var type = getType(attrs),\n      parserOpts = getParserOptions(attrs)\n\n    return _compileJS(code, opts, type, parserOpts, url)\n  }\n\n  var END_TAGS = /\\/>\\n|^<(?:\\/[\\w\\-]+\\s*|[\\w\\-]+(?:\\s+(?:[-\\w:\\xA0-\\xFF][\\S\\s]*?)?)?)>\\n/\n\n  function splitBlocks(str) {\n    var k, m\n\n    /* istanbul ignore next: this if() can't be true, but just in case... */\n    if (str[str.length - 1] === '>') return [str, '']\n\n    k = str.lastIndexOf('<')\n    while (~k) {\n      if (m = str.slice(k).match(END_TAGS)) {\n        k += m.index + m[0].length\n        return [str.slice(0, k), str.slice(k)]\n      }\n      k = str.lastIndexOf('<', k -1)\n    }\n    return ['', str]\n  }\n\n  function compileTemplate(html, url, lang, opts) {\n    var parser = parsers.html[lang]\n\n    if (!parser)\n      throw new Error('Template parser not found: \"' + lang + '\"')\n\n    return parser(html, opts, url)\n  }\n\n  var\n    CUST_TAG = _regEx(\n      /^([ \\t]*)<([-\\w]+)(?:\\s+([^'\"\\/>]+(?:(?:@Q|\\/[^>])[^'\"\\/>]*)*)|\\s*)?(?:\\/>|>[ \\t]*\\n?([\\S\\s]*)^\\1<\\/\\2\\s*>|>(.*)<\\/\\2\\s*>)/\n      .source.replace('@Q', brackets.R_STRINGS.source), 'gim'),\n    STYLE = /<style(\\s+[^>]*)?>\\n?([^<]*(?:<(?!\\/style\\s*>)[^<]*)*)<\\/style\\s*>/gi,\n    SCRIPT = _regEx(STYLE.source.replace(/tyle/g, 'cript'), 'gi')\n\n  function compile(src, opts, url) {\n    var\n      parts = [],\n      exclude\n\n    if (!opts) opts = {}\n\n    exclude = opts.exclude || false\n    function included(s) { return !(exclude && ~exclude.indexOf(s)) }\n\n    var _bp = brackets.array(opts.brackets)\n\n    if (opts.template)\n      src = compileTemplate(src, url, opts.template, opts.templateOptions)\n\n    src = src\n      .replace(/\\r\\n?/g, '\\n')\n      .replace(CUST_TAG, function (_, indent, tagName, attribs, body, body2) {\n\n        var\n          jscode = '',\n          styles = '',\n          html = '',\n          pcex = []\n\n        pcex._bp = _bp\n        pcex.__intflag = 1\n\n        tagName = tagName.toLowerCase()\n\n        attribs = attribs && included('attribs') ?\n          restoreExpr(parseAttrs(splitHtml(attribs, opts, pcex), pcex), pcex) : ''\n\n        if (body2) body = body2\n\n        if (body && (body = body.replace(HTML_COMMENT, '')) && /\\S/.test(body)) {\n\n          if (body2) {\n            /* istanbul ignore next */\n            html = included('html') ? _compileHTML(body2, opts, pcex) : ''\n          }\n          else {\n            body = body.replace(_regEx('^' + indent, 'gm'), '')\n\n            body = body.replace(STYLE, included('css') ? function (_, _attrs, _style) {\n              var extraOpts = {\n                scoped: _attrs && /\\sscoped(\\s|=|$)/i.test(_attrs),\n                url: url,\n                parserOpts: getParserOptions(_attrs)\n              }\n              styles += (styles ? ' ' : '') +\n                _compileCSS(_style, tagName, getType(_attrs) || opts.style, extraOpts)\n              return ''\n            } : '')\n\n            body = body.replace(SCRIPT, included('js') ? function (_, _attrs, _script) {\n              jscode += (jscode ? '\\n' : '') + getCode(_script, opts, _attrs, url)\n              return ''\n            } : '')\n\n            var blocks = splitBlocks(body.replace(TRIM_TRAIL, ''))\n\n            if (included('html')) {\n              body = blocks[0]\n              if (body)\n                html = _compileHTML(body, opts, pcex)\n            }\n\n            if (included('js')) {\n              body = blocks[1]\n              if (/\\S/.test(body))\n                jscode += (jscode ? '\\n' : '') + _compileJS(body, opts, null, null, url)\n            }\n          }\n        }\n\n        jscode = /\\S/.test(jscode) ? jscode.replace(/\\n{3,}/g, '\\n\\n') : ''\n\n        if (opts.entities) {\n          parts.push({\n            tagName: tagName,\n            html: html,\n            css: styles,\n            attribs: attribs,\n            js: jscode\n          })\n          return ''\n        }\n\n        return mktag(tagName, html, styles, attribs, jscode, pcex)\n      })\n\n    if (opts.entities) return parts\n\n    return src\n  }\n\n  riot.util.compiler = {\n    compile: compile,\n    html: compileHTML,\n    css: compileCSS,\n    js: compileJS,\n    version: 'v2.3.19'\n  }\n  return compile\n\n})()\n\n/*\n  Compilation for the browser\n*/\nriot.compile = (function () {\n\n  var\n    doc = window.document,\n    promise,\n    ready\n\n  function GET(url, fn, opts) {\n    var req = new XMLHttpRequest()\n\n    req.onreadystatechange = function() {\n      if (req.readyState === 4 &&\n         (req.status === 200 || !req.status && req.responseText.length))\n        fn(req.responseText, opts, url)\n    }\n    req.open('GET', url, true)\n    req.send('')\n  }\n\n  function globalEval(js) {\n    var\n      node = doc.createElement('script'),\n      root = doc.documentElement\n\n    node.text = js\n    root.appendChild(node)\n    root.removeChild(node)\n  }\n\n  function compileScripts(fn, exopt) {\n    var\n      scripts = doc.querySelectorAll('script[type=\"riot/tag\"]'),\n      scriptsAmount = scripts.length\n\n    function done() {\n      promise.trigger('ready')\n      ready = true\n      if (fn) fn()\n    }\n\n    function compileTag(src, opts, url) {\n      var code = compile(src, opts, url)\n\n      if (url) code += '\\n//# sourceURL=' + url + '.js'\n      globalEval(code)\n      if (!--scriptsAmount) done()\n    }\n\n    if (!scriptsAmount) done()\n    else {\n      for (var i = 0; i < scripts.length; ++i) {\n        var\n          script = scripts[i],\n          opts = {template: script.getAttribute('template')},\n          url = script.getAttribute('src')\n\n        if (exopt) opts = extend(opts, exopt)\n        url ? GET(url, compileTag, opts) : compileTag(script.innerHTML, opts)\n      }\n    }\n  }\n\n  //// Entry point -----\n\n  return function (arg, fn, opts) {\n\n    if (typeof arg === 'string') {\n\n      if (typeof fn === 'object') {\n        opts = fn\n        fn = false\n      }\n\n      if (/^\\s*</.test(arg)) {\n\n        // `riot.compile(tag [, true][, options])`\n        var js = compile(arg, opts)\n        if (!fn) globalEval(js)\n        return js\n      }\n\n      // `riot.compile(url [, callback][, options])`\n      GET(arg, function (str) {\n        var js = compile(str, opts, arg)\n        globalEval(js)\n        if (fn) fn(js, str)\n      })\n\n    }\n    else {\n\n      // `riot.compile([callback][, options])`\n\n      if (typeof arg === 'function') {\n        opts = fn\n        fn = arg\n      }\n      else {\n        opts = arg\n        fn = undefined\n      }\n\n      if (ready)\n        return fn && fn()\n\n      if (promise) {\n        if (fn) promise.on('ready', fn)\n\n      } else {\n        promise = riot.observable()\n        compileScripts(fn, opts)\n      }\n    }\n  }\n\n})()\n\n// reassign mount methods -----\nvar mount = riot.mount\n\nriot.mount = function(a, b, c) {\n  var ret\n  riot.compile(function() { ret = mount(a, b, c) })\n  return ret\n}\n  // support CommonJS, AMD & browser\n  /* istanbul ignore next */\n  if (typeof exports === T_OBJECT)\n    module.exports = riot\n  else if (typeof define === T_FUNCTION && typeof define.amd !== T_UNDEF)\n    define(function() { return (window.riot = riot) })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : void 0);\n","source":"unrest/bower_components/riot/riot+compiler.js","raw":"/* Riot v2.3.12, @license MIT, (c) 2015 Muut Inc. + contributors */\n\n;(function(window, undefined) {\n  'use strict';\nvar riot = { version: 'v2.3.12', settings: {} },\n  // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n\n  // counter to give a unique id to all the Tag instances\n  __uid = 0,\n  // tags instances cache\n  __virtualDom = [],\n  // tags implementation cache\n  __tagImpl = {},\n\n  /**\n   * Const\n   */\n  // riot specific prefixes\n  RIOT_PREFIX = 'riot-',\n  RIOT_TAG = RIOT_PREFIX + 'tag',\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n  T_OBJECT = 'object',\n  T_UNDEF  = 'undefined',\n  T_FUNCTION = 'function',\n  // special native tags that cannot be treated like the others\n  SPECIAL_TAGS_REGEX = /^(?:opt(ion|group)|tbody|col|t[rhd])$/,\n  RESERVED_WORDS_BLACKLIST = ['_item', '_id', '_parent', 'update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isLoop', 'tags', 'parent', 'opts', 'trigger', 'on', 'off', 'one'],\n\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (window && window.document || {}).documentMode | 0\n/* istanbul ignore next */\nriot.observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {}\n\n  /**\n   * Private variables and methods\n   */\n\n  var callbacks = {},\n    onEachEvent = function(e, fn) { e.replace(/\\S+/g, fn) },\n    defineProperty = function (key, value) {\n      Object.defineProperty(el, key, {\n        value: value,\n        enumerable: false,\n        writable: false,\n        configurable: false\n      })\n    }\n\n  /**\n   * Listen to the given space separated list of `events` and execute the `callback` each time an event is triggered.\n   * @param  { String } events - events ids\n   * @param  { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('on', function(events, fn) {\n    if (typeof fn != 'function')  return el\n\n    onEachEvent(events, function(name, pos) {\n      (callbacks[name] = callbacks[name] || []).push(fn)\n      fn.typed = pos > 0\n    })\n\n    return el\n  })\n\n  /**\n   * Removes the given space separated list of `events` listeners\n   * @param   { String } events - events ids\n   * @param   { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('off', function(events, fn) {\n    if (events == '*') callbacks = {}\n    else {\n      onEachEvent(events, function(name) {\n        if (fn) {\n          var arr = callbacks[name]\n          for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n            if (cb == fn) arr.splice(i--, 1)\n          }\n        } else delete callbacks[name]\n      })\n    }\n    return el\n  })\n\n  /**\n   * Listen to the given space separated list of `events` and execute the `callback` at most once\n   * @param   { String } events - events ids\n   * @param   { Function } fn - callback function\n   * @returns { Object } el\n   */\n\n  defineProperty('one', function(events, fn) {\n    function on() {\n      el.off(events, on)\n      fn.apply(el, arguments)\n    }\n    return el.on(events, on)\n  })\n\n  /**\n   * Execute all callback functions that listen to the given space separated list of `events`\n   * @param   { String } events - events ids\n   * @returns { Object } el\n   */\n\n  defineProperty('trigger', function(events) {\n\n    // getting the arguments\n    // skipping the first one\n    var arglen = arguments.length - 1,\n      args = new Array(arglen)\n    for (var i = 0; i < arglen; i++) {\n      args[i] = arguments[i + 1]\n    }\n\n    onEachEvent(events, function(name) {\n\n      var fns = (callbacks[name] || []).slice(0)\n\n      for (var i = 0, fn; fn = fns[i]; ++i) {\n        if (fn.busy) return\n        fn.busy = 1\n\n        try {\n          fn.apply(el, fn.typed ? [name].concat(args) : args)\n        } catch (e) { el.trigger('error', e) }\n        if (fns[i] !== fn) { i-- }\n        fn.busy = 0\n      }\n\n      if (callbacks.all && name != 'all')\n        el.trigger.apply(el, ['all', name].concat(args))\n\n    })\n\n    return el\n  })\n\n  return el\n\n}\n/* istanbul ignore next */\n;(function(riot) { if (!window) return;\n\n/**\n * Simple client-side router\n * @module riot-route\n */\n\n\nvar RE_ORIGIN = /^.+?\\/+[^\\/]+/,\n  EVENT_LISTENER = 'EventListener',\n  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n  HAS_ATTRIBUTE = 'hasAttribute',\n  REPLACE = 'replace',\n  POPSTATE = 'popstate',\n  HASHCHANGE = 'hashchange',\n  TRIGGER = 'trigger',\n  MAX_EMIT_STACK_LEVEL = 3,\n  win = window,\n  doc = document,\n  loc = win.history.location || win.location, // see html5-history-api\n  prot = Router.prototype, // to minify more\n  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n  started = false,\n  central = riot.observable(),\n  routeFound = false,\n  debouncedEmit,\n  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/)\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var re = new RegExp('^' + filter[REPLACE](/\\*/g, '([^/?#]+?)')[REPLACE](/\\.\\./, '.*') + '$'),\n    args = path.match(re)\n\n  if (args) return args.slice(1)\n}\n\n/**\n * Simple/cheap debounce implementation\n * @param   {function} fn - callback\n * @param   {number} delay - delay in seconds\n * @returns {function} debounced function\n */\nfunction debounce(fn, delay) {\n  var t\n  return function () {\n    clearTimeout(t)\n    t = setTimeout(fn, delay)\n  }\n}\n\n/**\n * Set the window listeners to trigger the routes\n * @param {boolean} autoExec - see route.start\n */\nfunction start(autoExec) {\n  debouncedEmit = debounce(emit, 1)\n  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit)\n  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n  doc[ADD_EVENT_LISTENER](clickEvent, click)\n  if (autoExec) emit(true)\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = []\n  riot.observable(this) // make it observable\n  central.on('stop', this.s.bind(this))\n  central.on('emit', this.e.bind(this))\n}\n\nfunction normalize(path) {\n  return path[REPLACE](/^\\/|\\/$/, '')\n}\n\nfunction isString(str) {\n  return typeof str == 'string'\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href)[REPLACE](RE_ORIGIN, '')\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  return base[0] == '#'\n    ? (href || loc.href).split(base)[1] || ''\n    : getPathFromRoot(href)[REPLACE](base, '')\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel == 0\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return\n\n  emitStackLevel++\n  emitStack.push(function() {\n    var path = getPathFromBase()\n    if (force || path != current) {\n      central[TRIGGER]('emit', path)\n      current = path\n    }\n  })\n  if (isRoot) {\n    while (emitStack.length) {\n      emitStack[0]()\n      emitStack.shift()\n    }\n    emitStackLevel = 0\n  }\n}\n\nfunction click(e) {\n  if (\n    e.which != 1 // not left click\n    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n    || e.defaultPrevented // or default prevented\n  ) return\n\n  var el = e.target\n  while (el && el.nodeName != 'A') el = el.parentNode\n  if (\n    !el || el.nodeName != 'A' // not A tag\n    || el[HAS_ATTRIBUTE]('download') // has download attr\n    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n    || el.target && el.target != '_self' // another window or frame\n    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin\n  ) return\n\n  if (el.href != loc.href) {\n    if (\n      el.href.split('#')[0] == loc.href.split('#')[0] // internal jump\n      || base != '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n    ) return\n  }\n\n  e.preventDefault()\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n * @returns {boolean} - route not found flag\n */\nfunction go(path, title) {\n  title = title || doc.title\n  // browsers ignores the second parameter `title`\n  history.pushState(null, title, base + normalize(path))\n  // so we need to set it manually\n  doc.title = title\n  routeFound = false\n  emit()\n  return routeFound\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n */\nprot.m = function(first, second) {\n  if (isString(first) && (!second || isString(second))) go(first, second)\n  else if (second) this.r(first, second)\n  else this.r('@', first)\n}\n\n/**\n * Stop routing\n */\nprot.s = function() {\n  this.off('*')\n  this.$ = []\n}\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function(path) {\n  this.$.concat('@').some(function(filter) {\n    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))\n    if (typeof args != 'undefined') {\n      this[TRIGGER].apply(null, [filter].concat(args))\n      return routeFound = true // exit from loop\n    }\n  }, this)\n}\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function(filter, action) {\n  if (filter != '@') {\n    filter = '/' + normalize(filter)\n    this.$.push(filter)\n  }\n  this.on(filter, action)\n}\n\nvar mainRouter = new Router()\nvar route = mainRouter.m.bind(mainRouter)\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function() {\n  var newSubRouter = new Router()\n  // stop only this sub-router\n  newSubRouter.m.stop = newSubRouter.s.bind(newSubRouter)\n  // return sub-router's main method\n  return newSubRouter.m.bind(newSubRouter)\n}\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function(arg) {\n  base = arg || '#'\n  current = getPathFromBase() // recalculate current path\n}\n\n/** Exec routing right now **/\nroute.exec = function() {\n  emit(true)\n}\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function(fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER\n    secondParser = DEFAULT_SECOND_PARSER\n  }\n  if (fn) parser = fn\n  if (fn2) secondParser = fn2\n}\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function() {\n  var q = {}\n  loc.href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })\n  return q\n}\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit)\n    win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit)\n    doc[REMOVE_EVENT_LISTENER](clickEvent, click)\n    central[TRIGGER]('stop')\n    started = false\n  }\n}\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    if (document.readyState == 'complete') start(autoExec)\n    // the timeout is needed to solve\n    // a weird safari bug https://github.com/riot/route/issues/33\n    else win[ADD_EVENT_LISTENER]('load', function() {\n      setTimeout(function() { start(autoExec) }, 1)\n    })\n    started = true\n  }\n}\n\n/** Prepare the router **/\nroute.base()\nroute.parser()\n\nriot.route = route\n})(riot)\n/* istanbul ignore next */\n\n/**\n * The riot template engine\n * @version v2.3.19\n */\n\n/**\n * @module brackets\n *\n * `brackets         ` Returns a string or regex based on its parameter\n * `brackets.settings` Mirrors the `riot.settings` object (use brackets.set in new code)\n * `brackets.set     ` Change the current riot brackets\n */\n\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB  = 'g',\n\n    MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n    STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\n    S_QBSRC = STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    DEFAULT = '{ }',\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBSRC, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBSRC, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBSRC, REGLOB)\n    }\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _pairs = []\n\n  function _loopback(re) { return re }\n\n  function _rewrite(re, bp) {\n    if (!bp) bp = _pairs\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create(pair) {\n    var\n      cvt,\n      arr = pair.split(' ')\n\n    if (pair === DEFAULT) {\n      arr[2] = arr[0]\n      arr[3] = arr[1]\n      cvt = _loopback\n    }\n    else {\n      if (arr.length !== 2 || /[\\x00-\\x1F<>a-zA-Z0-9'\",;\\\\]/.test(pair)) {\n        throw new Error('Unsupported brackets \"' + pair + '\"')\n      }\n      arr = arr.concat(pair.replace(/(?=[[\\]()*+?.^$|])/g, '\\\\').split(' '))\n      cvt = _rewrite\n    }\n    arr[4] = cvt(arr[1].length > 1 ? /{[\\S\\s]*?}/ : /{[^}]*}/, arr)\n    arr[5] = cvt(/\\\\({|})/g, arr)\n    arr[6] = cvt(/(\\\\?)({)/g, arr)\n    arr[7] = RegExp('(\\\\\\\\?)(?:([[({])|(' + arr[3] + '))|' + S_QBSRC, REGLOB)\n    arr[8] = pair\n    return arr\n  }\n\n  function _reset(pair) {\n    if (!pair) pair = DEFAULT\n\n    if (pair !== _pairs[8]) {\n      _pairs = _create(pair)\n      _regex = pair === DEFAULT ? _loopback : _rewrite\n      _pairs[9] = _regex(/^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/)\n      _pairs[10] = _regex(/(^|[^\\\\]){=[\\S\\s]*?}/)\n      _brackets._rawOffset = _pairs[0].length\n    }\n    cachedBrackets = pair\n  }\n\n  function _brackets(reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _pairs[reOrIdx]\n  }\n\n  _brackets.split = function split(str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) _bp = _pairs\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6]\n\n    isexpr = start = re.lastIndex = 0\n\n    while (match = re.exec(str)) {\n\n      pos = match.index\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(match[2], re.lastIndex)\n          continue\n        }\n\n        if (!match[3])\n          continue\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos))\n        start = re.lastIndex\n        re = _bp[6 + (isexpr ^= 1)]\n        re.lastIndex = start\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start))\n    }\n\n    return parts\n\n    function unescapeStr(str) {\n      if (tmpl || isexpr)\n        parts.push(str && str.replace(_bp[5], '$1'))\n      else\n        parts.push(str)\n    }\n\n    function skipBraces(ch, pos) {\n      var\n        match,\n        recch = FINDBRACES[ch],\n        level = 1\n      recch.lastIndex = pos\n\n      while (match = recch.exec(str)) {\n        if (match[1] &&\n          !(match[1] === ch ? ++level : --level)) break\n      }\n      return match ? recch.lastIndex : str.length\n    }\n  }\n\n  _brackets.hasExpr = function hasExpr(str) {\n    return _brackets(4).test(str)\n  }\n\n  _brackets.loopKeys = function loopKeys(expr) {\n    var m = expr.match(_brackets(9))\n    return m ?\n      { key: m[1], pos: m[2], val: _pairs[0] + m[3].trim() + _pairs[1] } : { val: expr.trim() }\n  }\n\n  _brackets.array = function array(pair) {\n    return _create(pair || cachedBrackets)\n  }\n\n  var _settings\n  function _setSettings(o) {\n    var b\n    o = o || {}\n    b = o.brackets\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    })\n    _settings = o\n    _reset(b)\n  }\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  })\n\n  /* istanbul ignore next: in the node version riot is not in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}\n  _brackets.set = _reset\n\n  _brackets.R_STRINGS = STRINGS\n  _brackets.R_MLCOMMS = MLCOMMS\n  _brackets.S_QBLOCKS = S_QBSRC\n\n  return _brackets\n\n})()\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\nvar tmpl = (function () {\n\n  var _cache = {}\n\n  function _tmpl(str, data) {\n    if (!str) return str\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.isRaw = function (expr) {\n    return expr[brackets._rawOffset] === \"=\"\n  }\n\n  _tmpl.haveRaw = function (src) {\n    return brackets(10).test(src)\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr\n\n  _tmpl.loopKeys = brackets.loopKeys\n\n  _tmpl.errorHandler = null\n\n  function _logErr(err, ctx) {\n\n    if (_tmpl.errorHandler) {\n\n      err.riotData = {\n        tagName: ctx && ctx.root && ctx.root.tagName,\n        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n      }\n      _tmpl.errorHandler(err)\n    }\n  }\n\n  function _create(str) {\n\n    var expr = _getTmpl(str)\n    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr\n\n    return new Function('E', expr + ';')\n  }\n\n  var\n    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_QBMARK = /\\x01(\\d+)~/g\n\n  function _getTmpl(str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str.replace(/\\u2057/g, '\"'), 1)\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = []\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i]\n\n        if (expr && (expr = i & 1 ?\n\n              _parseExpr(expr, 1, qstr) :\n\n              '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) list[j++] = expr\n\n      }\n\n      expr = j < 2 ? list[0] :\n             '[' + list.join(',') + '].join(\"\")'\n    }\n    else {\n\n      expr = _parseExpr(parts[1], 0, qstr)\n    }\n\n    if (qstr[0])\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      })\n\n    return expr\n  }\n\n  var\n    CS_IDENT = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\x01(\\d+)~):/,\n    RE_BRACE = /,|([[{(])|$/g\n\n  function _parseExpr(expr, asText, qstr) {\n\n    if (expr[0] === \"=\") expr = expr.slice(1)\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? '\\x01' + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1')\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match\n\n      while (expr &&\n            (match = expr.match(CS_IDENT)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g\n\n        expr = RegExp.rightContext\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1]\n\n        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)\n\n        jsb  = expr.slice(0, match.index)\n        expr = RegExp.rightContext\n\n        list[cnt++] = _wrapExpr(jsb, 1, key)\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText) :\n          cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0]\n    }\n    return expr\n\n    function skipBraces(jsb, re) {\n      var\n        match,\n        lv = 1,\n        ir = jsb === '(' ? /[()]/g : jsb === '[' ? /[[\\]]/g : /[{}]/g\n\n      ir.lastIndex = re.lastIndex\n      while (match = ir.exec(expr)) {\n        if (match[0] === jsb) ++lv\n        else if (!--lv) break\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex\n    }\n  }\n\n  // istanbul ignore next: not both\n  var JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').'\n  var JS_VARNAME = /[,{][$\\w]+:|(^ *|[^$\\w\\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g\n\n  function _wrapExpr(expr, asText, key) {\n    var tb\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar\n          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['\n        }\n        else if (pos)\n          tb = !/^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/.test(s.slice(pos))\n      }\n      return match\n    })\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}'\n    }\n\n    if (key) {\n\n      expr = (tb ?\n          'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"'\n    }\n    else if (asText) {\n\n      expr = 'function(v){' + (tb ?\n          expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)'\n    }\n\n    return expr\n  }\n\n  // istanbul ignore next: compatibility fix for beta versions\n  _tmpl.parse = function (s) { return s }\n\n  return _tmpl\n\n})()\n\n  tmpl.version = brackets.version = 'v2.3.19'\n\n\n/*\n  lib/browser/tag/mkdom.js\n\n  Includes hacks needed for the Internet Explorer version 9 and bellow\n\n*/\n// http://kangax.github.io/compat-table/es5/#ie8\n// http://codeplanet.io/dropping-ie8/\n\nvar mkdom = (function (checkIE) {\n\n  var rootEls = {\n      'tr': 'tbody',\n      'th': 'tr',\n      'td': 'tr',\n      'tbody': 'table',\n      'col': 'colgroup'\n    },\n    GENERIC = 'div'\n\n  checkIE = checkIE && checkIE < 10\n\n  // creates any dom element in a div, table, or colgroup container\n  function _mkdom(html) {\n\n    var match = html && html.match(/^\\s*<([-\\w]+)/),\n      tagName = match && match[1].toLowerCase(),\n      rootTag = rootEls[tagName] || GENERIC,\n      el = mkEl(rootTag)\n\n    el.stub = true\n\n    /* istanbul ignore next */\n    if (checkIE && tagName && (match = tagName.match(SPECIAL_TAGS_REGEX)))\n      ie9elem(el, html, tagName, !!match[1])\n    else\n      el.innerHTML = html\n\n    return el\n  }\n\n  // creates tr, th, td, option, optgroup element for IE8-9\n  /* istanbul ignore next */\n  function ie9elem(el, html, tagName, select) {\n\n    var div = mkEl(GENERIC),\n      tag = select ? 'select>' : 'table>',\n      child\n\n    div.innerHTML = '<' + tag + html + '</' + tag\n\n    child = $(tagName, div)\n    if (child)\n      el.appendChild(child)\n\n  }\n  // end ie9elem()\n\n  return _mkdom\n\n})(IE_VERSION)\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n\n  var i = tags.length,\n    j = items.length\n\n  while (i > j) {\n    var t = tags[--i]\n    tags.splice(i, 1)\n    t.unmount()\n  }\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @param   { Object } child - non custom loop tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(child, i) {\n  Object.keys(child.tags).forEach(function(tagName) {\n    var tag = child.tags[tagName]\n    if (isArray(tag))\n      each(tag, function (t) {\n        moveChildTag(t, tagName, i)\n      })\n    else\n      moveChildTag(tag, tagName, i)\n  })\n}\n\n/**\n * Adds the elements for a virtual tag\n * @param { Tag } tag - the tag whose root's children will be inserted or appended\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction addVirtual(tag, src, target) {\n  var el = tag._root\n  tag._virts = []\n  while (el) {\n    var sib = el.nextSibling\n    if (target)\n      src.insertBefore(el, target._root)\n    else\n      src.appendChild(el)\n\n    tag._virts.push(el) // hold for unmounting\n    el = sib\n  }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @param { Tag } tag - first child reference used to start move\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n * @param { Number } len - how many child nodes to move\n */\nfunction moveVirtual(tag, src, target, len) {\n  var el = tag._root\n  for (var i = 0; i < len; i++) {\n    var sib = el.nextSibling\n    src.insertBefore(el, target._root)\n    el = sib\n  }\n}\n\n\n/**\n * Manage tags having the 'each'\n * @param   { Object } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, 'each')\n\n  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n    tagName = getTagName(dom),\n    impl = __tagImpl[tagName] || { tmpl: dom.outerHTML },\n    useRoot = SPECIAL_TAGS_REGEX.test(tagName),\n    root = dom.parentNode,\n    ref = document.createTextNode(''),\n    child = getTag(dom),\n    isOption = /option/gi.test(tagName), // the option tags must be treated differently\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isVirtual = dom.tagName == 'VIRTUAL'\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr)\n\n  // insert a marked where the loop tags will be injected\n  root.insertBefore(ref, dom)\n\n  // clean template code\n  parent.one('before-mount', function () {\n\n    // remove the original DOM node\n    dom.parentNode.removeChild(dom)\n    if (root.stub) root = parent.root\n\n  }).on('update', function () {\n    // get the new items collection\n    var items = tmpl(expr.val, parent),\n      // create a fragment to hold the new DOM nodes to inject in the parent tag\n      frag = document.createDocumentFragment()\n\n\n\n    // object loop. any changes cause full redraw\n    if (!isArray(items)) {\n      hasKeys = items || false\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, key, items[key])\n        }) : []\n    }\n\n    // loop all the new items\n    items.forEach(function(item, i) {\n      // reorder only if the items are objects\n      var _mustReorder = mustReorder && item instanceof Object,\n        oldPos = oldItems.indexOf(item),\n        pos = ~oldPos && _mustReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos]\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item\n\n      // new tag\n      if (\n        !_mustReorder && !tag // with no-reorder we just update the old tags\n        ||\n        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements\n      ) {\n\n        tag = new Tag(impl, {\n          parent: parent,\n          isLoop: true,\n          hasImpl: !!__tagImpl[tagName],\n          root: useRoot ? root : dom.cloneNode(),\n          item: item\n        }, dom.innerHTML)\n\n        tag.mount()\n        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts\n        // this tag must be appended\n        if (i == tags.length) {\n          if (isVirtual)\n            addVirtual(tag, frag)\n          else frag.appendChild(tag.root)\n        }\n        // this tag must be insert\n        else {\n          if (isVirtual)\n            addVirtual(tag, root, tags[i])\n          else root.insertBefore(tag.root, tags[i].root)\n          oldItems.splice(i, 0, item)\n        }\n\n        tags.splice(i, 0, tag)\n        pos = i // handled here so no move\n      } else tag.update(item)\n\n      // reorder the tag if it's not located in its previous position\n      if (pos !== i && _mustReorder) {\n        // update the DOM\n        if (isVirtual)\n          moveVirtual(tag, root, tags[i], dom.childNodes.length)\n        else root.insertBefore(tag.root, tags[i].root)\n        // update the position attribute if it exists\n        if (expr.pos)\n          tag[expr.pos] = i\n        // move the old tag instance\n        tags.splice(i, 0, tags.splice(pos, 1)[0])\n        // move the old item\n        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child) moveNestedTags(tag, i)\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag._item = item\n      // cache the real parent tag internally\n      defineProperty(tag, '_parent', parent)\n\n    }, true) // allow null values\n\n    // remove the redundant tags\n    unmountRedundant(items, tags)\n\n    // insert the new nodes\n    if (isOption) root.appendChild(frag)\n    else root.insertBefore(frag, ref)\n\n    // set the 'tags' property of the parent tag\n    // if child is 'undefined' it means that we don't need to set this property\n    // for example:\n    // we don't need store the `myTag.tags['div']` property if we are looping a div tag\n    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`\n    if (child) parent.tags[tagName] = tags\n\n    // clone the items array\n    oldItems = items.slice()\n\n  })\n\n}\n\n\nfunction parseNamedElements(root, tag, childTags, forceParsingNamed) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = dom.isLoop || (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each')) ? 1 : 0\n\n      // custom child tag\n      if (childTags) {\n        var child = getTag(dom)\n\n        if (child && !dom.isLoop)\n          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))\n      }\n\n      if (!dom.isLoop || forceParsingNamed)\n        setNamed(dom, tag, [])\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (tmpl.hasExpr(val)) {\n      var expr = { dom: dom, expr: val }\n      expressions.push(extend(expr, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    var attr = getAttr(dom, 'each')\n\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n    opts = inherit(conf.opts) || {},\n    dom = mkdom(impl.tmpl),\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    hasImpl = conf.hasImpl,\n    item = cleanUpData(conf.item),\n    expressions = [],\n    childTags = [],\n    root = conf.root,\n    fn = impl.fn,\n    tagName = root.tagName.toLowerCase(),\n    attr = {},\n    propsInSyncWithParent = []\n\n  if (fn && root._tag) root._tag.unmount(true)\n\n  // not yet mounted\n  this.isMounted = false\n  root.isLoop = isLoop\n\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id\n\n  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    var val = el.value\n    // remember attributes with expressions only\n    if (tmpl.hasExpr(val)) attr[el.name] = val\n  })\n\n  if (dom.innerHTML && !/^(select|optgroup|table|tbody|tr|col(?:group)?)$/.test(tagName))\n    // replace all the yield tags with the tag inner html\n    dom.innerHTML = replaceYield(dom.innerHTML, innerHTML)\n\n  // options\n  function updateOpts() {\n    var ctx = hasImpl && isLoop ? self : parent || self\n\n    // update opts from current DOM attributes\n    each(root.attributes, function(el) {\n      opts[toCamel(el.name)] = tmpl(el.value, ctx)\n    })\n    // recover those with expressions\n    each(Object.keys(attr), function(name) {\n      opts[toCamel(name)] = tmpl(attr[name], ctx)\n    })\n  }\n\n  function normalizeData(data) {\n    for (var key in item) {\n      if (typeof self[key] !== T_UNDEF && isWritable(self, key))\n        self[key] = data[key]\n    }\n  }\n\n  function inheritFromParent () {\n    if (!self.parent || !isLoop) return\n    each(Object.keys(self.parent), function(k) {\n      // some properties must be always in sync with the parent tag\n      var mustSync = !contains(RESERVED_WORDS_BLACKLIST, k) && contains(propsInSyncWithParent, k)\n      if (typeof self[k] === T_UNDEF || mustSync) {\n        // track the property to keep in sync\n        // so we can keep it updated\n        if (!mustSync) propsInSyncWithParent.push(k)\n        self[k] = self.parent[k]\n      }\n    })\n  }\n\n  defineProperty(this, 'update', function(data) {\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data)\n    // inherit properties from the parent\n    inheritFromParent()\n    // normalize the tag properties in case an item object was initially passed\n    if (data && typeof item === T_OBJECT) {\n      normalizeData(data)\n      item = data\n    }\n    extend(self, data)\n    updateOpts()\n    self.trigger('update', data)\n    update(expressions, self)\n    // the updated event will be triggered\n    // once the DOM will be ready and all the reflow are completed\n    // this is useful if you want to get the \"real\" root properties\n    // 4 ex: root.offsetWidth ...\n    rAF(function() { self.trigger('updated') })\n    return this\n  })\n\n  defineProperty(this, 'mixin', function() {\n    each(arguments, function(mix) {\n      var instance\n\n      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix()\n        // save the prototype to loop it afterwards\n        mix = mix.prototype\n      } else instance = mix\n\n      // loop the keys in the function prototype or the all object keys\n      each(Object.getOwnPropertyNames(mix), function(key) {\n        // bind methods to self\n        if (key != 'init')\n          self[key] = isFunction(instance[key]) ?\n                        instance[key].bind(self) :\n                        instance[key]\n      })\n\n      // init method will be called automatically\n      if (instance.init) instance.init.bind(self)()\n    })\n    return this\n  })\n\n  defineProperty(this, 'mount', function() {\n\n    updateOpts()\n\n    // initialiation\n    if (fn) fn.call(self, opts)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    // mount the child tags\n    toggle(true)\n\n    // update the root adding custom attributes coming from the compiler\n    // it fixes also #1087\n    if (impl.attrs || hasImpl) {\n      walkAttributes(impl.attrs, function (k, v) { setAttr(root, k, v) })\n      parseExpressions(self.root, self, expressions)\n    }\n\n    if (!self.parent || isLoop) self.update(item)\n\n    // internal use only, fixes #403\n    self.trigger('before-mount')\n\n    if (isLoop && !hasImpl) {\n      // update the root attribute for the looped elements\n      self.root = root = dom.firstChild\n\n    } else {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n      if (root.stub) self.root = root = parent.root\n    }\n\n    // parse the named dom nodes in the looped child\n    // adding them to the parent as well\n    if (isLoop)\n      parseNamedElements(self.root, self.parent, null, true)\n\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent || self.parent.isMounted) {\n      self.isMounted = true\n      self.trigger('mount')\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() {\n      // avoid to trigger the `mount` event for the tags\n      // not visible included in an if statement\n      if (!isInStub(self.root)) {\n        self.parent.isMounted = self.isMounted = true\n        self.trigger('mount')\n      }\n    })\n  })\n\n\n  defineProperty(this, 'unmount', function(keepRootTag) {\n    var el = root,\n      p = el.parentNode,\n      ptag\n\n    self.trigger('before-unmount')\n\n    // remove this tag instance from the global virtualDom variable\n    __virtualDom.splice(__virtualDom.indexOf(self), 1)\n\n    if (this._virts) {\n      each(this._virts, function(v) {\n        v.parentNode.removeChild(v)\n      })\n    }\n\n    if (p) {\n\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent)\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (isArray(ptag.tags[tagName]))\n          each(ptag.tags[tagName], function(tag, i) {\n            if (tag._riot_id == self._riot_id)\n              ptag.tags[tagName].splice(i, 1)\n          })\n        else\n          // otherwise just delete the tag instance\n          ptag.tags[tagName] = undefined\n      }\n\n      else\n        while (el.firstChild) el.removeChild(el.firstChild)\n\n      if (!keepRootTag)\n        p.removeChild(el)\n      else\n        // the riot-tag attribute isn't needed anymore, remove it\n        remAttr(p, 'riot-tag')\n    }\n\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    self.isMounted = false\n    // somehow ie8 does not like `delete root._tag`\n    root._tag = null\n\n  })\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (parent) {\n      var evt = isMount ? 'on' : 'off'\n\n      // the loop tags will be always in sync with the parent automatically\n      if (isLoop)\n        parent[evt]('unmount', self.unmount)\n      else\n        parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n    }\n  }\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n}\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n\n  dom[name] = function(e) {\n\n    var ptag = tag._parent,\n      item = tag._item,\n      el\n\n    if (!item)\n      while (ptag && !item) {\n        item = ptag._item\n        ptag = ptag._parent\n      }\n\n    // cross browser event fix\n    e = e || window.event\n\n    // override the event properties\n    if (isWritable(e, 'currentTarget')) e.currentTarget = dom\n    if (isWritable(e, 'target')) e.target = e.srcElement\n    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode\n\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      if (e.preventDefault) e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      el = item ? getImmediateCustomParentTag(ptag) : tag\n      el.update()\n    }\n\n  }\n\n}\n\n\n/**\n * Insert a DOM node replacing another one (used by if- attribute)\n * @param   { Object } root - parent node\n * @param   { Object } node - node replaced\n * @param   { Object } before - node added\n */\nfunction insertTo(root, node, before) {\n  if (root) {\n    root.insertBefore(before, node)\n    root.removeChild(node)\n  }\n}\n\n/**\n * Update the expressions in a Tag instance\n * @param   { Array } expressions - expression that must be re evaluated\n * @param   { Tag } tag - tag instance\n */\nfunction update(expressions, tag) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n      attrName = expr.attr,\n      value = tmpl(expr.expr, tag),\n      parent = expr.dom.parentNode\n\n    if (expr.bool)\n      value = value ? attrName : false\n    else if (value == null)\n      value = ''\n\n    // leave out riot- prefixes from strings inside textarea\n    // fix #815: any value -> string\n    if (parent && parent.tagName == 'TEXTAREA') {\n      value = ('' + value).replace(/riot-/g, '')\n      // change textarea's value\n      parent.value = value\n    }\n\n    // no change\n    if (expr.value === value) return\n    expr.value = value\n\n    // text node\n    if (!attrName) {\n      dom.nodeValue = '' + value    // #815 related\n      return\n    }\n\n    // remove original attribute\n    remAttr(dom, attrName)\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, tag)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub,\n        add = function() { insertTo(stub.parentNode, stub, dom) },\n        remove = function() { insertTo(dom.parentNode, dom, stub) }\n\n      // add to DOM\n      if (value) {\n        if (stub) {\n          add()\n          dom.inStub = false\n          // avoid to trigger the mount event if the tags is not visible yet\n          // maybe we can optimize this avoiding to mount the tag at all\n          if (!isInStub(dom)) {\n            walk(dom, function(el) {\n              if (el._tag && !el._tag.isMounted) el._tag.isMounted = !!el._tag.trigger('mount')\n            })\n          }\n        }\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        // if the parentNode is defined we can easily replace the tag\n        if (dom.parentNode)\n          remove()\n        // otherwise we need to wait the updated event\n        else (tag.parent || tag).one('updated', remove)\n\n        dom.inStub = true\n      }\n    // show / hide\n    } else if (/^(show|hide)$/.test(attrName)) {\n      if (attrName == 'hide') value = !value\n      dom.style.display = value ? '' : 'none'\n\n    // field value\n    } else if (attrName == 'value') {\n      dom.value = value\n\n    // <img src=\"{ expr }\">\n    } else if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n      if (value)\n        setAttr(dom, attrName.slice(RIOT_PREFIX.length), value)\n\n    } else {\n      if (expr.bool) {\n        dom[attrName] = value\n        if (!value) return\n      }\n\n      if (value && value != 0 && typeof value !== T_OBJECT)\n        setAttr(dom, attrName, value)\n\n    }\n\n  })\n\n}\n/**\n * Loops an array\n * @param   { Array } els - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(els, fn) {\n  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n    el = els[i]\n    // return false -> remove current item during loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\n/**\n * Detect if the argument passed is a function\n * @param   { * } v - whatever you want to pass to this function\n * @returns { Boolean } -\n */\nfunction isFunction(v) {\n  return typeof v === T_FUNCTION || false   // avoid IE problems\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } string - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(string) {\n  return string.replace(/-(\\w)/g, function(_, c) {\n    return c.toUpperCase()\n  })\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  dom.setAttribute(name, val)\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]\n}\n/**\n * Add a child tag to its parent into the `tags` object\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the new tag will be stored\n * @param   { Object } parent - tag instance where the new child tag will be included\n */\nfunction addChildTag(tag, tagName, parent) {\n  var cachedTag = parent.tags[tagName]\n\n  // if there are multiple children tags having the same name\n  if (cachedTag) {\n    // if the parent tags property is not yet an array\n    // create it adding the first cached tag\n    if (!isArray(cachedTag))\n      // don't add the same tag twice\n      if (cachedTag !== tag)\n        parent.tags[tagName] = [cachedTag]\n    // add the new nested tag to the array\n    if (!contains(parent.tags[tagName], tag))\n      parent.tags[tagName].push(tag)\n  } else {\n    parent.tags[tagName] = tag\n  }\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @param   { Object } tag - child tag instance\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tag, tagName, newPos) {\n  var parent = tag.parent,\n    tags\n  // no parent no move\n  if (!parent) return\n\n  tags = parent.tags[tagName]\n\n  if (isArray(tags))\n    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])\n  else addChildTag(tag, tagName, parent)\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag(child, opts, innerHTML),\n    tagName = getTagName(opts.root),\n    ptag = getImmediateCustomParentTag(parent)\n  // fix for the parent attribute in the looped elements\n  tag.parent = ptag\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag._parent = parent\n\n  // add this tag to the custom parent tag\n  addChildTag(tag, tagName, ptag)\n  // and also to the real parent tag\n  if (ptag !== parent)\n    addChildTag(tag, tagName, parent)\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = ''\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag\n  while (!getTag(ptag.root)) {\n    if (!ptag.parent) break\n    ptag = ptag.parent\n  }\n  return ptag\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n* @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: false\n  }, options))\n  return el\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom) {\n  var child = getTag(dom),\n    namedTag = getAttr(dom, 'name'),\n    tagName = namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n\n  return tagName\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          src[key] = obj[key]\n      }\n    }\n  }\n  return src\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } arr - target array\n * @param   { * } item - item to test\n * @returns { Boolean } Does 'arr' contain 'item'?\n */\nfunction contains(arr, item) {\n  return ~arr.indexOf(item)\n}\n\n/**\n * Check whether an object is a kind of array\n * @param   { * } a - anything\n * @returns {Boolean} is 'a' an array?\n */\nfunction isArray(a) { return Array.isArray(a) || a instanceof Array }\n\n/**\n * Detect whether a property of an object could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } is this property writable?\n */\nfunction isWritable(obj, key) {\n  var props = Object.getOwnPropertyDescriptor(obj, key)\n  return typeof obj[key] === T_UNDEF || props && props.writable\n}\n\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION)) return data\n\n  var o = {}\n  for (var key in data) {\n    if (!contains(RESERVED_WORDS_BLACKLIST, key))\n      o[key] = data[key]\n  }\n  return o\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n */\nfunction walk(dom, fn) {\n  if (dom) {\n    // stop the recursion\n    if (fn(dom) === false) return\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttributes(html, fn) {\n  var m,\n    re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\n  while (m = re.exec(html)) {\n    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n  }\n}\n\n/**\n * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n * @param   { Object }  dom - DOM node we want to parse\n * @returns { Boolean } -\n */\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub) return true\n    dom = dom.parentNode\n  }\n  return false\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name) {\n  return document.createElement(name)\n}\n\n/**\n * Create a generic DOM node, and fill it with innerHTML\n * @param   { String } name - name of the DOM node we want to create\n * @param   { String } innerHTML - innerHTML of the new DOM\n * @returns { Object } DOM node just created\n */\nfunction mkElWithInnerHTML(name, innerHTML) {\n  var el = mkEl(name)\n  el.innerHTML = innerHTML || ''\n  return el\n}\n\n/**\n * Replace the yield tag from any tag template with the innerHTML of the\n * original tag in the page\n * @param   { String } tmpl - tag implementation template\n * @param   { String } innerHTML - original content of the tag in the DOM\n * @returns { String } tag template updated without the yield tag\n */\nfunction replaceYield(tmpl, innerHTML) {\n  var tmplElement = mkElWithInnerHTML('div', tmpl)\n  // if ($('yield[from]'.tmplElement)) { // this issues test errors\n  if (tmplElement.querySelector && tmplElement.querySelector('yield[from]')) { // code coverage path not taken (?)\n    // yield to(s) must be direct children from innerHTML(root), all other tags are ignored\n    each(mkElWithInnerHTML('div', innerHTML).childNodes, function(toYield) {\n      if (toYield.nodeType == 1 && toYield.tagName == 'YIELD' && toYield.getAttribute('to')) {\n        // replace all yield[from]\n        each($$('yield[from=\"'+toYield.getAttribute('to')+'\"]', tmplElement), function(fromYield) {\n          fromYield.outerHTML = toYield.innerHTML\n        })\n      }\n    })\n    return tmplElement.innerHTML\n  } else\n    // just replace yield in tmpl with the innerHTML\n    return tmpl.replace(/<yield\\s*(?:\\/>|>\\s*<\\/yield\\s*>)/gi, innerHTML || '')\n}\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Simple object prototypal inheritance\n * @param   { Object } parent - parent object\n * @returns { Object } child instance\n */\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n\n/**\n * Get the name property needed to identify a DOM node in riot\n * @param   { Object } dom - DOM node we need to parse\n * @returns { String | undefined } give us back a string to identify this dom node\n */\nfunction getNamedKey(dom) {\n  return getAttr(dom, 'id') || getAttr(dom, 'name')\n}\n\n/**\n * Set the named properties of a tag element\n * @param { Object } dom - DOM node we need to parse\n * @param { Object } parent - tag instance where the named dom element will be eventually added\n * @param { Array } keys - list of all the tag instance properties\n */\nfunction setNamed(dom, parent, keys) {\n  // get the key value we want to add to the tag instance\n  var key = getNamedKey(dom),\n    // add the node detected to a tag instance using the named property\n    add = function(value) {\n      // avoid to override the tag properties already set\n      if (contains(keys, key)) return\n      // check whether this value is an array\n      var isArr = isArray(value)\n      // if the key was never set\n      if (!value)\n        // set it once on the tag instance\n        parent[key] = dom\n      // if it was an array and not yet set\n      else if (!isArr || isArr && !contains(value, dom)) {\n        // add the dom node into the array\n        if (isArr)\n          value.push(dom)\n        else\n          parent[key] = [value, dom]\n      }\n    }\n\n  // skip the elements with no named properties\n  if (!key) return\n\n  // check whether this key has been already evaluated\n  if (tmpl.hasExpr(key))\n    // wait the first updated event only once\n    parent.one('updated', function() {\n      key = getNamedKey(dom)\n      add(parent[key])\n    })\n  else\n    add(parent[key])\n\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } src - source string\n * @param   { String } str - test string\n * @returns { Boolean } -\n */\nfunction startsWith(src, str) {\n  return src.slice(0, str.length) === str\n}\n\n/**\n * Function needed to inject in runtime the custom tags css\n */\nvar injectStyle = (function() {\n\n  if (!window) return // skip injection on the server\n\n  // create the style node\n  var styleNode = mkEl('style'),\n    placeholder = $('style[type=riot]')\n\n  setAttr(styleNode, 'type', 'text/css')\n\n  // inject the new node into the DOM -- in head\n  if (placeholder) {\n    placeholder.parentNode.replaceChild(styleNode, placeholder)\n    placeholder = null\n  }\n  else document.getElementsByTagName('head')[0].appendChild(styleNode)\n\n  /**\n   * This is the function exported that will be used to update the style tag just created\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @param   { String } css [description]\n   */\n  return styleNode.styleSheet ?\n    function (css) { styleNode.styleSheet.cssText += css } :\n    function (css) { styleNode.innerHTML += css }\n\n})()\n\n/**\n * requestAnimationFrame polyfill\n */\nvar rAF = (function(w) {\n  return  w.requestAnimationFrame       ||\n          w.webkitRequestAnimationFrame ||\n          w.mozRequestAnimationFrame    ||\n          function(cb) { setTimeout(cb, 1000 / 60) }\n})(window || {})\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts) {\n  var tag = __tagImpl[tagName],\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    // add this tag to the virtualDom variable\n    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)\n  }\n\n  return tag\n}\n/**\n * Riot public api\n */\n\n// share methods for other riot parts, e.g. compiler\nriot.util = { brackets: brackets, tmpl: tmpl }\n\n/**\n * Create a mixin that could be globally shared across all the tags\n */\nriot.mixin = (function() {\n  var mixins = {}\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String } name - mixin name\n   * @param   { Object } mixin - mixin logic\n   * @returns { Object } the mixin logic\n   */\n  return function(name, mixin) {\n    if (!mixin) return mixins[name]\n    mixins[name] = mixin\n  }\n\n})()\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nriot.tag = function(name, html, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css\n      css = ''\n    } else attrs = ''\n  }\n  if (css) {\n    if (isFunction(css)) fn = css\n    else if (injectStyle) injectStyle(css)\n  }\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   html - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @param   { string }  [bpair] - brackets used in the compilation\n * @returns { String } name/id of the tag just created\n */\nriot.tag2 = function(name, html, css, attrs, fn, bpair) {\n  if (css && injectStyle) injectStyle(css)\n  //if (bpair) riot.settings.brackets = bpair\n  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { String } selector - tag DOM selector\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nriot.mount = function(selector, tagName, opts) {\n\n  var els,\n    allTags,\n    tags = []\n\n  // helper functions\n\n  function addRiotTags(arr) {\n    var list = ''\n    each(arr, function (e) {\n      list += ', *[' + RIOT_TAG + '=\"' + e.trim() + '\"]'\n    })\n    return list\n  }\n\n  function selectAllTags() {\n    var keys = Object.keys(__tagImpl)\n    return keys + addRiotTags(keys)\n  }\n\n  function pushTags(root) {\n    var last\n\n    if (root.tagName) {\n      if (tagName && (!(last = getAttr(root, RIOT_TAG)) || last != tagName))\n        setAttr(root, RIOT_TAG, tagName)\n\n      var tag = mountTo(root, tagName || root.getAttribute(RIOT_TAG) || root.tagName.toLowerCase(), opts)\n\n      if (tag) tags.push(tag)\n    } else if (root.length)\n      each(root, pushTags)   // assume nodeList\n\n  }\n\n  // ----- mount code -----\n\n  if (typeof tagName === T_OBJECT) {\n    opts = tagName\n    tagName = 0\n  }\n\n  // crawl the DOM to find the tag\n  if (typeof selector === T_STRING) {\n    if (selector === '*')\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selectAllTags()\n    else\n      // or just the ones named like the selector\n      selector += addRiotTags(selector.split(','))\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    els = selector ? $$(selector) : []\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    els = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectAllTags()\n    // if the root els it's just a single tag\n    if (els.tagName)\n      els = $$(tagName, els)\n    else {\n      // select all the children for all the different root elements\n      var nodeList = []\n      each(els, function (_el) {\n        nodeList.push($$(tagName, _el))\n      })\n      els = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  if (els.tagName)\n    pushTags(els)\n  else\n    each(els, pushTags)\n\n  return tags\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nriot.update = function() {\n  return each(__virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n/**\n * Export the Tag constructor\n */\nriot.Tag = Tag\n/* istanbul ignore next */\n\n/**\n * @module parsers\n */\nvar parsers = (function () {\n  var _mods = {\n    none: function (js) {\n      return js\n    }\n  }\n  _mods.javascript = _mods.none\n\n  function _try(name, req) {  //eslint-disable-line complexity\n    var parser\n\n    switch (name) {\n    case 'coffee':\n      req = 'CoffeeScript'\n      break\n    case 'es6':\n    case 'babel':\n      req = 'babel'\n      break\n    case 'none':\n    case 'javascript':\n      return _mods.none\n    default:\n      if (!req) req = name\n      break\n    }\n    parser = window[req]\n\n    if (!parser)\n      throw new Error(req + ' parser not found.')\n    _mods[name] = parser\n\n    return parser\n  }\n\n  function _req(name, req) {\n    return name in _mods ? _mods[name] : _try(name, req)\n  }\n\n  var _html = {\n    jade: function (html, opts, url) {\n      return _req('jade').render(html, extend({\n        pretty: true,\n        filename: url,\n        doctype: 'html'\n      }, opts))\n    }\n  }\n\n  var _css = {\n    less: function(tag, css, opts, url) {\n      var less = _req('less'),\n        ret\n\n      less.render(css, extend({\n        sync: true,\n        compress: true\n      }, opts), function (err, result) {\n        // istanbul ignore next\n        if (err) throw err\n        ret = result.css\n      })\n      return ret\n    },\n    stylus: function (tag, css, opts, url) {\n      var\n        stylus = _req('stylus'), nib = _req('nib')\n      /* istanbul ignore next: can't run both */\n      return nib ?\n        stylus(css).use(nib()).import('nib').render() : stylus.render(css)\n    }\n  }\n\n  var _js = {\n    livescript: function (js, opts, url) {\n      return _req('livescript').compile(js, extend({bare: true, header: false}, opts))\n    },\n    typescript: function (js, opts, url) {\n      return _req('typescript')(js, opts).replace(/\\r\\n?/g, '\\n')\n    },\n    es6: function (js, opts, url) {\n      return _req('es6').transform(js, extend({\n        blacklist: ['useStrict', 'strict', 'react'], sourceMaps: false, comments: false\n      }, opts)).code\n    },\n    babel: function (js, opts, url) {\n      // istanbul ignore next: url empty if comming from expression\n      return _req('babel').transform(js,\n        extend({\n          filename: url || ''\n        }, opts)\n      ).code\n    },\n    coffee: function (js, opts, url) {\n      return _req('coffee').compile(js, extend({bare: true}, opts))\n    },\n    none: _mods.none\n  }\n\n  _js.javascript   = _js.none\n  _js.coffeescript = _js.coffee\n\n  return {\n    html: _html,\n    css: _css,\n    js: _js,\n    _req: _req}\n\n})()\n\nriot.parsers = parsers\n\n/**\n * Compiler for riot custom tags\n * @version v2.3.19\n */\nvar compile = (function () {\n\n  function _regEx(str, opt) { return new RegExp(str, opt) }\n\n  var\n\n    BOOL_ATTRS = _regEx(\n      '^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|' +\n      'compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|' +\n      'multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|' +\n      'selected|sortable|truespeed|typemustmatch)$'),\n\n    RIOT_ATTRS = ['style', 'src', 'd'],\n\n    VOID_TAGS  = /^(?:input|img|br|wbr|hr|area|base|col|embed|keygen|link|meta|param|source|track)$/,\n\n    HTML_ATTR  = /\\s*([-\\w:\\xA0-\\xFF]+)\\s*(?:=\\s*('[^']+'|\"[^\"]+\"|\\S+))?/g,\n\n    TRIM_TRAIL = /[ \\t]+$/gm\n\n  function q(s) {\n    return \"'\" + (s ? s\n      .replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\").replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r') :\n      '') + \"'\"\n  }\n\n  function mktag(name, html, css, attrs, js, pcex) {\n    var\n      c = ', ',\n      s = '}' + (pcex.length ? ', ' + q(pcex._bp[8]) : '') + ');'\n\n    if (js && js.slice(-1) !== '\\n') s = '\\n' + s\n\n    return 'riot.tag2(\\'' + name + \"'\" + c + q(html) + c + q(css) + c + q(attrs) +\n           ', function(opts) {\\n' + js + s\n  }\n\n  function extend(obj, props) {\n    for (var prop in props) {\n      /* istanbul ignore next */\n      if (props.hasOwnProperty(prop)) {\n        obj[prop] = props[prop]\n      }\n    }\n    return obj\n  }\n\n  function parseAttrs(str, pcex) {\n    var\n      list = [],\n      match,\n      k, v,\n      _bp = pcex._bp,\n      DQ = '\"'\n\n    HTML_ATTR.lastIndex = 0\n\n    str = str.replace(/\\s+/g, ' ')\n\n    while (match = HTML_ATTR.exec(str)) {\n\n      k = match[1].toLowerCase()\n      v = match[2]\n\n      if (!v) {\n        list.push(k)\n      }\n      else {\n\n        if (v[0] !== DQ)\n          v = DQ + (v[0] === \"'\" ? v.slice(1, -1) : v) + DQ\n\n        if (k === 'type' && v.toLowerCase() === '\"number\"') {\n          v = DQ + _bp[0] + \"'number'\" + _bp[1] + DQ\n        }\n        else if (/\\u0001\\d/.test(v)) {\n\n          if (BOOL_ATTRS.test(k)) {\n            k = '__' + k\n          }\n          else if (~RIOT_ATTRS.indexOf(k)) {\n            k = 'riot-' + k\n          }\n        }\n\n        list.push(k + '=' + v)\n      }\n    }\n    return list.join(' ')\n  }\n\n  function splitHtml(html, opts, pcex) {\n    var _bp = pcex._bp\n\n    if (html && _bp[4].test(html)) {\n      var\n        jsfn = opts.expr && (opts.parser || opts.type) ? _compileJS : 0,\n        list = brackets.split(html, 0, _bp),\n        expr\n\n      for (var i = 1; i < list.length; i += 2) {\n        expr = list[i]\n        if (expr[0] === '^')\n          expr = expr.slice(1)\n        else if (jsfn) {\n          var israw = expr[0] === '='\n          expr = jsfn(israw ? expr.slice(1) : expr, opts).trim()\n          if (expr.slice(-1) === ';') expr = expr.slice(0, -1)\n          if (israw) expr = '=' + expr\n        }\n        list[i] = '\\u0001' + (pcex.push(expr.replace(/[\\r\\n]+/g, ' ').trim()) - 1) + _bp[1]\n      }\n      html = list.join('')\n    }\n    return html\n  }\n\n  function restoreExpr(html, pcex) {\n    if (pcex.length) {\n      html = html\n        .replace(/\\u0001(\\d+)/g, function (_, d) {\n          var expr = pcex[d]\n          if (expr[0] === '=') {\n            expr = expr.replace(brackets.R_STRINGS, function (qs) {\n              return qs\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;')\n            })\n          }\n          return pcex._bp[0] + expr.replace(/\"/g, '\\u2057')\n        })\n    }\n    return html\n  }\n\n  var\n    HTML_COMMENT = /<!--(?!>)[\\S\\s]*?-->/g,\n    HTML_TAGS = /<([-\\w]+)\\s*([^\"'\\/>]*(?:(?:\"[^\"]*\"|'[^']*'|\\/[^>])[^'\"\\/>]*)*)(\\/?)>/g,\n    PRE_TAG = _regEx(\n      /<pre(?:\\s+[^'\">]+(?:(?:@Q)[^'\">]*)*|\\s*)?>([\\S\\s]*?)<\\/pre\\s*>/\n      .source.replace('@Q', brackets.R_STRINGS.source), 'gi')\n\n  function _compileHTML(html, opts, pcex) {\n\n    html = splitHtml(html, opts, pcex)\n      .replace(HTML_TAGS, function (_, name, attr, ends) {\n\n        name = name.toLowerCase()\n\n        ends = ends && !VOID_TAGS.test(name) ? '></' + name : ''\n\n        if (attr) name += ' ' + parseAttrs(attr, pcex)\n\n        return '<' + name + ends + '>'\n      })\n\n    if (!opts.whitespace) {\n      if (/<pre[\\s>]/.test(html)) {\n        var p = []\n        html = html.replace(PRE_TAG, function (q)\n          { return p.push(q) && '\\u0002' }).trim().replace(/\\s+/g, ' ')\n        // istanbul ignore else\n        if (p.length)\n          html = html.replace(/\\u0002/g, function (_) { return p.shift() })\n      }\n      else\n        html = html.trim().replace(/\\s+/g, ' ')\n    }\n\n    if (opts.compact) html = html.replace(/> <([-\\w\\/])/g, '><$1')\n\n    return restoreExpr(html, pcex)\n  }\n\n  // istanbul ignore next\n  function compileHTML(html, opts, pcex) {\n    if (Array.isArray(opts)) {\n      pcex = opts\n      opts = {}\n    }\n    else {\n      if (!pcex) pcex = []\n      if (!opts) opts = {}\n    }\n\n    if (!pcex.__intflag)\n      html = html.replace(/\\r\\n?/g, '\\n').replace(HTML_COMMENT, '').replace(TRIM_TRAIL, '')\n\n    if (!pcex._bp) pcex._bp = brackets.array(opts.brackets)\n\n    return _compileHTML(html, opts, pcex)\n  }\n\n  var\n    JS_RMCOMMS = _regEx('(' + brackets.S_QBLOCKS + ')|' + brackets.R_MLCOMMS.source + '|//[^\\r\\n]*', 'g'),\n    JS_ES6SIGN = /^([ \\t]*)([$_A-Za-z][$\\w]*)\\s*(\\([^()]*\\)\\s*{)/m\n\n  function riotjs(js) {\n    var\n      match,\n      toes5,\n      parts = [],\n      pos\n\n    js = js.replace(JS_RMCOMMS, function (m, q) { return q ? m : ' ' })\n\n    while (match = js.match(JS_ES6SIGN)) {\n\n      parts.push(RegExp.leftContext)\n      js  = RegExp.rightContext\n      pos = skipBlock(js)\n\n      toes5 = !/^(?:if|while|for|switch|catch|function)$/.test(match[2])\n      if (toes5)\n        match[0] = match[1] + 'this.' + match[2] + ' = function' + match[3]\n\n      parts.push(match[0], js.slice(0, pos))\n      js = js.slice(pos)\n      if (toes5 && !/^\\s*.\\s*bind\\b/.test(js)) parts.push('.bind(this)')\n    }\n\n    return parts.length ? parts.join('') + js : js\n\n    function skipBlock(str) {\n      var\n        re = _regEx('([{}])|' + brackets.S_QBLOCKS, 'g'),\n        level = 1,\n        match\n\n      while (level && (match = re.exec(str))) {\n        if (match[1])\n          match[1] === '{' ? ++level : --level\n      }\n      return level ? str.length : re.lastIndex\n    }\n  }\n\n  function _compileJS(js, opts, type, parserOpts, url) {\n    if (!js) return ''\n    if (!type) type = opts.type\n\n    var parser = opts.parser || (type ? parsers.js[type] : riotjs)\n    if (!parser)\n      throw new Error('JS parser not found: \"' + type + '\"')\n\n    return parser(js, parserOpts, url).replace(TRIM_TRAIL, '')\n  }\n\n  // istanbul ignore next\n  function compileJS(js, opts, type, extra) {\n    if (typeof opts === 'string') {\n      extra = type\n      type = opts\n      opts = {}\n    }\n    if (typeof type === 'object') {\n      extra = type\n      type = ''\n    }\n    else if (!extra) extra = {}\n\n    return _compileJS(js, opts, type, extra.parserOptions, extra.url)\n  }\n\n  var CSS_SELECTOR = _regEx('(}|{|^)[ ;]*([^@ ;{}][^{}]*)(?={)|' + brackets.R_STRINGS.source, 'g')\n\n  function scopedCSS(tag, style) {\n    var scope = ':scope'\n\n    return style.replace(CSS_SELECTOR, function (m, p1, p2) {\n\n      if (!p2) return m\n\n      p2 = p2.replace(/[^,]+/g, function (sel) {\n        var s = sel.trim()\n\n        if (s && s !== 'from' && s !== 'to' && s.slice(-1) !== '%') {\n\n          if (s.indexOf(scope) < 0) s = scope + ' ' + s\n          s = s.replace(scope, tag) + ',' +\n              s.replace(scope, '[riot-tag=\"' + tag + '\"]')\n        }\n        return sel.slice(-1) === ' ' ? s + ' ' : s\n      })\n\n      return p1 ? p1 + ' ' + p2 : p2\n    })\n  }\n\n  function _compileCSS(style, tag, type, opts) {\n    var scoped = (opts || (opts = {})).scoped\n\n    if (type) {\n      if (type === 'scoped-css') {\n        scoped = true\n      }\n      else if (parsers.css[type]) {\n        style = parsers.css[type](tag, style, opts.parserOpts, opts.url)\n      }\n      else if (type !== 'css') {\n        throw new Error('CSS parser not found: \"' + type + '\"')\n      }\n    }\n\n    style = style.replace(brackets.R_MLCOMMS, '').replace(/\\s+/g, ' ').trim()\n\n    if (scoped) {\n      // istanbul ignore next\n      if (!tag)\n        throw new Error('Can not parse scoped CSS without a tagName')\n      style = scopedCSS(tag, style)\n    }\n    return style\n  }\n\n  // istanbul ignore next\n  function compileCSS(style, parser, opts) {\n    if (typeof parser === 'object') {\n      opts = parser\n      parser = ''\n    }\n    else if (!opts) opts = {}\n    return _compileCSS(style, opts.tagName, parser, opts)\n  }\n\n  var\n    TYPE_ATTR = /\\stype\\s*=\\s*(?:(['\"])(.+?)\\1|(\\S+))/i,\n    MISC_ATTR = /\\s*=\\s*(\"(?:\\\\[\\S\\s]|[^\"\\\\]*)*\"|'(?:\\\\[\\S\\s]|[^'\\\\]*)*'|\\{[^}]+}|\\S+)/.source\n\n  function getType(str) {\n\n    if (str) {\n      var match = str.match(TYPE_ATTR)\n      str = match && (match[2] || match[3])\n    }\n    return str ? str.replace('text/', '') : ''\n  }\n\n  function getAttr(str, name) {\n\n    if (str) {\n      var\n        re = _regEx('\\\\s' + name + MISC_ATTR, 'i'),\n        match = str.match(re)\n      str = match && match[1]\n      if (str)\n        return (/^['\"]/).test(str) ? str.slice(1, -1) : str\n    }\n    return ''\n  }\n\n  function getParserOptions(attrs) {\n    var opts = getAttr(attrs, 'options')\n\n    if (opts) opts = JSON.parse(opts)\n    return opts\n  }\n\n  function getCode(code, opts, attrs, url) {\n    var type = getType(attrs),\n      parserOpts = getParserOptions(attrs)\n\n    return _compileJS(code, opts, type, parserOpts, url)\n  }\n\n  var END_TAGS = /\\/>\\n|^<(?:\\/[\\w\\-]+\\s*|[\\w\\-]+(?:\\s+(?:[-\\w:\\xA0-\\xFF][\\S\\s]*?)?)?)>\\n/\n\n  function splitBlocks(str) {\n    var k, m\n\n    /* istanbul ignore next: this if() can't be true, but just in case... */\n    if (str[str.length - 1] === '>') return [str, '']\n\n    k = str.lastIndexOf('<')\n    while (~k) {\n      if (m = str.slice(k).match(END_TAGS)) {\n        k += m.index + m[0].length\n        return [str.slice(0, k), str.slice(k)]\n      }\n      k = str.lastIndexOf('<', k -1)\n    }\n    return ['', str]\n  }\n\n  function compileTemplate(html, url, lang, opts) {\n    var parser = parsers.html[lang]\n\n    if (!parser)\n      throw new Error('Template parser not found: \"' + lang + '\"')\n\n    return parser(html, opts, url)\n  }\n\n  var\n    CUST_TAG = _regEx(\n      /^([ \\t]*)<([-\\w]+)(?:\\s+([^'\"\\/>]+(?:(?:@Q|\\/[^>])[^'\"\\/>]*)*)|\\s*)?(?:\\/>|>[ \\t]*\\n?([\\S\\s]*)^\\1<\\/\\2\\s*>|>(.*)<\\/\\2\\s*>)/\n      .source.replace('@Q', brackets.R_STRINGS.source), 'gim'),\n    STYLE = /<style(\\s+[^>]*)?>\\n?([^<]*(?:<(?!\\/style\\s*>)[^<]*)*)<\\/style\\s*>/gi,\n    SCRIPT = _regEx(STYLE.source.replace(/tyle/g, 'cript'), 'gi')\n\n  function compile(src, opts, url) {\n    var\n      parts = [],\n      exclude\n\n    if (!opts) opts = {}\n\n    exclude = opts.exclude || false\n    function included(s) { return !(exclude && ~exclude.indexOf(s)) }\n\n    var _bp = brackets.array(opts.brackets)\n\n    if (opts.template)\n      src = compileTemplate(src, url, opts.template, opts.templateOptions)\n\n    src = src\n      .replace(/\\r\\n?/g, '\\n')\n      .replace(CUST_TAG, function (_, indent, tagName, attribs, body, body2) {\n\n        var\n          jscode = '',\n          styles = '',\n          html = '',\n          pcex = []\n\n        pcex._bp = _bp\n        pcex.__intflag = 1\n\n        tagName = tagName.toLowerCase()\n\n        attribs = attribs && included('attribs') ?\n          restoreExpr(parseAttrs(splitHtml(attribs, opts, pcex), pcex), pcex) : ''\n\n        if (body2) body = body2\n\n        if (body && (body = body.replace(HTML_COMMENT, '')) && /\\S/.test(body)) {\n\n          if (body2) {\n            /* istanbul ignore next */\n            html = included('html') ? _compileHTML(body2, opts, pcex) : ''\n          }\n          else {\n            body = body.replace(_regEx('^' + indent, 'gm'), '')\n\n            body = body.replace(STYLE, included('css') ? function (_, _attrs, _style) {\n              var extraOpts = {\n                scoped: _attrs && /\\sscoped(\\s|=|$)/i.test(_attrs),\n                url: url,\n                parserOpts: getParserOptions(_attrs)\n              }\n              styles += (styles ? ' ' : '') +\n                _compileCSS(_style, tagName, getType(_attrs) || opts.style, extraOpts)\n              return ''\n            } : '')\n\n            body = body.replace(SCRIPT, included('js') ? function (_, _attrs, _script) {\n              jscode += (jscode ? '\\n' : '') + getCode(_script, opts, _attrs, url)\n              return ''\n            } : '')\n\n            var blocks = splitBlocks(body.replace(TRIM_TRAIL, ''))\n\n            if (included('html')) {\n              body = blocks[0]\n              if (body)\n                html = _compileHTML(body, opts, pcex)\n            }\n\n            if (included('js')) {\n              body = blocks[1]\n              if (/\\S/.test(body))\n                jscode += (jscode ? '\\n' : '') + _compileJS(body, opts, null, null, url)\n            }\n          }\n        }\n\n        jscode = /\\S/.test(jscode) ? jscode.replace(/\\n{3,}/g, '\\n\\n') : ''\n\n        if (opts.entities) {\n          parts.push({\n            tagName: tagName,\n            html: html,\n            css: styles,\n            attribs: attribs,\n            js: jscode\n          })\n          return ''\n        }\n\n        return mktag(tagName, html, styles, attribs, jscode, pcex)\n      })\n\n    if (opts.entities) return parts\n\n    return src\n  }\n\n  riot.util.compiler = {\n    compile: compile,\n    html: compileHTML,\n    css: compileCSS,\n    js: compileJS,\n    version: 'v2.3.19'\n  }\n  return compile\n\n})()\n\n/*\n  Compilation for the browser\n*/\nriot.compile = (function () {\n\n  var\n    doc = window.document,\n    promise,\n    ready\n\n  function GET(url, fn, opts) {\n    var req = new XMLHttpRequest()\n\n    req.onreadystatechange = function() {\n      if (req.readyState === 4 &&\n         (req.status === 200 || !req.status && req.responseText.length))\n        fn(req.responseText, opts, url)\n    }\n    req.open('GET', url, true)\n    req.send('')\n  }\n\n  function globalEval(js) {\n    var\n      node = doc.createElement('script'),\n      root = doc.documentElement\n\n    node.text = js\n    root.appendChild(node)\n    root.removeChild(node)\n  }\n\n  function compileScripts(fn, exopt) {\n    var\n      scripts = doc.querySelectorAll('script[type=\"riot/tag\"]'),\n      scriptsAmount = scripts.length\n\n    function done() {\n      promise.trigger('ready')\n      ready = true\n      if (fn) fn()\n    }\n\n    function compileTag(src, opts, url) {\n      var code = compile(src, opts, url)\n\n      if (url) code += '\\n//# sourceURL=' + url + '.js'\n      globalEval(code)\n      if (!--scriptsAmount) done()\n    }\n\n    if (!scriptsAmount) done()\n    else {\n      for (var i = 0; i < scripts.length; ++i) {\n        var\n          script = scripts[i],\n          opts = {template: script.getAttribute('template')},\n          url = script.getAttribute('src')\n\n        if (exopt) opts = extend(opts, exopt)\n        url ? GET(url, compileTag, opts) : compileTag(script.innerHTML, opts)\n      }\n    }\n  }\n\n  //// Entry point -----\n\n  return function (arg, fn, opts) {\n\n    if (typeof arg === 'string') {\n\n      if (typeof fn === 'object') {\n        opts = fn\n        fn = false\n      }\n\n      if (/^\\s*</.test(arg)) {\n\n        // `riot.compile(tag [, true][, options])`\n        var js = compile(arg, opts)\n        if (!fn) globalEval(js)\n        return js\n      }\n\n      // `riot.compile(url [, callback][, options])`\n      GET(arg, function (str) {\n        var js = compile(str, opts, arg)\n        globalEval(js)\n        if (fn) fn(js, str)\n      })\n\n    }\n    else {\n\n      // `riot.compile([callback][, options])`\n\n      if (typeof arg === 'function') {\n        opts = fn\n        fn = arg\n      }\n      else {\n        opts = arg\n        fn = undefined\n      }\n\n      if (ready)\n        return fn && fn()\n\n      if (promise) {\n        if (fn) promise.on('ready', fn)\n\n      } else {\n        promise = riot.observable()\n        compileScripts(fn, opts)\n      }\n    }\n  }\n\n})()\n\n// reassign mount methods -----\nvar mount = riot.mount\n\nriot.mount = function(a, b, c) {\n  var ret\n  riot.compile(function() { ret = mount(a, b, c) })\n  return ret\n}\n  // support CommonJS, AMD & browser\n  /* istanbul ignore next */\n  if (typeof exports === T_OBJECT)\n    module.exports = riot\n  else if (typeof define === T_FUNCTION && typeof define.amd !== T_UNDEF)\n    define(function() { return (window.riot = riot) })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : void 0);\n","date":"2015-12-17T03:11:20.948Z","updated":"2015-12-15T21:11:22.000Z","path":"unrest/bower_components/riot/riot+compiler.js","layout":"false","title":"","comments":1,"_id":"cijth4lay000e0nfwekk1vx4k"},{"_content":"{\n  \"name\": \"riot\",\n  \"version\": \"2.3.12\",\n  \"description\": \"A React-like user interface micro-library\",\n  \"homepage\": \"http://riotjs.com/\",\n  \"repository\": { \"type\": \"git\", \"url\": \"git://github.com/riot/riot.git\" },\n  \"authors\": [\"Muut, Inc. and other contributors\"],\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"custom tags\",\n    \"custom elements\",\n    \"web components\",\n    \"virtual dom\",\n    \"shadow dom\",\n    \"polymer\",\n    \"react\",\n    \"jsx\",\n    \"minimal\",\n    \"minimalist\",\n    \"client-side\",\n    \"framework\",\n    \"declarative\",\n    \"templating\",\n    \"template\",\n    \"data binding\",\n    \"mvc\",\n    \"router\",\n    \"model\",\n    \"view\",\n    \"controller\",\n    \"riotjs\",\n    \"riot.js\"\n  ],\n  \"ignore\": [\n    \"**/*\",\n    \"!/riot.js\",\n    \"!/riot.min.js\",\n    \"!/riot+compiler.js\",\n    \"!/riot+compiler.min.js\"\n  ],\n  \"main\": \"riot.js\"\n}\n","source":"unrest/bower_components/riot/bower.json","raw":"{\n  \"name\": \"riot\",\n  \"version\": \"2.3.12\",\n  \"description\": \"A React-like user interface micro-library\",\n  \"homepage\": \"http://riotjs.com/\",\n  \"repository\": { \"type\": \"git\", \"url\": \"git://github.com/riot/riot.git\" },\n  \"authors\": [\"Muut, Inc. and other contributors\"],\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"custom tags\",\n    \"custom elements\",\n    \"web components\",\n    \"virtual dom\",\n    \"shadow dom\",\n    \"polymer\",\n    \"react\",\n    \"jsx\",\n    \"minimal\",\n    \"minimalist\",\n    \"client-side\",\n    \"framework\",\n    \"declarative\",\n    \"templating\",\n    \"template\",\n    \"data binding\",\n    \"mvc\",\n    \"router\",\n    \"model\",\n    \"view\",\n    \"controller\",\n    \"riotjs\",\n    \"riot.js\"\n  ],\n  \"ignore\": [\n    \"**/*\",\n    \"!/riot.js\",\n    \"!/riot.min.js\",\n    \"!/riot+compiler.js\",\n    \"!/riot+compiler.min.js\"\n  ],\n  \"main\": \"riot.js\"\n}\n","date":"2015-12-17T03:11:20.944Z","updated":"2015-12-15T21:11:22.000Z","path":"unrest/bower_components/riot/bower.json","layout":"false","title":"","comments":1,"_id":"cijth4lb1000f0nfw0c0ahrbi"},{"_content":"{\n  \"name\": \"unrest\",\n  \"version\": \"0.0.0\",\n  \"authors\": [\n    \"chriscauley <chris@lablackey.com>\"\n  ],\n  \"description\": \"baby's first bower package\",\n  \"main\": \"test.js\",\n  \"keywords\": [\n    \"riot.js\"\n  ],\n  \"license\": \"MIT\",\n  \"ignore\": [\n    \"**/.*\",\n    \"node_modules\",\n    \"bower_components\",\n    \"test\",\n    \"tests\",\n    \"*~\"\n  ],\n  \"homepage\": \"https://github.com/chriscauley/unrest\",\n  \"dependencies\": {\n    \"riot\": \"~2.3.12\"\n  }\n}\n","source":"unrest/bower.json","raw":"{\n  \"name\": \"unrest\",\n  \"version\": \"0.0.0\",\n  \"authors\": [\n    \"chriscauley <chris@lablackey.com>\"\n  ],\n  \"description\": \"baby's first bower package\",\n  \"main\": \"test.js\",\n  \"keywords\": [\n    \"riot.js\"\n  ],\n  \"license\": \"MIT\",\n  \"ignore\": [\n    \"**/.*\",\n    \"node_modules\",\n    \"bower_components\",\n    \"test\",\n    \"tests\",\n    \"*~\"\n  ],\n  \"homepage\": \"https://github.com/chriscauley/unrest\",\n  \"dependencies\": {\n    \"riot\": \"~2.3.12\"\n  }\n}\n","date":"2015-12-17T03:11:20.976Z","updated":"2015-12-17T03:11:20.976Z","path":"unrest/bower.json","layout":"false","title":"","comments":1,"_id":"cijth4lb3000g0nfw3k77h1zi"},{"_content":"var header = document.querySelector(\"header\");\nvar last_scroll = 0;\nvar header_y = -header.scrollHeight;\nwindow.addEventListener(\"scroll\",function() {\n  var fixed = false;\n  if (window.scrollY<2*header.scrollHeight) {\n    //havent scrolled past header\n    header_y = -header.scrollHeight;\n  } else {\n    header.className = \"fixed\"; // you may prefer header.classList.add(\"fixed\")\n    header_y = header_y - (window.scrollY-last_scroll);\n    header_y = Math.min(header_y,0);\n    header_y = Math.max(header_y,-header.scrollHeight);\n    header.style.top = header_y + \"px\";\n  }\n  last_scroll = window.scrollY;\n  if (window.scrollY == 0) {\n    header.className = \"\"; // you may prefer header.classList.remove(\"fixed\")\n    header.style.top = 0;\n  }\n});\n","source":"downloads/code/2016/01/scroll.js","raw":"var header = document.querySelector(\"header\");\nvar last_scroll = 0;\nvar header_y = -header.scrollHeight;\nwindow.addEventListener(\"scroll\",function() {\n  var fixed = false;\n  if (window.scrollY<2*header.scrollHeight) {\n    //havent scrolled past header\n    header_y = -header.scrollHeight;\n  } else {\n    header.className = \"fixed\"; // you may prefer header.classList.add(\"fixed\")\n    header_y = header_y - (window.scrollY-last_scroll);\n    header_y = Math.min(header_y,0);\n    header_y = Math.max(header_y,-header.scrollHeight);\n    header.style.top = header_y + \"px\";\n  }\n  last_scroll = window.scrollY;\n  if (window.scrollY == 0) {\n    header.className = \"\"; // you may prefer header.classList.remove(\"fixed\")\n    header.style.top = 0;\n  }\n});\n","date":"2016-01-25T04:28:19.932Z","updated":"2016-01-25T04:28:19.932Z","path":"downloads/code/2016/01/scroll.js","layout":"false","title":"","comments":1,"_id":"cijth4lb5000h0nfwy7xdgpbk"},{"_content":"body {\n  padding-top: 50px;\n}\n\nheader {\n  background: white;\n  left: 0;\n  line-height: 50px;\n  height: 50px;\n  padding: 0 5px;\n  position: absolute;\n  right: 0;\n  top:0;\n}\n/* This is the only crutial piece of css */\nheader.fixed { position: fixed; }","source":"downloads/code/2016/01/scroll.css","raw":"body {\n  padding-top: 50px;\n}\n\nheader {\n  background: white;\n  left: 0;\n  line-height: 50px;\n  height: 50px;\n  padding: 0 5px;\n  position: absolute;\n  right: 0;\n  top:0;\n}\n/* This is the only crutial piece of css */\nheader.fixed { position: fixed; }","date":"2016-01-25T04:28:19.932Z","updated":"2016-01-25T04:28:19.932Z","path":"downloads/code/2016/01/scroll.css","layout":"false","title":"","comments":1,"_id":"cijth4lb7000i0nfwgmnmonsz"}],"Post":[{"layout":"post","title":"CSS Serpinski Triangle","description":"","category":null,"_content":"\n<ur-tabs>\n  <ur-tab id=\"demo\">\n    {% include \"css-serpinski-triangle/index.html\" %}\n  </ur-tab>\n  <ur-tab id=\"css\">\n{% codeblock lang:css %}\n{% include \"css-serpinski-triangle/serpinski.css\" %}\n{% endcodeblock %}\n  </ur-tab>\n  <ur-tab id=\"html\">\n{% codeblock lang:html %}\n    <div id=\"serpinski\">\n      <div>\n        <div></div> <!--               -->\n        <div></div> <!-- One unit cell -->\n        <div></div> <!--               -->\n      </div>\n    </div>\n{% endcodeblock %}\n  </ur-tab>\n</ur-tabs>\n\n<p>A pure css Serpinski Triangle I made. The each unit cell has three divs, and to extend the fractal one level you just add three more divs in each empty div. Each div is `width: 50%; height: 50%;` of the parent div. The divs are then floated, making a square with three squares inside of it, and the forth quadrant is empty.</p>\n\n<p>Normally pure css trangles are made using elements with `width: 0; height: 0` and a border with asymetrick coloring. If you are unfamiliar with this technique, you can read more at [CSS Tricks](http://css-tricks.com/snippets/css/css-triangle/ \"Pure CSS Triangle\"). However, because borders can't be percentages, this doesn't work with fractals. Instead we use a square, rotated pseudo elements (the `div:before` in the above css). The parent of the pseudo element is overflow hidden. Here's the full CSS. Feel free to email me if you want to know more. I may post more on this later.</p>\n","source":"_posts/2014/03/css-serpinski-triangle.md","raw":"---\nlayout: post\ntitle: \"CSS Serpinski Triangle\"\ndescription: \"\"\ncategory: \ntags: [css,fractals]\n---\n\n<ur-tabs>\n  <ur-tab id=\"demo\">\n    {% include \"css-serpinski-triangle/index.html\" %}\n  </ur-tab>\n  <ur-tab id=\"css\">\n{% codeblock lang:css %}\n{% include \"css-serpinski-triangle/serpinski.css\" %}\n{% endcodeblock %}\n  </ur-tab>\n  <ur-tab id=\"html\">\n{% codeblock lang:html %}\n    <div id=\"serpinski\">\n      <div>\n        <div></div> <!--               -->\n        <div></div> <!-- One unit cell -->\n        <div></div> <!--               -->\n      </div>\n    </div>\n{% endcodeblock %}\n  </ur-tab>\n</ur-tabs>\n\n<p>A pure css Serpinski Triangle I made. The each unit cell has three divs, and to extend the fractal one level you just add three more divs in each empty div. Each div is `width: 50%; height: 50%;` of the parent div. The divs are then floated, making a square with three squares inside of it, and the forth quadrant is empty.</p>\n\n<p>Normally pure css trangles are made using elements with `width: 0; height: 0` and a border with asymetrick coloring. If you are unfamiliar with this technique, you can read more at [CSS Tricks](http://css-tricks.com/snippets/css/css-triangle/ \"Pure CSS Triangle\"). However, because borders can't be percentages, this doesn't work with fractals. Instead we use a square, rotated pseudo elements (the `div:before` in the above css). The parent of the pseudo element is overflow hidden. Here's the full CSS. Feel free to email me if you want to know more. I may post more on this later.</p>\n","slug":"css-serpinski-triangle","published":1,"date":"2016-01-25T04:28:19.928Z","updated":"2016-01-25T04:28:19.928Z","comments":1,"photos":[],"link":"","_id":"cijth4l9h00000nfwfjhslgym"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2016-01-25T04:26:20.996Z","updated":"2016-01-25T04:26:20.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijth4lba000j0nfwnaa9j87m"},{"title":"what","date":"2016-01-25T04:21:00.000Z","_content":"","source":"_posts/2016/01/what.md","raw":"---\ntitle: what\ndate: 2016-01-24 23:21:00\ntags:\n---\n","slug":"what","published":1,"updated":"2016-01-25T04:28:19.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijth4lbf000k0nfwunr3f8r8"},{"title":"Vanilla Javascript Scroll Header","date":"2016-01-22T16:22:52.000Z","_content":"\nOpening external links in new tabs, carousels, spamming visitors; as a developer there are many ideas that clients insist on that I am opposed to. But one of the more persistent one annoyances is a header bar with `position: fixed`. I am personally opposed to it because most users understand how to scroll up (they did scroll down, right?), and it takes up valuable screen space on mobile phones. So I decided to make a scroll header. Similar to angular or material design or the address bar in mobile chrome, the top nav of the site stays hidden until the user scrolls up. The header is slowly revealed until it is fully visible and then stays fixed as long as the user is scrolling up. When the user scrolls down again the header subtly disappears exactly as it would at the top of the page. I also made a <a href=\"https://jsfiddle.net/chriscauley/aqsnsegh/1/\">live demo on jsfiddle</a> if you prefer.\n\n{% include_code lang:js 2016/01/scroll.js %}\n\nHere's the css I used. Really you can change whatever you want except the final line, so don't feel married to any of this.\n\n{% include_code 2016/01/scroll.css %}\n","source":"_posts/2016/01/scroll-header.md","raw":"---\ntitle: \"Vanilla Javascript Scroll Header\"\ndate: 2016-01-22 11:22:52\ntags: javascript,widget,scroll header\n---\n\nOpening external links in new tabs, carousels, spamming visitors; as a developer there are many ideas that clients insist on that I am opposed to. But one of the more persistent one annoyances is a header bar with `position: fixed`. I am personally opposed to it because most users understand how to scroll up (they did scroll down, right?), and it takes up valuable screen space on mobile phones. So I decided to make a scroll header. Similar to angular or material design or the address bar in mobile chrome, the top nav of the site stays hidden until the user scrolls up. The header is slowly revealed until it is fully visible and then stays fixed as long as the user is scrolling up. When the user scrolls down again the header subtly disappears exactly as it would at the top of the page. I also made a <a href=\"https://jsfiddle.net/chriscauley/aqsnsegh/1/\">live demo on jsfiddle</a> if you prefer.\n\n{% include_code lang:js 2016/01/scroll.js %}\n\nHere's the css I used. Really you can change whatever you want except the final line, so don't feel married to any of this.\n\n{% include_code 2016/01/scroll.css %}\n","slug":"scroll-header","published":1,"updated":"2016-01-25T04:28:19.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijth4lbj000l0nfwbjf8dch6"},{"title":"Riot Tabs","date":"2016-01-24T05:05:52.000Z","_content":"\n{% raw %}\n<ur-tabs>\n  <ur-tab id=\"Some Content\">\n    <p>Sed fermentum lorem vitae leo sodales, ac placerat lacus ornare. Duis semper nulla vitae pharetra aliquam. Curabitur leo urna, euismod eget blandit eu, condimentum ut nisi. Sed ultricies mi nunc, in vulputate nibh eleifend et. Cras faucibus massa nec elementum varius. Quisque diam justo, blandit eget erat vel, suscipit lobortis nulla. Aenean non risus vel lorem scelerisque ultricies at ac orci. Pellentesque a lacinia libero. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.</p>\n  </ur-tab>\n  <ur-tab id=\"More Content\">\n    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse cursus scelerisque iaculis. Duis erat sapien, auctor in auctor quis, dapibus non elit. Proin varius malesuada est in tincidunt. Aenean commodo quis eros placerat malesuada. Suspendisse potenti. Proin nunc nisl, porta nec velit in, feugiat maximus diam. Aliquam erat volutpat. Suspendisse arcu dolor, porta vel nisl quis, pellentesque tincidunt massa. Donec bibendum eleifend arcu, non elementum mauris ornare at. Quisque eget diam eu mauris consequat fringilla. Ut convallis mollis neque. Donec id tortor ac diam consectetur faucibus nec eget nunc.</p>\n    <p>Sed at luctus neque, at mollis nunc. Sed accumsan libero ac lorem pharetra elementum eget sed mi. In eu mi non mi laoreet sagittis. Aliquam venenatis consectetur lacus a maximus. Suspendisse sit amet quam non ipsum placerat mattis at et dui. Donec sit amet nunc sagittis, tincidunt sem id, tincidunt augue. Nulla in sollicitudin arcu, ut tristique est. Aliquam erat augue, placerat et vulputate congue, scelerisque quis urna. Suspendisse ante urna, commodo vel lorem eu, elementum imperdiet lorem. Proin fermentum dolor enim, quis porta massa egestas in. Aliquam interdum est nec elit aliquam gravida. Sed in libero et diam lacinia rutrum in sed lorem. Integer ut nisl ut purus iaculis aliquam.</p>\n  </ur-tab>\n</ur-tabs>\n{% endraw %}\n","source":"_posts/2016/01/Riot-Tabs.md","raw":"---\ntitle: Riot Tabs\ndate: 2016-01-24 00:05:52\ntags:\n---\n\n{% raw %}\n<ur-tabs>\n  <ur-tab id=\"Some Content\">\n    <p>Sed fermentum lorem vitae leo sodales, ac placerat lacus ornare. Duis semper nulla vitae pharetra aliquam. Curabitur leo urna, euismod eget blandit eu, condimentum ut nisi. Sed ultricies mi nunc, in vulputate nibh eleifend et. Cras faucibus massa nec elementum varius. Quisque diam justo, blandit eget erat vel, suscipit lobortis nulla. Aenean non risus vel lorem scelerisque ultricies at ac orci. Pellentesque a lacinia libero. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.</p>\n  </ur-tab>\n  <ur-tab id=\"More Content\">\n    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse cursus scelerisque iaculis. Duis erat sapien, auctor in auctor quis, dapibus non elit. Proin varius malesuada est in tincidunt. Aenean commodo quis eros placerat malesuada. Suspendisse potenti. Proin nunc nisl, porta nec velit in, feugiat maximus diam. Aliquam erat volutpat. Suspendisse arcu dolor, porta vel nisl quis, pellentesque tincidunt massa. Donec bibendum eleifend arcu, non elementum mauris ornare at. Quisque eget diam eu mauris consequat fringilla. Ut convallis mollis neque. Donec id tortor ac diam consectetur faucibus nec eget nunc.</p>\n    <p>Sed at luctus neque, at mollis nunc. Sed accumsan libero ac lorem pharetra elementum eget sed mi. In eu mi non mi laoreet sagittis. Aliquam venenatis consectetur lacus a maximus. Suspendisse sit amet quam non ipsum placerat mattis at et dui. Donec sit amet nunc sagittis, tincidunt sem id, tincidunt augue. Nulla in sollicitudin arcu, ut tristique est. Aliquam erat augue, placerat et vulputate congue, scelerisque quis urna. Suspendisse ante urna, commodo vel lorem eu, elementum imperdiet lorem. Proin fermentum dolor enim, quis porta massa egestas in. Aliquam interdum est nec elit aliquam gravida. Sed in libero et diam lacinia rutrum in sed lorem. Integer ut nisl ut purus iaculis aliquam.</p>\n  </ur-tab>\n</ur-tabs>\n{% endraw %}\n","slug":"Riot-Tabs","published":1,"updated":"2016-01-25T04:28:19.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cijth4lbm000o0nfw99nkfo0w"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cijth4l9h00000nfwfjhslgym","tag_id":"cijth4l9q00010nfwiaqn2fo6","_id":"cijth4l9t00030nfwgbeza87k"},{"post_id":"cijth4l9h00000nfwfjhslgym","tag_id":"cijth4l9t00020nfw61jscyn7","_id":"cijth4l9u00040nfwjpt2wj9k"},{"post_id":"cijth4lbj000l0nfwbjf8dch6","tag_id":"cijth4lbk000m0nfwe68f1cpp","_id":"cijth4lbl000n0nfwupecfduk"}],"Tag":[{"name":"css","_id":"cijth4l9q00010nfwiaqn2fo6"},{"name":"fractals","_id":"cijth4l9t00020nfw61jscyn7"},{"name":"javascript,widget,scroll header","_id":"cijth4lbk000m0nfwe68f1cpp"}]}}